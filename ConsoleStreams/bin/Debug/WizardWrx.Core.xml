<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WizardWrx.Core</name>
    </assembly>
    <members>
        <member name="T:WizardWrx.Core.AgedFileInfo">
            <summary>
            This class extends a FileInfo object with a custom IComparable interface
            implementation.
            </summary>
            <remarks>
            This class and AgedFileInfoCollection are designed to be used together 
            to achieve the goal of processing a list of the files that match a file
            specification from newest to oldest.
            
            These objects are not intended for independent use, since they must go
            into a collection that can be sorted to leverage the IComparable
            interface implementation that permits them to be sorted in reverse order
            by LastWriteTimeUTC.
            
            Each AgedFileInfo is a FileInfo object, wrapped in a small class that
            augments it with a custom IComparable interface implementation that
            allows the list to be sorted by LastWriteTimeUTC. Using LastWriteTimeUTC
            guarantees that the files are always sorted correctly, even when the set
            includes one or more files that were created during the transition hour
            that occurs twice annually, on the days when the transitions to and from
            Daylight Saving Time occur. LastWriteTimeUTC time stamps created during
            this hour are not guaranteed to sort correctly, especially during the
            "fall back" transition that occurs in Autumn, when the local time is set
            back by 1 hour, so that there are two hours during which the same local
            hour is reported.
            
            In the course of investigating an unexpected exception, I again read the
            recommendation from Microsoft (published in the MSDN library) about
            overriding other methods (Equals and GetHashCode), implementing other
            interfaces (IEquatable and IEqualityComparer), and overloading the
            equality and inequality operators, all of which I went ahead and did,
            even though doing so is almost certainly overkill for this class.
            </remarks>
            <see cref="T:WizardWrx.Core.AgedFileInfoCollection"/>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfo.#ctor">
            <summary>
            The default constructor would be private, except that I believe that
            it must be marked as Public to satisfy the IComparable and IList
            interfaces.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfo.#ctor(System.IO.FileInfo)">
            <summary>
            The single overloaded constructor stashes a reference to a FileInfo,
            which this class augments with a custom implementation of the
            IComparable interface that supports inverse ordering.
            </summary>
            <param name="pfileInfo">
            Pass in a reference to the FileInfo to be stored in the instance.
            </param>
        </member>
        <member name="P:WizardWrx.Core.AgedFileInfo.Details">
            <summary>
            Return a reference to the FileInfo that was loaded into the
            constructor.
            </summary>
            <remarks>
            While this protects the reference against destruction, it doesn't
            prevent callers from changing read/write properties. For that, each
            property must be individually exposed as a read-only property.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfo.ToString">
            <summary>
            Override the base class ToString method, so that it renders the most
            critical properties of the underlying file.
            </summary>
            <returns>
            The returned string lists the name of the exporting class, as usual,
            but followed immediately by the key properties that a debugger will
            most likely need.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfo.Equals(System.Object)">
            <summary>
            Override the base imp0lementation of the Equals method to return a
            result that is consistent with the algorithm implemented by the
            IComparable interface.
            </summary>
            <param name="obj">
            The object against which to compare must be another AgedFileInfo, or
            the return value is False.
            </param>
            <returns>
            The returned Boolean value is that returned by comparing the two
            _fileInfo.LastAccessTimeUtc.Ticks property values.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfo.GetHashCode">
            <summary>
            Override the base GetHashCode method to return a result that is
            consistent with the algorithm implemented by the IComparable
            interface.
            </summary>
            <returns>
            The return value is the HashCode of the LastWriteTimeUTC.Ticks
            property of the underlying FileInfo object.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.AgedFileInfoCollection">
            <summary>
            This class hides its data in a List of AgedFileInfo objects, which its
            constructors assemble from permutations of the array of FileInfo objects
            returned by the GetFiles method on the DirectoryInfo instance that is
            fed into it.
            </summary>
            <remarks>
            This class and AgedFileInfo are designed to be used together to
            achieve the goal of processing a list of the files that match a file
            specification from newest to oldest.
            
            Each AgedFileInfo is a FileInfo object, wrapped in a small class that
            augments it with a custom IComparable interface implementation that
            allows the list to be sorted by LastWriteTimeUTC. Using LastWriteTimeUTC
            guarantees that the files are always sorted correctly, even when the set
            includes one or more files that were created during the transition hour
            that occurs twice annually, on the days when the transitions to and from
            Daylight Saving Time occur. LastWriteTimeUTC time stamps created during
            this hour are not guaranteed to sort correctly, especially during the
            "fall back" transition that occurs in Autumn, when the local time is set
            back by 1 hour, so that there are two hours during which the same local
            hour is reported.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.#ctor">
            <summary>
            To ensure that a populated collection is always created, the default
            constructor is hidden.
            </summary>
            <remarks>
            Apart from the constructors, this class is implemented entirely by
            its base class.
            
            This class and AgedFileInfo are designed to be used together to
            achieve the goal of processing a list of the files that match a file
            specification from newest to oldest.
            </remarks>
            <see cref="T:WizardWrx.Core.AgedFileInfo"/>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo)">
            <summary>
            The simplest of the three public constructors takes a reference to a
            DirectoryInfo collection, which is loaded in its entirety.
            </summary>
            <param name="pdirInfoCollection">
            The DirectoryInfo collection from which to populate the instance
            </param>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String)">
            <summary>
            A slightly more advanced constructor restricts the files to those
            that match a standard file name mask.
            </summary>
            <param name="pdirInfoCollection">
            The DirectoryInfo collection from which to populate the instance
            </param>
            <param name="pstrFileSpec">
            The string to employ as a search mask
            </param>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String,System.IO.SearchOption)">
            <summary>
            The most advanced constructor includes the restriction to a file name mask, to which it adds a SearchOption enumeration member that specifies whether to apply the mask to subdirectories.
            </summary>
            <param name="pdirInfoCollection">
            The DirectoryInfo collection from which to populate the instance
            </param>
            <param name="pstrFileSpec">
            The string to employ as a search mask
            </param>
            <param name="penmSearchOption">
            The SearchOption that determines whether subdirectories are searched or ignored
            </param>
        </member>
        <member name="P:WizardWrx.Core.AgedFileInfoCollection.Count">
            <summary>
            Read the count off the private list.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo">
            <summary>
            Unless the list is empty, return the newest file in it, which is the
            first file in the list, since it is reverse sorted by LastWriteTime.
            </summary>
            <returns>
            The returned FileInfo object represents the newest file in the list,
            which occupies its first slot, since the list is sorted in reverse
            order by LastWriteTimeUTC.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo">
            <summary>
            Unless the list is empty, return the oldest file in it, which is the
            last file in the list, since it is reverse sorted by LastWriteTime.
            </summary>
            <returns>
            The returned FileInfo object represents the oldest file in the list,
            which occupies its last slot, since the list is sorted in reverse
            order by LastWriteTimeUTC.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AgedFileInfoCollection.InitializeAndSortList(System.IO.FileInfo[])">
            <summary>
            Once the array of matching files is filled, all three public constructors do the same thing with it.
            </summary>
            <param name="pafiMatchingFiles">
            Since the array is redundant once it has been loaded into the list, it has method scope.
            </param>
        </member>
        <member name="T:WizardWrx.Core.AssemblyLocatorBase">
            <summary>
            Use a class derived from this class to get the fully qualified name of
            the file from which the assembly in which the derived class is defined
            was loaded. See Remarks.
            </summary>
            <remarks>
            Given the location from which an assembly was loaded, you can learn
            almost anything else you need to know about that file, such as its size,
            age, version, and directory. Given the directory, you can locate
            satellite files, such as configuration files that contain settings that
            it uses.
            </remarks>
            <seealso cref="T:WizardWrx.Core.PropertyDefaults"/>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN">
            <summary>
            Use this token in file names stored in DLL configuration files to
            explicitly state that the file is expected to inhabit the directory
            from which the assembly is loaded, unless the assembly was loaded
            from the Global Assembly Cache (GAC). In that case, substitute the
            application directory.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts">
            <summary>
            SetPropertiesFromDLLConfiguration fills and returns this structure,
            to account for all defined properties, whether or not their values
            are configured.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration">
            <summary>
            Count of properties read from the configuration file.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.Defaulted">
            <summary>
            Count of properties omitted from the configuration file, and
            left at their default values.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation">
            <summary>
            Once the energy required to gather the location has been expended,
            save it for future use.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase._strAssemblyDataPath">
            <summary>
            Likewise, hang onto the AssemblyDataPath.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.AssemblyLocatorBase._strAssemblyConfigPath">
            <summary>
            The assembly configuration file has the same name as does the
            assembly, with an extension of .config appended. However, if the DLL
            loaded from the GAC, its configuration file must live in the
            application directory.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.#ctor">
            <summary>
            Initialize the one and only property of this class, which holds the
            fully qualified path from which the containing assembly was loaded.
            
            Use this constructor to link the configuration file to the assembly
            that defines this class.
            </summary>
            <remarks>
            IMPORTANT: If the assembly loads from the Global Assembly Cache, its
            configuration file must be stored in the application directory. Be
            aware that if an assembly exists in the Global Assembly Cache, it
            loads from there, even if there is a copy in the application
            directory.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.#ctor(System.Reflection.Assembly)">
            <summary>
            Initialize the one and only property of this class, which holds the
            fully qualified path from which the containing assembly was loaded.
            
            Use this constructor to link the configuration file to the assembly
            that defines this class.
            </summary>
            <param name="pasmLinkedAssembly">
            Pass in a reference to the assembly to which the configuration file
            is linked. For example, you can use the executing assembly of the
            object at the top of the inheritance tree.
            </param>
            <remarks>
            IMPORTANT: If the assembly loads from the Global Assembly Cache, its
            configuration file must be stored in the application directory. Be
            aware that if an assembly exists in the Global Assembly Cache, it
            loads from there, even if there is a copy in the application
            directory.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath">
            <summary>
            Gets a string containing the fully qualified path of the directory
            from which the assembly was loaded, unless it was loaded from the
            Global Assembly Cache (GAC). In that case, the return value is the
            fully qualified name of the directory from which the first assembly
            was loaded into the current process. See Remarks.
            </summary>
            <remarks>
            So far as I know, assemblies must load from one of two locations.
            Unsigned assemblies MUST load from the application directory. If the
            assembly is signed with a strong name, it MAY  be loaded from either
            the application directory or the Global Assembly Cache. If a signed
            assembly is in the local GAC, it loads from there, even if there is
            a copy in the application directory.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation">
            <summary>
            Gets a string containing the fully qualified file name from which
            the assembly in which the derived class is defined was loaded.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions">
            <summary>
            This read only property returns a generic List of Exceptions that
            arose during the initialization phase of an instance, and were
            silently recovered, so that they can be reported for investigation.
            </summary>
            <remarks>
            This property supersedes ConfigMessage, which returned the list of
            exceptions as one long string, discarding their all-important stack
            traces.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings">
            <summary>
            This read-only property returns a generic List of string, each of
            which is a message that names a property that was omitted from the
            configuration file, along with its default value.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration">
            <summary>
            Gets a reference to the entire Configuration object tied to the
            assembly in which the derived class is defined.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection">
            <summary>
            Gets a reference to the entire AppSettingsSection object tied to
            the assembly in which the derived class is defined.
            </summary>
            <remarks>
            Since this property starts from the ConfigurationManager object
            returned by its DLLConfiguration sibling, it requires only a single
            statement, with a little help from an explicit cast.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.AssemblyLocatorBase.DLLSettings">
            <summary>
            Gets the DLL Settings section as a KeyValueConfigurationCollection.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.SaveErrorReport(System.Type,System.String,System.Exception)">
            <summary>
            Protected method SetPropertiesFromDLLConfiguration calls this
            routine to assemble an error message for appending to a string, for
            subsequent review by callers of derived classes.
            </summary>
            <param name="pderivedType">
            The derived type is listed in the report.
            </param>
            <param name="pstrPropertyName">
            The property name is listed in the report.
            </param>
            <param name="pexAllKinds">
            The message, presumably reporting a missing configuration item,
            completes the message.
            </param>
            <returns>
            The return value is a string, ready to be appended to the
            ConfigMessage string.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate(System.DateTimeKind)">
            <summary>
            Return the LastWriteTime of the file that contains the executing
            assembly. For all practical purposes, that is the date on which the
            assembly was built.
            </summary>
            <param name="pdtmKind">
            This DateTimeKind enumeration member specifies whether to report the
            LastWriteTime or the LastWriteTimeUtc.
            </param>
            <returns>
            The return value is a fully initialized DateTime structure, which
            contains the requested LastWriteTime (Local or UTC) of the file that
            contains the code of the executing assembly.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion">
            <summary>
            Return the Version structure, to expedite parsing its parts.
            </summary>
            <returns>
            The return value is the version component of the fully qualified
            assembly name.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString">
            <summary>
            Return the complete version of the executing assembly.
            </summary>
            <returns>
            The return value is a string representation of all version number
            "octets" - Major, Minor, Build, and Revision.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)">
            <summary>
            Return the specified setting value, as a string.
            </summary>
            <param name="pstrSettingsKey">
            This string is the name (key) of the desired setting.
            </param>
            <returns>
            The return value is a string representation of the value stored in
            the named key.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)">
            <summary>
            Set the like named properties from the linked configuration file.
            </summary>
            <param name="pderivedType">
            When the derived class constructor calls this method, it must pass in a
            reference to its own Type property.
            </param>
            <returns>
            The return value is the count of properties that were set.
            </returns>
            <remarks>
            This can almost certainly be simplified by enumerating the settings,
            but either way risks a NOT FOUND exception.
            
            This method uses some fairly tricky Reflection gymnastics to map the
            key names in a configuration file to property names on an object.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.FromString(System.Reflection.PropertyInfo,System.String)">
            <summary>
            Create an object of the correct type from a string. Please see the
            Remarks section for important information.
            </summary>
            <param name="piThisProperty">
            The PropertyInfo identifies the name and type of the property to be
            converted. Please see the Remarks section for important information.
            </param>
            <param name="strConfigValueString">
            Since they are essentially untyped, the inputs from application
            configuration files always arrive as a string.
            </param>
            <returns>
            The return value is a new object of the desired type, containing
            enough type information to permit it to be implicitly cast to the
            desired ultimate type.
            </returns>
            <remarks>
            For conversion purposes, objects fall into two groups: enumerations,
            and everything else.
            
            Segregating inputs into the correct group is done by evaluating
            the PropertyType.BaseType property of the input PropertyInfo object,
            since enumerations derive from a distinct base type, System.Enum.
            
            Everything else derives from System.Object, and its conversion is
            handled by the SetValue method on the supplied PropertyInfo object.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.AssemblyLocatorBase.InitializeInstance">
            <summary>
            Both constructors call this method to finish initializing the
            instance. Private string member _strAssemblyLocation must be
            initialized before the constructor calls this method.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.BasicSystemInfoDisplayMessages">
            <summary>
            The static methods exposed by this class simplify displaying information
            about the processor on which the calling process is executing that is
            otherwise hard to determine accurately.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K">
            <summary>
            Use as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 2000 or newer.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA">
            <summary>
            Use as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows Vista or newer.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8">
            <summary>
            Use as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 8 or newer.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10">
            <summary>
            Use as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 10 or newer.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE">
            <summary>
            Use as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for even numbered (.0) versions of Windows (e. g., Win28, Vista, 8.0, 10.0).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1">
            <summary>
            Use as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for point versions of Windows (e. g., Windows XP (5.1), Windows 7 (which has an internal version number of 6.1), etc.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2">
            <summary>
            Use as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for point two versions of Windows (e. g., Windows Server 2003, 2008, 2012).
            </summary>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture">
            <summary>
            Get a ProcessorArchitecture enumeration member that specifies the
            processor architecture.
            </summary>
            <returns>
            The return value is a member of the ProcessorArchitecture
            enumeration that specifies the type of processor installed on the
            machine.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture">
            <summary>
            Get a string that describes the processor architecture and the size,
            in bits, of the machine word of the subsystem in which the calling
            process is executing.
            </summary>
            <returns>
            The return value is a string of the following form.
            
            Processor Architecture = ProcessorArchitecture
            Process Machine Word   = NN bits
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer">
            <summary>
            Evaluate whether the operating system is at least Windows Vista.
            </summary>
            <returns>
            Return TRUE if the calling process is executing on Windows Vista or
            newer. Otherwise, return FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer">
            <summary>
            Evaluate whether the operating system is at least Windows XP.
            </summary>
            <returns>
            Return TRUE if the calling process is executing on Windows XP or
            newer. Otherwise, return FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer">
            <summary>
            Evaluate whether the operating system is at least Windows 7.
            </summary>
            <returns>
            Return TRUE if the calling process is executing on Windows 7 or
            newer. Otherwise, return FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(System.Int32)">
            <summary>
            Evaluate whether the operating system is at least equal to the
            specified major version number.
            </summary>
            <returns>
            Return TRUE if the calling process is executing on the specified
            major version number of Windows or newer. Otherwise, return FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(System.Int32,System.Int32)">
            <summary>
            Evaluate whether the operating system is at least equal to the
            specified major and minor version number.
            </summary>
            <returns>
            Return TRUE if the calling process is executing on the specified
            major and minor version number of Windows or newer. Otherwise,
            return FALSE.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.ByteArrayFormatters">
            <summary>
            The static methods in this class format byte arrays into strings of
            hexadecimal numerals for display on reports and in windows.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4">
            <summary>
            Use this to set ByteArrayToHexDigitString argument puintGroupSize to
            insert a space between every 4th byte.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8">
            <summary>
            Use this to set ByteArrayToHexDigitString argument puintGroupSize to
            insert a space between every 8th byte.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING">
            <summary>
            Use this to set ByteArrayToHexDigitString argument puintGroupSize to
            format the string without any spaces.
            </summary>
            <remarks>
            This constant is intended primarily for internal use by the first
            overload, which omits the second argument, to call the second
            overload, which does the work.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[])">
            <summary>
            Convert a byte array into a printable hexadecimal representation.
            </summary>
            <param name="pbytInputData">
            Specify the byte array to be formatted. Any byte array will do.
            </param>
            <returns>
            The return value is a string that contains two characters for each
            byte in the array.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[],System.UInt32)">
            <summary>
            Convert a byte array into a printable hexadecimal representation.
            </summary>
            <param name="pbytInputData">
            Specify the byte array to be formatted. Any byte array will do.
            </param>
            <param name="puintGroupSize">
            Specify the number of bytes to display as a group.
            </param>
            <returns>
            The return value is a string that contains two characters for each
            byte in the array, plus one space between every puintGroupSizeth
            byte.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.CmdLneArgsBasic">
             <summary>
             An instance of this class efficiently processes command line switches,
             named arguments, and positional arguments, in such a way that they are
             easily accessible. The command line is completely parsed in a single
             pass.
            
             Switches, named arguments, and positional arguments may be freely mixed
             in any way; your users aren't confined to specifying all switches and/or
             named arguments first, last, or in any other order.
            
             Since command line parsing happens in the constructor, your code must
             define all the rules in its parameters. To that end, there are 26
             constructors, which provide access to all of the rich capabilities of
             this object. In spite of the multitude of constructors, their
             organization, coupled with consistent naming and documentation of their
             arguments, is intended to make their features readily accessible.
            
             While it is fairly trivial to reverse engineer the underlying Dictionary
             object, and read the arguments directly, the supported method of reading
             them is through its methods: GetArgByName, GetArgByPosition, and
             GetSwitchByName.
             </summary>
        </member>
        <member name="T:WizardWrx.Core.CmdLneArgsBasic.ArgMatching">
            <summary>
            Argument matching may be either case sensitive (default) or case
            insensitive (by constructor override). Constructor argument
            penmArgMatching is of this type.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseSensitive">
            <summary>
            Argument matching is case sensitive.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseInsensitive">
            <summary>
            Argument matching is case insensitive.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.CmdLneArgsBasic.ArgType">
             <summary>
             Arguments may be of three types:
            
             1) Named
             2) Positional
             3) Switch
            
             Further, the first and third types may be invalid arguments of their
             respective types. That is, a switch may be invalid, or the name of a
             Named Argument may be invalid.        ///
             </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidNamed">
            <summary>
            The specified argument appears to be a named argument, but its
            name is undefined (not on the list of valid names).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidSwitch">
            <summary>
            The specified argument appears to be a switch, but its name is
            undefined (not on the list of valid switch characters).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Named">
            <summary>
            The argument is named, and its value is in the list of valid
            names.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Positional">
            <summary>
            The argument is positional. That is, it is neither a named
            argument, nor a switch. Its meaning is defined by its order of
            appearance in the command line.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Switch">
            <summary>
            The argument is a switch, and its value is in the list of valid
            switch characters.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_HAS_ARGS">
            <summary>
            When the ArgListIsEmpty property has this value, the command line
            contains at least one argument. See Remarks.
            </summary>
            <remarks>
            ArgListIsEmpty being false means only that there is an argument in
            the command line, which may be invalid. Check the ArgMatching array
            or the two invalid argument counters, InvalidNamedArgsInCmd and
            InvalidSwitchesInCmd.
            </remarks>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_IS_EMPTY">
            <summary>
            When the ArgListIsEmpty property has this value, the command line is
            empty, consisting solely of the name of the executing assembly.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED">
            <summary>
            When the AllowEmptyStringAsDefault property has this value, an empty
            string is permitted as a default value. See the Remarks section of 
            the on-line documentation of the AllowEmptyStringAsDefault property
            for complete details.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN">
            <summary>
            When the AllowEmptyStringAsDefault property has this value, an empty
            string as a default value is forbidden. See the Remarks section of 
            the on-line documentation of the AllowEmptyStringAsDefault property
            for complete details.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.FIRST_POSITIONAL_ARG">
            <summary>
            Use this constant with the GetArgByPosition method to get the first
            positional argument, or as the initializer of a For loop to get all
            positional arguments.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.NAME_VALUE_DELIMITER">
            <summary>
            This class uses the equal sign as its delimiter between the name and
            value of named arguments.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.NONE">
            <summary>
            Counts are initialized to this value (zero). Making it public
            simplifies coding well-documented tests.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT">
            <summary>
            This constant defines the default number of positional arguments
            that instances of this class will capture.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.CmdLneArgsBasic.VALUE_NOT_SET">
            <summary>
            This symbolic constant maps to the empty string, and indicates that
            a specified named or positional argument was omitted from the
            command line.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor">
            <summary>
            Initialize an instance that supports exclusively positional
            arguments.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Int32)">
             <summary>
             Initialize an instance that supports exclusively positional
             arguments, and enforces a user-specified limit, in lieu of a default
             limit of 99 positional arguments
            
             Please see Remarks for important security considerations.
             </summary>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[])">
            <summary>
            Initialize the instance with a list of valid switches, all having a
            default value of Properties.Resources.SWITCH_IS_OFF.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[])">
            <summary>
            Initialize the instance with a list of valid named arguments, each
            having a default value of VALUE_NOT_SET.
            </summary>
            <param name="pastrValidNamedArgs">
            Array of strings, each of which is a valid (supported) argument
            name. All arguments are initialized to VALUE_NOT_SET.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[])">
            <summary>
            Initialize the instance with lists of valid switches and named arguments.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
            <param name="pastrValidNamedArgs">
            Array of strings, each of which is a valid (supported) argument
            name. All arguments are initialized to VALUE_NOT_SET.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String})">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the value specified in the corresponding item in pdctValidSwitches.
            </summary>
            <param name="pdctValidSwitches">
            Dictionary, keyed by switch name, a character, containing its desired
            default value, a string.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initialize the instance with a list of valid named arguments, each
            having the default value specified in the corresponding item in
            pdctValidNamedArgs.
            </summary>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the default value specified in the corresponding item in
            pdctValidSwitches, and a separate list of valid named arguments,
            defined in the same manner.
            </summary>
            <param name="pdctValidSwitches">
            Dictionary, keyed by switch name, a character, containing its desired
            default value, a string.
            </param>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid switches, all having a
            default value of Properties.Resources.SWITCH_IS_OFF.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid named arguments, each
            having a default value of VALUE_NOT_SET.
            </summary>
            <param name="pastrValidNamedArgs">
            Array of strings, each of which is a valid (supported) argument
            name. All arguments are initialized to VALUE_NOT_SET.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with lists of valid switches and named arguments.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
            <param name="pastrValidNamedArgs">
            Array of strings, each of which is a valid (supported) argument
            name. All arguments are initialized to VALUE_NOT_SET.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the value specified in the corresponding item in pdctValidSwitches.
            </summary>
            <param name="pdctValidSwitches">
            Dictionary, keyed by switch name, a character, containing its desired
            default value, a string.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid named arguments, each
            having the default value specified in the corresponding item in
            pdctValidNamedArgs.
            </summary>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the default value specified in the corresponding item in
            pdctValidSwitches, and a separate list of valid named arguments,
            defined in the same manner.
            </summary>
            <param name="pdctValidSwitches">
            Dictionary, keyed by switch name, a character, containing its desired
            default value, a string.
            </param>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, all having a
             default value of Properties.Resources.SWITCH_IS_OFF.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],System.Int32)">
             <summary>
             Initialize the instance with a list of valid named arguments, each
             having a default value of VALUE_NOT_SET.
             </summary>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],System.Int32)">
             <summary>
             Initialize the instance with lists of valid switches and named arguments.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the value specified in the corresponding item in pdctValidSwitches.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
             <summary>
             Initialize the instance with a list of valid named arguments, each
             having the default value specified in the corresponding item in
             pdctValidNamedArgs.
             </summary>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the default value specified in the corresponding item in
             pdctValidSwitches, and a separate list of valid named arguments,
             defined in the same manner.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, all having a
             default value of Properties.Resources.SWITCH_IS_OFF.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid named arguments, each
             having a default value of VALUE_NOT_SET.
             </summary>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with lists of valid switches and named arguments.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the value specified in the corresponding item in pdctValidSwitches.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid named arguments, each
             having the default value specified in the corresponding item in
             pdctValidNamedArgs.
             </summary>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the default value specified in the corresponding item in
             pdctValidSwitches, and a separate list of valid named arguments,
             defined in the same manner.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the default value specified in the corresponding item in
            pdctValidSwitches, and a separate list of valid named arguments, in
            an array of strings, with the class supplying a standard default.
            </summary>
            <param name="pdctValidSwitches">
            Dictionary, keyed by switch name, a character, containing its desired
            default value, a string.
            </param>
            <param name="pastrValidNamedArgs">
            Array of strings, each of which is a valid (supported) argument
            name. All arguments are initialized to VALUE_NOT_SET.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)">
            <summary>
            Initialize the instance with a list of valid named arguments, in
            a dictionary strings, where each value is the corresponding default,
            and a list of valid switches in an array of characters, with their
            default values as the class default.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
            <param name="penmArgMatching">
            Use this member of the CmdLneArgs.ArgMatching enumeration to set the
            argument matching rules. At present, two rules are defined. See the
            IntelliSense documentation of any CmdLneArgs argument for details.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initialize the instance with a list of valid switches, each having
            the default value defined by the class, and a separate list of valid
            named arguments, each defined as a DictionaryItem, with its default
            value given in the value member.
            </summary>
            <param name="pachrValidSwitches">
            Array of characters, each of which is a valid (supported) switch.
            All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
            </param>
            <param name="pdctValidNamedArgs">
            Dictionary, keyed by argument name, a string, containing its desired
            default value, also a string.
            </param>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the default value defined by the class, and a separate list of valid
             named arguments, each defined as a DictionaryItem, with its default
             value given in the value member.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             its default value defined by the value member of a DictionaryItem,
             and a separate list of valid named arguments, each defined as a
             DictionaryItem, with its default value given in the value member.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="penmArgMatching">
             Use this member of the CmdLneArgs.ArgMatching enumeration to set the
             argument matching rules. At present, two rules are defined. See the
             IntelliSense documentation of any CmdLneArgs argument for details.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             the default value defined by the class, and a separate list of valid
             named arguments, each defined as a DictionaryItem, with its default
             value given in the value member.
             </summary>
             <param name="pachrValidSwitches">
             Array of characters, each of which is a valid (supported) switch.
             All switches are initialized to Properties.Resources.SWITCH_IS_OFF.
             </param>
             <param name="pdctValidNamedArgs">
             Dictionary, keyed by argument name, a string, containing its desired
             default value, also a string.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],System.Int32)">
             <summary>
             Initialize the instance with a list of valid switches, each having
             its default value defined by the value member of a DictionaryItem,
             and a separate list of valid named arguments, defined in an array of
             strings, with the default value supplied by the class.
             </summary>
             <param name="pdctValidSwitches">
             Dictionary, keyed by switch name, a character, containing its desired
             default value, a string.
             </param>
             <param name="pastrValidNamedArgs">
             Array of strings, each of which is a valid (supported) argument
             name. All arguments are initialized to VALUE_NOT_SET.
             </param>
             <param name="pintPositionalArgCountLimit">
             The default limit on the number of positional arguments is
             POSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this
             argument to set a lower or higher limit.
            
             A pintPositionalArgCountLimit value of less than zero is discarded
             silently, and the default limit remains in force.
            
             Please see Remarks for important security considerations.
             </param>
             <remarks>
             SECURITY NOTE
            
             All constructors in this class enforce a limit on the number of
             positional arguments permitted. The default limit is 9, which is
             defined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.
            
             This limit is imposed to protect your program from being fed an
             excessively long command line, in an attempt to cause a denial of
             service. Although few applications require more than nine positional
             command line arguments, the level is made adjustable, to meet that
             once per career need for more than nine arguments.
            
             While objects of this class cannot do anything about the number of
             characters in the command line (That is the responsibility of the
             Common Language Runtime.), they can, and do, limit the amount of
             memory allowed to be consumed to hold arguments parsed from it.
            
             No such limits are imposed on switches and named arguments, because
             the number of valid arguments (hence, the upper limit on memory
             consumed by them) is under programmer control, and unlikely to be an
             issue, since invalid arguments are discarded.
            
             WHY NINE?
            
             I chose the number nine mostly for historical reasons. Starting with
             MS-DOS 1.0, the number of positional parameters supported by batch
             files (without resorting to tricks with SHIFT) is 9.
            
             This limit has been carried forward into modern command processors,
             including CMD.EXE, the default console mode command processor of
             Windows NT, 2000, XP, Vista, etc.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases(System.String[])">
            <summary>
            Return the value of an argument that has two or more aliases.
            </summary>
            <param name="pastrValiddArgNames">
            This is an array of strings, each of which is the name of a command
            line argument that is a synonym. See Remarks.
            </param>
            <returns>
            The return value is the specified value, or its default value, of
            none of the synonyms appears in the input. See Remarks.
            </returns>
            <remarks>
            Arguments are evaluated in the order specified in pastrValiddArgNames,
            Synonyms are assumed to return the same default value.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pstrDefault is
            returned.
            </returns>
            <remarks>
            This overload is a wrapper around the second overload,
            GetArgByName ( int, string ), which does the real work.
            This method calls it internally, passing a default value of
            VALUE_NOT_SET.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pstrDefault">
            Specify a default value to return if the argument was omitted from
            the command line, or VALUE_NOT_SET or a null reference (Nothing in
            Visual Basic), to use an empty string as the default.
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pstrDefault is
            returned.
            </returns>
            <remarks>
            POTENTIAL BREAKING CHANGE:
            
            When the AllowEmptyStringAsDefault property is FALSE and argument
            pstrDefault is a null reference, this method returns the null
            reference. Previous versions returned the empty string anyway, which
            wasn't the intended behavior, and a missing command line argument
            thereby escaped detection.
            
            Hence, going forward, when pstrDefault is NULL, you must be prepared
            to handle a null reference as the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String,System.Boolean)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pstrDefault">
            Specify a default value to return if the argument was omitted from
            the command line, or VALUE_NOT_SET or a null reference (Nothing in
            Visual Basic), to use an empty string as the default.
            </param>
            <param name="pfAllowEmptyStringAsDefault">
            Set this to TRUE if you want an empty string for the value of the
            pstrDefault argument treated as a valid default value. Otherwise,
            empty strings are treated as null references (Nothing in Visual
            Basic).
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pstrDefault is
            returned.
            </returns>
            <remarks>
            POTENTIAL BREAKING CHANGE:
            
            When the AllowEmptyStringAsDefault property is FALSE and argument
            pstrDefault is a null reference, this method returns the null
            reference. Previous versions returned the empty string anyway, which
            wasn't the intended behavior, and a missing command line argument
            thereby escaped detection.
            
            Hence, going forward, when pstrDefault is NULL, you must be prepared
            to handle a null reference as the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pchrDefault is
            returned.
            </returns>
            <remarks>
            This method returns through GetArgByName, by way of 
            FirstCharFromString. Hence, everything that applies to either of
            them applies as well to this method.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pchrDefault">
            Specify a default value to return if the argument was omitted from
            the command line, or VALUE_NOT_SET or a null reference (Nothing in
            Visual Basic), to use a null character as the default.
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pchrDefault is
            returned.
            </returns>
            <remarks>
            This method returns through GetArgByName, by way of 
            FirstCharFromString. Hence, everything that applies to either of
            them applies as well to this method.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char,System.Boolean)">
            <summary>
            Given the external name of a named argument (the name that was
            supplied to the constructor), return its value, which is either the
            value given on the command line or the default specified in this
            method call.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pchrDefault">
            Specify a default value to return if the argument was omitted from
            the command line, or VALUE_NOT_SET or a null reference (Nothing in
            Visual Basic), to use a null character as the default.
            </param>
            <param name="pfAllowEmptyStringAsDefault">
            Set this to TRUE if you want an empty string for the value of the
            pstrDefault argument treated as a valid default value. Otherwise,
            empty strings are treated as null references (Nothing in Visual
            Basic).
            </param>
            <returns>
            If the requested name is valid, and the argument was entered on the
            command line, the value supplied on the command line is returned. If
            the argument was omitted from the command line, or if the specified
            name is invalid, the value specified in argument pchrDefault is
            returned.
            </returns>
            <remarks>
            This method returns through GetArgByName, by way of 
            FirstCharFromString. Hence, everything that applies to either of
            them applies as well to this method.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            zero.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <returns>
            This method passes the value returned by GetArgByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            pintDefault.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pintDefault">
            Specify a default value to return if the argument was omitted from
            the command line.
            </param>
            <returns>
            This method passes the value returned by GetArgByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32,System.Boolean)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            pintDefault.
            </summary>
            <param name="pstrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pintDefault">
            Specify a default value to return if the argument was omitted from
            the command line.
            </param>
            <param name="pfAllowEmptyStringAsDefault">
            Set this to TRUE if you want an empty string for the value of the
            pstrDefault argument treated as a valid default value. Otherwise,
            empty strings are treated as null references (Nothing in Visual
            Basic).
            </param>
            <returns>
            This method passes the value returned by GetArgByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32)">
            <summary>
            Get a positional argument by its ordinal position.
            </summary>
            <param name="pintIndex">
            Position of argument in list. Arguments are numbered from 1.
            </param>
            <returns>
            The argument value at the ordinal position specified by pintIndex is
            returned, unless pintIndex is out of range, in which case an empty
            string is returned.
            </returns>
            <remarks>
            This overload is a wrapper around the second overload,
            GetArgByPosition ( int, string ), which does the real work.
            This method calls it internally, passing a default value of
            VALUE_NOT_SET.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32,System.String)">
            <summary>
            Get a positional argument by its ordinal position.
            </summary>
            <param name="pintIndex">
            Position of argument in list. Arguments are numbered from 1.
            </param>
            <param name="pstrDefault">
            Default value to return if argument ordinal is greater than the
            number of positional arguments entered on the command line.
            </param>
            <returns>
            The argument value at the ordinal position specified by pintIndex is
            returned, unless pintIndex is out of range, in which case, the
            default value specified in pstrDefault is returned.
            </returns>
            <remarks>
            POTENTIAL BREAKING CHANGE:
            
            When the AllowEmptyStringAsDefault property is FALSE and argument
            pstrDefault is a null reference, this method returns the null
            reference. Previous versions returned the empty string anyway, which
            wasn't the intended behavior, and a missing command line argument
            thereby escaped detection.
            
            Hence, going forward, when pstrDefault is NULL, you must be prepared
            to handle a null reference as the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            zero.
            </summary>
            <param name="pintIndex">
            Position of argument in list. Arguments are numbered from 1.
            the constructor.
            </param>
            <returns>
            This method passes the value returned by GetArgByPosition to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32,System.Int32)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            pintDefault.
            </summary>
            <param name="pintIndex">
            Position of argument in list. Arguments are numbered from 1.
            the constructor.
            </param>
            <param name="pintDefault">
            Specify a default value to return if the argument was omitted from
            the command line.
            </param>
            <returns>
            This method passes the value returned by GetArgByPosition to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName(System.Char)">
            <summary>
            Test for the presence of a defined switch. The modifier, if any, is
            ignored.
            </summary>
            <param name="pchrName">
            Character to identify switch. This must be one of the characters
            stored in the array, or used as keys in the dictionary passed into
            the instance constructor.
            </param>
            <returns>
            The return value is TRUE if the switch is present, with or without a
            modifier (which is ignored). Otherwise, the return value is FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char)">
            <summary>
            Return the value stored for a switch argument.
            </summary>
            <param name="pchrName">
            Character to identify switch. This must be one of the characters
            stored in the array, or used as keys in the dictionary passed into
            the instance constructor.
            </param>
            <returns>
            If the switch was defined in the constructor, and it was specified
            on the command line of the executing assembly, the value defined on
            the command line is returned. Otherwise, the default value, if any,
            passed into the constructor is returned. Failing both of those, the
            generic default value constant, Properties.Resources.SWITCH_IS_OFF,
            is returned.
            </returns>
            <remarks>
            This overload is a wrapper around the other overload,
            GetSwitchByName ( char, string ), which does the real work.
            This method calls it internally, passing a default value of
            Properties.Resources.SWITCH_IS_OFF.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String)">
            <summary>
            Return the value stored for a switch argument.
            </summary>
            <param name="pchrName">
            Character to identify switch. This must be one of the characters
            stored in the array, or used as keys in the dictionary passed into
            the instance constructor.
            </param>
            <param name="pstrDefault">
            Default value to return if argument pchrName is not in the list of
            valid switches passed into the constructor. See pchrName.
            </param>
            <returns>
            If the switch was defined in the constructor, and it was specified
            on the command line of the executing assembly, the value defined on
            the command line is returned. Otherwise, the default value, if any,
            passed into the constructor is returned. Failing both of those, the
            generic default value constant, Properties.Resources.SWITCH_IS_OFF,
            is returned.
            </returns>
            <remarks>
            POTENTIAL BREAKING CHANGE:
            
            When the AllowEmptyStringAsDefault property is FALSE and argument
            pstrDefault is a null reference, this method returns the null
            reference. Previous versions returned the empty string anyway, which
            wasn't the intended behavior, and a missing command line argument
            thereby escaped detection.
            
            Hence, going forward, when pstrDefault is NULL, you must be prepared
            to handle a null reference as the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String,System.Boolean)">
            <summary>
            Return the value stored for a switch argument.
            </summary>
            <param name="pchrName">
            Character to identify switch. This must be one of the characters
            stored in the array, or used as keys in the dictionary passed into
            the instance constructor.
            </param>
            <param name="pstrDefault">
            Default value to return if argument pchrName is not in the list of
            valid switches passed into the constructor. See pchrName.
            </param>
            <param name="pfAllowEmptyStringAsDefault">
            Set this to TRUE if you want an empty string for the value of the
            pstrDefault argument treated as a valid default value. Otherwise,
            empty strings are treated as null references (Nothing in Visual
            Basic).
            </param>
            <returns>
            If the switch was defined in the constructor, and it was specified
            on the command line of the executing assembly, the value defined on
            the command line is returned. Otherwise, the default value, if any,
            passed into the constructor is returned. Failing both of those, the
            generic default value constant, Properties.Resources.SWITCH_IS_OFF,
            is returned.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            zero.
            </summary>
            <param name="pchrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <returns>
            This method passes the value returned by GetSwitchByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            pintDefault.
            </summary>
            <param name="pchrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pintDefault">
            Specify a default value to return if the argument was omitted from
            the command line.
            </param>
            <returns>
            This method passes the value returned by GetSwitchByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32,System.Boolean)">
            <summary>
            If the value of a switch is an integer, return it. Otherwise, return
            pintDefault.
            </summary>
            <param name="pchrArgName">
            Specify the external name of the argument, as it was identified to
            the constructor.
            </param>
            <param name="pintDefault">
            Specify a default value to return if the argument was omitted from
            the command line.
            </param>
            <param name="pfAllowEmptyStringAsDefault">
            Set this to TRUE if you want an empty string for the value of the
            pstrDefault argument treated as a valid default value. Otherwise,
            empty strings are treated as null references (Nothing in Visual
            Basic).
            </param>
            <returns>
            This method passes the value returned by GetSwitchByName to the 
            int.TryParse method. Hence, everything that applies to either of
            them applies as well to this method.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue(System.String)">
            <summary>
            Extract the argument name from a string that consists of the key
            (index) of the collection.
            </summary>
            <param name="pstrArgKey">
            Specify the key to parse and strip, so that it can be fed into an
            instance method to retrieve the value of a named argument or switch.
            </param>
            <returns>
            If the function succeeds, the return value is the name of a named
            argument or of a switch, which can be fed into GetArgByName, 
            GetSwitchByName, or one of their siblings.
            </returns>
            <remarks>
            Since this class derives from a Dictionary whose keys and values are
            strings, given the string that becomes the pstrArgKey argument of
            this method, you could just as easily get the value directly.
            However, if you did so, you would lose the benefit of default value
            assignment, not to mention the accessors that bundle conversions to
            Integer, Boolean, and Character types. Moreover, reaching into the
            base class makes it slightly less obvious that the value retrieved
            is that of a command line argument, let alone its name and intrinsic
            type (switch versus named argument versus positional argument).
            
            A wiser design would hide the dictionary from view. Notwithstanding
            this one-off use, it is not too late to do so, since this is the
            only case in which I have reached into the base class in this way.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String)">
            <summary>
            Extract the first character from a string, and return it as a char
            value type.
            </summary>
            <param name="pstrIn">
            The first character in this string is returned.
            </param>
            <returns>
            The return value is the first character of string pstrIn, as a
            scalar value type.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the input string, pstrIn, is null or empty, an ArgumentException
            is thrown. See the next overload for an alternative that doesn't
            throw exceptions.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String,System.Char)">
            <summary>
            Extract the first character from a string, and return it as a char
            value type.
            </summary>
            <param name="pstrIn">
            The first character in this string is returned.
            </param>
            <param name="pchrDefault">
            If string pstrIn is null or empty, this character is returned.
            </param>
            <returns>
            The return value is the first character of string pstrIn, as a
            scalar value type.
            </returns>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty">
             <summary>
             This property returns True (ARG_LIST_IS_EMPTY) when the command line
             is devoid of arguments.
            
             Otherwise, it returns False (ARG_LIST_HAS_ARGS), indicating that the
             command line contains at least one argument. See Remarks.
             </summary>
             <remarks>
             ArgListIsEmpty being false means only that there is an argument in
             the command line, which may be invalid. Check the ArgMatching array
             or the two invalid argument counters, InvalidNamedArgsInCmd and
             InvalidSwitchesInCmd.
             </remarks>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault">
            <summary>
            The value of this property determines how the GetArgDefaultToUse and
            GetSwitchDefaultToUse methods treat an empty string supplied as a
            default value to return. See Remarks for complete details.
            </summary>
            <remarks>
            The AllowEmptyStringAsDefault property is initialized to FALSE, to
            maintain backwards compatibility with previous versions of the
            library that exports this class.
            
            By default switches return a string value of "OFF" to indicate their
            omission from the command line. To override this behavior, you must
            call the two-argument overload of GetSwitchDefaultToUse, specifying
            a default string value as the second argument.
            
            Prior to version 2.0, this overload treated both null references
            (Nothing in Visual Basic) and empty strings equally, returning the
            class default value of "OFF" in both cases.
            
            Beginning with version 2.0, this behavior can be overridden in one
            of two ways.
            
            1) Setting the AllowEmptyStringAsDefault property to TRUE (signified
            by symbolic constant BLANK_AS_DEFAULT_ALLOWED) changes the behavior
            for the entire class for the rest of its lifetime, or until it is
            set back to its default, whichever comes first.
            
            2) Calling method GetSwitchDefaultToUse or GetArgDefaultToUse with a
            third (Boolean) argument that affects only the behavior of that one
            call, regardless of the current AllowEmptyStringAsDefault setting.
            This method leaves the AllowEmptyStringAsDefault property unchanged.
            </remarks>
            <remarks>
            POTENTIAL BREAKING CHANGE:
            
            When the AllowEmptyStringAsDefault property is FALSE and argument
            pstrDefault is a null reference, this method returns the null
            reference. Previous versions returned the empty string anyway, which
            wasn't the intended behavior, and a missing command line argument
            thereby escaped detection.
            
            Hence, going forward, when pstrDefault is NULL, you must be prepared
            to handle a null reference as the return value.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching">
            <summary>
            Although you cannot change the rules in the middle of the game,
            transparency is highly desirable.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray">
            <summary>
            This property is an array of ArgType enumerated types, which has one
            element for each command line argument. Use this list to find and
            report invalid command line arguments, if any.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.Count">
            <summary>
            Get the total number of valid arguments of all types.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs">
            <summary>
            Get the count of named arguments defined by the constructor.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches">
            <summary>
            Count of switches defined by the constructor
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount">
            <summary>
            Total number of invalid arguments found in the command line. This is
            the sum of InvalidNamedArgsInCmd and InvalidSwitchesInCmd. Use it as
            a quick check for invalid arguments.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd">
            <summary>
            Count of invalid named arguments found in the command line.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd">
            <summary>
            Count of invalid switches found in the command line.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine">
            <summary>
            Count of positional arguments found in the command line.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF">
            <summary>
            Gets the SWITCH_IS_OFF string, which is loaded from the string
            resources of the DLL into a private static read-only string.
            </summary>
            <remarks>
            This static read-only property replaces a like named constant, which
            I moved into the resource strings because that is really where it
            belongs, so that the library can be adapted for another language by
            substituting a localized string resource.
            
            While the simplest approach would be to assign these names to the
            private strings, and mark them public, doing so would obscure their
            their true nature.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON">
            <summary>
            Gets the SWITCH_IS_ON string, which is loaded from the string
            resources of the DLL into a private static read-only string.
            </summary>
            <remarks>
            This static read-only property replaces a like named constant, which
            I moved into the resource strings because that is really where it
            belongs, so that the library can be adapted for another language by
            substituting a localized string resource.
            
            While the simplest approach would be to assign these names to the
            private strings, and mark them public, doing so would obscure their
            their true nature.
            </remarks>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine">
            <summary>
            Count of valid named arguments found in the command line.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine">
            <summary>
            Count of valid switches found in the command line.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.CmdLneArgsBasic.ParseArgs">
            <summary>
            Every constructor finishes in this routine, which does as its name
            implies; using the list of valid arguments, it parses the command
            line.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.PropertyDefaults">
            <summary>
            Expose the AppSettingsSection associated with this DLL. 
            
            The configuration settings come from the base class. The configuration
            settings come from the base class, AssemblyLocatorBase; hence, this
            class also serves as the concrete example that is recommended to
            accompany distribution of any abstract base class.
            
            The settings exposed by this class inhabit a configuration file that is
            associated with the DLL, itself, as opposed to the application 
            configuration. Though its format is similar to that of the application
            configuration file, the DLL configuration lives in its own configuration
            file that has the same name as the DLL, with an additional suffix of
            .config.
            </summary>
            <remarks>
            The rationale behind segregating these settings is that the affected
            application properties are ones that you want to keep consistent, or
            nearly so, across large groups of applications. Keeping them in a
            dedicated configuration file that travels with the DLL that implements
            them eliminates the thankless task of adding them to every application
            configuration file.
            </remarks>
        </member>
        <member name="F:WizardWrx.Core.PropertyDefaults._DllConfigSettings">
            <summary>
            Keep a copy of the AppSettingsSection here.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.#ctor">
            <summary>
            Use this constructor when the class instance is a sibling (defined
            in the same assembly).
            </summary>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.#ctor(System.Reflection.Assembly)">
            <summary>
            Use this constructor when the class instance and base class are
            defined in different assemblies.
            </summary>
            <param name="pasmLinkedAssembly"></param>
        </member>
        <member name="P:WizardWrx.Core.PropertyDefaults.ValuesCollection">
            <summary>
            Return the KeyValueConfigurationCollection from the
            AppSettingsSection section of the DLL configuration file.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate(System.DateTimeKind)">
            <summary>
            Get the date on which the assembly was built.
            </summary>
            <param name="pdtmKind">
            Specify whether to return local or UTC time. Altough all three types
            are nominally supported, Unspecified is treated as Local.
            </param>
            <returns>
            The return value is the System.DateTime when the assembly was built.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString">
            <summary>
            Get a version string, suitable for display in reports.
            </summary>
            <returns>
            The fully qualified version (i. e., all four parts) is returned.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.InitializeInstance">
            <summary>
            Both constructors call this method to initialize their properties.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues">
            <summary>
            Enumeate missing configuration values, if any.
            </summary>
            <returns>
            This method returns a message suitable for display on a console or a
            Windows message box. The returned message summarises the state of
            affairs, even when all defined values are represented in the
            configuration file.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.RegistryValues">
            <summary>
            This sealed class exposes static methods for efficiently testing for the
            presence of named values in a Registry key that behave more like the
            Item property of a collection, and retrieving Registry value types that
            require a transformation of one sort or another to get them into the
            appropriate native type.
            
            Since static classes are implicitly sealed, this class cannot be inherited.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.RegistryValues.REG_BINARY_NULL_FOR_ABSENT">
            <summary>
            Specify this constant as the value of RegQueryValue argument pfNullIsOK if
            your routine expects a null reference when the requested value is absent
            or the wrong type.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT">
            <summary>
            Specify this constant as the value of RegQueryValue argument pfNullIsOK if
            your routine expects an array of some kind, even when the requested value
            is absent or the wrong type.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Boolean)">
            <summary>
            Get a REG_BINARY value from the Windows Registry.
            </summary>
            <param name="phRegKey">
            Specify the handle of the Registry key where the value is expected
            to exist. This must be the key that holds the value, since neither
            RegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.
            </param>
            <param name="pstrValueName">
            Specify the name, sans square brackets, which aren't needed, since
            the string is the unqualified name of a value.
            </param>
            <param name="pfNullIsOK">
            Specify True if your code tests the return value for a null
            reference. Otherwise, specify False, and expect an uninitialized
            one-element byte array.
            
            This is a specific instance in which I believe that a null reference
            is the best solution to the problem of what to use as a default for
            a missing REG_BINARY value.
            </param>
            <returns>
            If the specified value exists and its type is REG_BINARY, the return
            value is a byte array containing the value read from the Registry.
            Otherwise, the return value is null (Nothing in Visual Basic).
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference (Nothing in Visual Basic), when this
            method calls companion method ValueExists to query the Registry for
            the specified value, that method throws an ArgumentNullException
            exception, listing this method as its calling method in its stack
            trace.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int32)">
            <summary>
            Get a REG_DWORD value from the Windows Registry.
            </summary>
            <param name="phRegKey">
            Specify the handle of the Registry key where the value is expected
            to exist. This must be the key that holds the value, since neither
            RegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.
            </param>
            <param name="pstrValueName">
            Specify the name, sans square brackets, which aren't needed, since
            the string is the unqualified name of a value.
            </param>
            <param name="pintDefault">
            Although a DWORD seems logically more like an unsigned integer, I am
            somewhat surprised that the framework casts it to int, which carries
            a sign. Nevertheless, since the return is cast to int, so is its
            default, which is returned if the specified value is absent, or if
            it exists, but has a different type (ValueKind) property.
            </param>
            <returns>
            If the named value exists in the specified key and its type is 
            REG_DWORD, it is returned, as a SIGNED integer. Otherwise, the value
            specified in pintDefault is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference (Nothing in Visual Basic), when this
            method calls companion method ValueExists to query the Registry for
            the specified value, that method throws an ArgumentNullException
            exception, listing this method as its calling method in its stack
            trace.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int64)">
            <summary>
            Get a REG_QWORD value from the Windows Registry.
            </summary>
            <param name="phRegKey">
            Specify the handle of the Registry key where the value is expected
            to exist. This must be the key that holds the value, since neither
            RegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.
            </param>
            <param name="pstrValueName">
            Specify the name, sans square brackets, which aren't needed, since
            the string is the unqualified name of a value.
            </param>
            <param name="plngDefault">
            Although a QWORD seems logically more like an unsigned long, I am
            somewhat surprised that the framework casts it to long, which
            carries a sign. Nevertheless, since the return is cast to long, so
            is its default, which is returned if the specified value is absent,
            or if it exists, but has a different type (ValueKind) property.
            </param>
            <returns>
            If the named value exists in the specified key and its type is
            REG_QWORD, it is returned, as a SIGNED long integer. Otherwise, the
            value specified in plngDefault is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference (Nothing in Visual Basic), this
            method throws an ArgumentNullException exception.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Return the single string representation of a REG_SZ or 
            REG_EXPAND_SZ Registry value.
            </summary>
            <param name="phRegKey">
            Pass in a handle to the Registry sub-key that is supposed to contain
            the required REG_SZ or REG_EXPAND_SZ value.
            </param>
            <param name="pstrValueName">
            Pass in a string that contains the name of the value to be queried
            and returned if present. See notes in the Return Value comment.
            </param>
            <param name="pstrDefault">
            Specify the string to return if the value is missing or of the wrong type.
            </param>
            <returns>
            If the function succeeds, the return value is a string containing
            the value. If the value type is REG_EXPAND_SZ, environment variables
            are expanded.
            
            If the value specified by pstrValueName is missing entirely, the
            return value is pstrDefault.
            
            If the requested string is something other than REG_SZ or 
            REG_EXPAND_SZ, the return value is pstrDefault.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference (Nothing in Visual Basic), when this
            method calls companion method ValueExists to query the Registry for
            the specified value, that method throws an ArgumentNullException
            exception, listing this method as its calling method in its stack
            trace.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Return the multiple values stored in a REG_MULTI_SZ Registry value.
            </summary>
            <param name="phRegKey">
            Pass in a handle to the Registry sub-key that is supposed to contain
            the required REG_MULTI_SZ value.
            </param>
            <param name="pstrValueName">
            Pass in a string that contains the name of the value to be queried
            and returned if present. See notes in the Return Value comment.
            </param>
            <returns>
            If the function succeeds, the return value is an array of strings
            that contains one string for each substring in the REG_MULTI_SZ
            value.
            
            If the value specified by pstrValueName is missing entirely, an
            empty array is returned.
            
            If the requested string is something other than REG_MULTI_SZ, this
            method treats the call as a degenerate case, returning an array of
            one element if the value is either REG_SZ or REG_EXPAND_SZ.
            
            ALL other types return empty arrays.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference (Nothing in Visual Basic), when this
            method calls companion method ValueExists to query the Registry for
            the specified value, that method throws an ArgumentNullException
            exception, listing this method as its calling method in its stack
            trace.
            </exception>
        </member>
        <member name="M:WizardWrx.Core.RegistryValues.ValueExists(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Return TRUE if a specified value exists on a specified key of the
            Windows Registry.
            </summary>
            <param name="phRegKey">
            Pass in a handle to the Registry sub-key that is supposed to contain
            the desired value.
            </param>
            <param name="pstrValueName">
            Pass in a string that contains the name of the value to be queried
            and returned if present. See notes in the Return Value comment.
            </param>
            <returns>
            The function returns true if the key contains a value with the 
            specified name, or if pstrValueName is the empty string or a null
            reference, either of which stands for the default value, which is
            always present, though seldom set. Otherwise, the return value is
            false.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If phRegKey is a null reference, an ArgumentNullException exception
            is thrown.
            </exception>
            <remarks>
            This was written as a service routine for companion methods
            GetRegDwordValue and GetRegMultiStringValue. However, since it is
            almost certain to find use on its own, I marked it public.
            </remarks>
        </member>
        <member name="T:WizardWrx.Core.StringFixups">
            <summary>
            Instances of this class represent pairs of fixup strings to apply as
            replacement pairs to amend a string, such as the JSON response from a
            REST endpoint that motivated its creation.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.StringFixups.StringFixup">
            <summary>
            A fixup pair is a pair of strings.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.StringFixups.StringFixup.InputValue">
            <summary>
            Specify the string to be replaced with OutputValue when found in
            an input string.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.StringFixups.StringFixup.OutputValue">
            <summary>
            Specify the string to substitute for InputValue when found in an
            input string.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.StringFixup.#ctor(System.String,System.String)">
            <summary>
            This constructor permits initializing static read-only arrays of
            these structures.
            </summary>
            <param name="pstrInputValue">
            String to assign to the InputValue property
            </param>
            <param name="pstroutputValue">
            String to assign to the OutpuValue property
            </param>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.StringFixup.ToString">
            <summary>
            Override the ToString method on the base class to render the two
            structure members' values when the framework invokes the default
            ToString method, such as when it populates a watch window.
            </summary>
            <returns>
            The return value is a formatted string that displays the name
            and value of each of the two members of the structure.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.#ctor">
            <summary>
            The default constructor is marked as private to force all instances
            to be initialized.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.#ctor(WizardWrx.Core.StringFixups.StringFixup[])">
            <summary>
            The public constructor is overloaded, to guarantee that instances
            are properly initialized.
            </summary>
            <param name="pafixupPair">
            The array of StringFixup string pairs to apply to string fed into
            the ApplyFixups method
            </param>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.ApplyFixups(System.String)">
            <summary>
            Call this method to apply the StringFixup array that was passed into
            the constructor.
            </summary>
            <param name="pstrInputString">
            String to transform by applying the StringFixup array that was passed into
            the constructor
            </param>
            <returns>
            The <paramref name="pstrInputString"/>, transformed by applying each
            StringFixup to it in turn
            </returns>
        </member>
        <member name="F:WizardWrx.Core.StringFixups._afixupPairs">
            <summary>
            The input array is sequestered here.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.StringFixups.ValidateFixupPairArray(WizardWrx.Core.StringFixups.StringFixup[])">
            <summary>
            Unless sumething is wrong with it, return the input <paramref name="pafixupPairs"/>
            to the calling routine.
            </summary>
            <param name="pafixupPairs">
            Array of StringFixup structures to validate
            </param>
            <returns>
            If the method succeeds, the return value is a reference to the input <paramref name="pafixupPairs"/>.
            Otherwise, the method throws an ArgumentNullException exception or
            an ArgumentException exception, depending on the circumstances.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            An ArgumentNullException exception arises when the entire <paramref name="pafixupPairs"/>
            array is a null reference.
            </exception>
            <exception cref="T:System.ArgumentException">
            An ArgumentException exception arises when the entire array is empty
            or one of its InputValue members is a null reference or the empty
            string.
            </exception>
        </member>
        <member name="T:WizardWrx.Core.TimeDisplayFormatter">
            <summary>
            Use instances of this class to return dates and times, uniformly
            formatted by rules set by way of its properties.
            
            This class is sealed, and cannot be inherited.
            </summary>
            <seealso cref="T:WizardWrx.DisplayFormats"/>
            <seealso cref="T:WizardWrx.SysDateFormatters"/>
        </member>
        <member name="T:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder">
            <summary>
            Indicate the format to use for displaying the calendar date.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate">
            <summary>
            Use the ShortDate format defined in the current CultureInfo.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYYYY">
            <summary>
            Display Month, Day, and Year, showing all four digits of the year.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYYYMMDD">
            <summary>
            Display Year, Month, and Day, showing all four digits of the year.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYYYY">
            <summary>
            Display Day, Month, and Year, showing all four digits of the year.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYY">
            <summary>
            Display Month, Day, and Year, discarding the century from the year.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYMMDD">
            <summary>
            Display Year, Month, and Day, discarding the century from the year.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYY">
            <summary>
            Display Day, Month, and Year, discarding the century from the year.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType">
            <summary>
            Indicate time format to use (CultureInfoShortTime, Civilian, or
            Military).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime">
            <summary>
            Use the ShortTime format defined in the current CultureInfo.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Civilian">
            <summary>
            Use civilian (12 hour) display format.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Military">
            <summary>
            Use Military (24 hour) display format.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType">
            <summary>
            Indicate the precision to use for the time display. The class
            default is HMST.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HM">
            <summary>
            Display only hours and minutes (HH:MM).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMS">
            <summary>
            Display hours, minutes, and seconds (HH:MM:SS).
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMST">
            <summary>
            Display hours, minutes, seconds, and milliseconds.
            </summary>
        </member>
        <member name="F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMSTN">
            <summary>
            Display hours, minutes, seconds, milliseconds, and ticks.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat">
            <summary>
            Set this property to override the default formatting of calendar
            dates, which is governed by the active CultureInfo settings, which
            are, themselves, governed by the active Regional Settings of the
            operating system.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.HoursFormat">
             <summary>
             Set the display format for hours. See the HoursFormatType enumeration
             for more details.
             
             When the value is DateFieldOrder.CultureInfoShortDate, the
             HoursFormat and TimePrecision properties are ignored.
            
             The default format is Military, and the value must be a member of
             the HoursFormatType enumeration. If an invalid value is specified, a
             System.ArgumentOutOfRangeException exception is thrown, and the
             property value is unchanged.
            
             When the value of this property is CultureInfoShortTime, the
             TimePrecision property is ignored.
             </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone">
            <summary>
            This static property provides convenience access to the
            CurrentTimeZone property maintained in a static TimeZone instance
            for its own use.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC">
             <summary>
             Set this property to TRUE to have the AM and PM tokens displayed in
             upper case.
            
             Unless the HoursFormat property is HoursFormatType.Civilian, this
             property is ignored.
             </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone">
             <summary>
             Set this property to TRUE to have the local time zone displayed with
             the time. By default, the time zone is omitted.
            
             This property is applied independently of the HoursFormatType and
             Precision properties.
             </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.ShowWeekday">
             <summary>
             Set this property to TRUE to have the local weekday name displayed
             with the time. By default, the weekday name is omitted.
            
             This property is applied independently of the HoursFormatType and
             Precision properties.
             </summary>
        </member>
        <member name="P:WizardWrx.Core.TimeDisplayFormatter.TimePrecision">
             <summary>
             This property governs the precision used for time displays. The
             class default is HMST.
            
             When the value of the HoursFormat property is CultureInfoShortTime,
             the value of this property is ignored.
            
             For additional information, see the TimePrecisionType enumeration.
             </summary>
        </member>
        <member name="M:WizardWrx.Core.TimeDisplayFormatter.#ctor">
             <summary>
             The default constructor initializes an instance that follows the
             default preferences built into the class. Hence, methods called on
             objects created by it are guaranteed to yield a usable string unless
             the DateTime value supplied to the method is, itself, invalid.
             </summary>
             <remarks>
             Rather than attempt to create the numerous constructors that would
             be required to cover every possible combination of properties, there
             is just one constructor. All properties are read-write. Use them to
             change the operating parameters.
            
             If you always use the same combination of settings, you can wrap
             your own class around an instance of this one.
             </remarks>
        </member>
        <member name="M:WizardWrx.Core.TimeDisplayFormatter.FormatThisTime(System.DateTime)">
            <summary>
            Format the specified time.
            </summary>
            <param name="pdtmThisTime">
            The DateTime instance to format.
            </param>
            <returns>
            The input time, formatted as dictated by the current settings of the
            properties of the class instance.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime">
            <summary>
            Format the current time.
            </summary>
            <returns>
            The current time, formatted as dictated by the current settings of
            the properties of the class instance.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime(System.DateTime)">
            <summary>
            Return the time zone name that corresponds to a local time.
            </summary>
            <param name="pdtmTheTime">
            Specify the System.DateTime for which the correct time zone string
            is required.
            </param>
            <returns>
            If the DateTimeKind of argument pdtmTheTime is Local, the return
            value is a string representation of the spelled out time zone name.
            Otherwise, an ArgumentException is thrown.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes(System.DateTime,System.DateTime)">
            <summary>
            Given a pair of DateTime structures, return them in a standardized
            format.
            </summary>
            <param name="dtmTimeLocal">
            Specify the local time to include in the standardized message.
            </param>
            <param name="dtmTimeUtc">
            Specify the UTC time to include in the standardized message.
            </param>
            <returns>
            The returned string is of the format {0} ({1} UTC), where {0} is
            replaced with the local time, while {1} is replaced with the
            corresponding UTC time.
            </returns>
            <example>
            2017/03/27 18:18:58 (2017/03/27 23:18:58 UTC)
            </example>
        </member>
        <member name="T:WizardWrx.Core.TraceLogger">
            <summary>
            This static class exposes methods that support every conceivable
            combination of local and UTC time stamps for trace logging.
            </summary>
            <remarks>
            The methods that record both local and UTC time capture the current UTC
            time, then convert it into local time. This guarantees that both times
            are truly equal, and that local and UTC times are unambiguous.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst(System.String)">
            <summary>
            Write a time stamped trace log message, using the local and UTC 
            machine times as its time stamp prefix, local first, followed by
            UTC in parentheses.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst(System.String)">
            <summary>
            Write a time stamped trace log message, using the local and UTC 
            machine times as its time stamp prefix, UTC first, followed by
            local in parentheses.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(System.String)">
            <summary>
            Write a time stamped trace log message, using the local and UTC 
            machine times as its time stamp prefix, local first, followed by
            UTC in parentheses.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(System.String)">
            <summary>
            Write a time stamped trace log message, using the local and UTC 
            machine times as its time stamp prefix, UTC first, followed by
            local in parentheses.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime(System.String)">
            <summary>
            Write a time stamped trace log message, using the local machine time
            as its time stamp prefix.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime(System.String)">
            <summary>
            Write a time stamped trace log message, using the local machine time
            as its time stamp prefix.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime(System.String)">
            <summary>
            Write a time stamped trace log message, using the UTC machine time
            as its time stamp prefix.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime(System.String)">
            <summary>
            Write a time stamped trace log message, using the UTC machine time
            as its time stamp prefix.
            </summary>
            <param name="pstrMessage">
            The specified string is written verbatim, immediately after the time
            stamp.
            </param>
        </member>
        <member name="M:WizardWrx.Core.TraceLogger.ReplaceNewlines(System.String)">
            <summary>
            This private method replaces newlines embedded in the message with a
            string that maintains separation of the text, while keeping it on a
            single logical output line.
            </summary>
            <param name="pstrMessage">
            This argument specifies the string that needs its embedded newlines replaced.
            </param>
            <returns>
            In the current implementation, the replacement string is a privately defined
            constant.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.UnconfiguredDLLSettings">
            <summary>
            Organize the DLL configuration values that were omitted from the
            associated configuration file. Since multiple classes can and do share a
            DLL configuration file, this class must be a Singleton.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.Add(System.String,System.String,System.String)">
            <summary>
            Add a new unconfigured setting.
            </summary>
            <param name="configFileName">
            Identify the affected configuration file.
            </param>
            <param name="propName">
            Identify the name of the missing property.
            </param>
            <param name="propValue">
            Recird its default value.
            </param>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile(System.String)">
            <summary>
            Return the list of parameters that are missing from the specified
            configuration file.
            </summary>
            <param name="pstrConfigFileName">
            Specify the name of the file for which the list is wanted.
            </param>
            <returns>
            The return value is a list of UnconfiguredSetting objects, which may
            be empty.
            </returns>
        </member>
        <member name="P:WizardWrx.Core.UnconfiguredDLLSettings.Count">
            <summary>
            Expose the Count property of the dictionary.
            </summary>
        </member>
        <member name="T:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting">
            <summary>
            Settings are organized into a private collection that belongs to the
            singleton.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor">
            <summary>
            The default constructor is intended to remain unused.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor(System.String,System.String,System.String)">
            <summary>
            All interaction is expected to be with this constructor.
            </summary>
            <param name="configFileName">
            Settings are associated with a named configuration file. Only
            its base name matters, however.
            </param>
            <param name="propertyName">
            Each property name must be unique within the scope of its
            configuration file.
            </param>
            <param name="propertyValue">
            The default property value is recorded herein for reference.
            </param>
        </member>
        <member name="P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName">
            <summary>
            Gets or sets the configuration file name
            </summary>
        </member>
        <member name="P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName">
            <summary>
            Gets or sets the property name
            </summary>
        </member>
        <member name="P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue">
            <summary>
            Gets or sets the default value assigned to the property
            </summary>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals(System.Object)">
            <summary>
            Override the Equals method on the base class to give a value
            that contains the absolute (fully qualified) configuration value
            name, composed of the configuration file name and the key name.
            </summary>
            <param name="obj">
            Comparand
            </param>
            <returns>
            True if this instance and the other refer to the same
            configuration file key.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode">
            <summary>
            Return a hash code based on the equality value.
            </summary>
            <returns>
            The return value is the hash code that corresponds to the
            equality value.
            </returns>
        </member>
        <member name="M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString">
            <summary>
            Return a concatenated string composed of the name of the
            configuration file followed by the configuration value name.
            </summary>
            <returns>
            The return value is the configuration file name and key name,
            separated by an underscore character.
            </returns>
        </member>
        <member name="T:WizardWrx.Core.UnmanagedLibrary">
            <summary>
            Utility class to wrap an unmanaged DLL and be responsible for freeing it
            </summary>
            <remarks>
            This is a managed wrapper over the native LoadLibrary, GetProcAddress,
            and FreeLibrary calls.
            
            I didn't immediately notice the fact that this class is sealed, but not
            static; hence, public UnmanagedLibrary ( string fileName ) is its one
            and only public constructor. As insurance against accidentally creating
            a useless, uninitialized instance, I added a default constructor, marked
            as private.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.UnmanagedLibrary.#ctor">
            <summary>
            Since Mike didn't provide a default constructor, and there is no
            provision for initializing an object after the fact, I took the
            precaution of hiding the default constructor.
            </summary>
        </member>
        <member name="M:WizardWrx.Core.UnmanagedLibrary.#ctor(System.String)">
            <summary>
            Constructor to load a DLL and be responsible for freeing it
            </summary>
            <param name="fileName">
            full path name of DLL to load
            </param>
            <exception cref="T:System.IO.FileNotFoundException">
            if fileName cannot be found
            </exception>
            <remarks>
            Throws exceptions on failure. Most common failure would be file-not-found, or
            that the file is not a loadable image.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction``1(System.String)">
            <summary>
            Dynamically lookup a function via kernel32!GetProcAddress.
            </summary>
            <param name="functionName">
            raw name of the function in the export table
            </param>
            <returns>
            null if function is not found, else a delegate to the unmanaged
            function
            </returns>
            <remarks>
            GetProcAddress results are valid as long as the DLL is loaded. This
            is very, very dangerous to use since you need to ensure that the DLL
            is not unloaded until after you’re done with any objects implemented
            by the DLL. For example, if you get a delegate that then gets an
            IUnknown implemented by this DLL, you can not dispose this library
            until that IUnknown is collected. Else, you may free the library, and
            then the CLR may call release on that IUnknown, leading to a crash.
            
            Declare your delegate pretty much as you would in C or C++; if you
            happen to have a working typedef, use it as the pattern for your
            delegate declaration, which must have class cope.
            
            Once you have your delegate declared, instantiate it by assigning it
            the value returned by calling this method on an instance that was
            constructed using the name of the DLL that exports the desired Win32
            (or Win64) function.
            
            Since the Win64 API generally uses the same names, signatures, and
            DLL names (e. g., it's still Kernel32.dll, and GetProcAddress is
            still GetProcAddress), most of your existing Windows API calls work
            unchanged in Win64. The magic that makes this possible is that Win32
            code looks in %SystemRoot%\SysWOW64, while Win64 code looks in
            %SystemRoot%\System32 for system libraries. The clear goal of this
            initially confusing scheme was to make porting code to 64 bits as
            painless as possible.
            </remarks>
        </member>
        <member name="M:WizardWrx.Core.UnmanagedLibrary.Dispose">
            <summary>
            Call FreeLibrary on the unmanaged DLL. All function pointers
            handed out from this class become invalid after this.
            </summary>
            <remarks>
            This is very dangerous because it suddenly invalidate
            everything retrieved from this DLL. This includes any functions
            handed out via GetProcAddress, and potentially any objects returned
            from those functions (which may have an implementation in the DLL).
            </remarks>
        </member>
        <member name="T:WizardWrx.Core.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.AGED_FILES_INFO_TOSTRING_TEMPLATE">
            <summary>
              Looks up a localized string similar to {{{0} (Per AgedFileInfo Instance: Base Name        = {1},LastWriteTimeUTC = {2} ({3 Ticks}),LastWriteTime    = {4} ({5 Ticks}))}}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.EMPTY_ALIAS_LIST">
            <summary>
              Looks up a localized string similar to The list of aliases is empty..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_ARRAY_IS_EMPTY">
            <summary>
              Looks up a localized string similar to Array cannot be empty..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_CANNOT_PARSE">
            <summary>
              Looks up a localized string similar to ERROR: The CreateFormatString method cannot process the specified format string.{1}    Specified format string = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_COMMA_AND_LITERAL">
            <summary>
              Looks up a localized string similar to , and.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_COMPARAND_IS_WRONG_TYPE">
            <summary>
              Looks up a localized string similar to ERROR: The specified object is a {0}.{2}Type must be {1}..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_CONFIG_FILE_IS_EMPTY">
            <summary>
              Looks up a localized string similar to The specified DLL configuration file, {0}, exists, but is empty..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_CONFIG_PROP_NOT_FOUND">
            <summary>
              Looks up a localized string similar to An exception occurred while processing the {0} property on a {1} object. Details are as follows: {2}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_DETAIL_FORMAT_CANNOT_BE_NULL_OR_BLANK">
            <summary>
              Looks up a localized string similar to ERROR: The DetailFormat property cannot be a null reference or empty string..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_DISPLAY_ORDER_CANNOT_BE_ZERO">
            <summary>
              Looks up a localized string similar to ERROR: The DisplayOrder property cannot be set to zero..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_DUPLICATE_CONFIG_PROP_NAME">
            <summary>
              Looks up a localized string similar to Property name {0} in configuration file {1} is a duplicate name..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_DUPLICATE_SWITCH">
            <summary>
              Looks up a localized string similar to Switch {0} with a default value of {1} is a duplicate..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_ENUMERATION_CONVERSION">
            <summary>
              Looks up a localized string similar to {0}{3}    Input Value   = {1}{3}    Expected Type = {2}{3}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_EXCEPTION_IN_DEFINE_NEW_SWITCH">
            <summary>
              Looks up a localized string similar to An {0} Exception was caught while attempting to define a switch named {1} with a default value of {2}..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_EXCEPTION_NOT_THROWN">
            <summary>
              Looks up a localized string similar to Message from Exception Logged without throwing: {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_FROM_THROWN_EXCEPTION">
            <summary>
              Looks up a localized string similar to Message from Exception Thrown and Logged: {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_INTERNAL_ERROR_UNSUPP_ALG">
            <summary>
              Looks up a localized string similar to An internal error has been detected in routine ReformatSysDate.{2}An unexpected FormattingAlgorithm of {0} has been encountered while processing the following input string:{2}{1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_INV_TZINFO">
            <summary>
              Looks up a localized string similar to CORRUPTED SYSTEM REGISTRY: The GetDisplayTimeZone method found the specified key, but the corresponding Registry key is corrupted.{1}                           Specified ID = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_MISSING_CONFIG_FILE">
            <summary>
              Looks up a localized string similar to There is no valid configuration file for DLL file {0}..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_NO_MEMORY">
            <summary>
              Looks up a localized string similar to SYSTEM RESOURCE FAMINE: The GetDisplayTimeZone method ran out of memory..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_NULL_TZ_ID">
            <summary>
              Looks up a localized string similar to INTERNAL ERROR: The GetDisplayTimeZone method let a null pstrTimeZoneID through to TimeZoneInfo.FindSystemTimeZoneById..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_REPORT_ITEM_IS_NULL">
            <summary>
              Looks up a localized string similar to ERROR: No value has been assigned to this object..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_REPORT_ITEM_IS_UNLABELED">
            <summary>
              Looks up a localized string similar to ERROR: This detail object is incomplete. It needs a label..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_SECURITY">
            <summary>
              Looks up a localized string similar to ACCESS VIOLATION: The GetDisplayTimeZone method cannot read the Registry keys where the time zone information is kept. The process has insufficient access permissions on that key..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_SPECIFIED_LABEL_IS_NULL_OR_BLANK">
            <summary>
              Looks up a localized string similar to ERROR: Label property of a ReportDetail cannot be null or blank..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_START_CHARACTER">
            <summary>
              Looks up a localized string similar to starting at character position {0}{1}{2}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_STRING_FIXUP_PAIR_IS_INVALID">
            <summary>
              Looks up a localized string similar to The InputValue of the fixup pair at ordinal position {0} (subscript = {1}) is a null reference or the empty string.{4}    The OutputValue at that position is {2}, which is {3}..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_THIS_REPORTITEM_IS_NULL">
            <summary>
              Looks up a localized string similar to ERROR: The value of the report item labeled {0} has not been set..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_TZ_NOT_FOUND">
            <summary>
              Looks up a localized string similar to INTERNAL or DATA ERROR: The GetDisplayTimeZone method let a pstrTimeZoneID that isn&apos;t registered on this computer through to TimeZoneInfo.FindSystemTimeZoneById.{1}                        Specified ID = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_UNLABELED">
            <summary>
              Looks up a localized string similar to * UNLABELED *.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_UNRESLOVED_ENVIRONEMT_STRINGS">
            <summary>
              Looks up a localized string similar to INPUT ERROR: Specified input string {0}{2}             contains {1} unresolved environment variable.{2}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.ERRMSG_VARIABLE_LITERAL">
            <summary>
              Looks up a localized string similar to variable.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.FILE_DETAILS">
            <summary>
              Looks up a localized string similar to {9}{0} Absolute Name = {1}{8}{7} Modified Date = {2}{8}{7} Date Created  = {3}{8}{7} Date Accessed = {4}{8}{7} Size in bytes = {5}{8}{7} Attributes    = {6}{10}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.FORMAT_SUBSTRINGSTARTANDLENGTH_TOSSTRING">
            <summary>
              Looks up a localized string similar to SubstringStart = {0}, SubstringLength = {1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_EFI_APPLICATION">
            <summary>
              Looks up a localized string similar to Image is an EFI Application..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER">
            <summary>
              Looks up a localized string similar to Image is a EFI Boot Service Driver..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_EFI_ROM">
            <summary>
              Looks up a localized string similar to Image runs from a EFI ROM..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER">
            <summary>
              Looks up a localized string similar to Image is a EFI Runtime Driver..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_NATIVE">
            <summary>
              Looks up a localized string similar to Image doesn&apos;t require a subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_NATIVE_WINDOWS">
            <summary>
              Looks up a localized string similar to Image is a native Win9x driver..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_OS2_CUI">
            <summary>
              Looks up a localized string similar to Image runs in the OS/2 character subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_POSIX_CUI">
            <summary>
              Looks up a localized string similar to Image runs in the Posix character subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_UNDEFINED_VALUE">
            <summary>
              Looks up a localized string similar to The specified image subsystem ID, {0} is undefined..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_UNKNOWN">
            <summary>
              Looks up a localized string similar to Unknown subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_WINDOWS_CE_GUI">
            <summary>
              Looks up a localized string similar to Image runs in the Windows CE subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_WINDOWS_CUI">
            <summary>
              Looks up a localized string similar to Image runs in the Windows character subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_WINDOWS_GUI">
            <summary>
              Looks up a localized string similar to Image runs in the Windows GUI subsystem..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.IMAGE_SUBSYSTEM_XBOX">
            <summary>
              Looks up a localized string similar to Image runs on XBOX..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.INCREMENT_CANNOT_BE_ZERO">
            <summary>
              Looks up a localized string similar to Must be greater than zero..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.INCREMENT_PROPERTY_VALUE">
            <summary>
              Looks up a localized string similar to Increment Property Value.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.LOCAL_AND_UTC_TIME_TEMPLATE">
            <summary>
              Looks up a localized string similar to {0} ({1} UTC).
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_ACCEPTED_DEFAULT_VALUE">
            <summary>
              Looks up a localized string similar to     {0} of {1}: {2} = {3}{4}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_ACCEPTED_LIST_END">
            <summary>
              Looks up a localized string similar to {0}End of list{0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_ALL_CONFIG_SETTINGS_COVERED">
            <summary>
              Looks up a localized string similar to All {0} configuration settings defined for {1} are covered by its configuration file..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_DEFAULT_ACCEPTED">
            <summary>
              Looks up a localized string similar to {0} property default value of {1} accepted in lieu of value in configuration file, which is absent..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_SOME_CONFIG_SETTINGS_OMITTED">
            <summary>
              Looks up a localized string similar to {0} of {1} configuration settings defined for {2} are missing from its configuration file.{3}{3} Details follow.{3}{3}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_STACK_TRACE_IS_FROM_ENVIRONMENT">
            <summary>
              Looks up a localized string similar to at System.Environment.get_StackTrace().
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.MSG_STRING_FIXUPS_TOSTRING">
            <summary>
              Looks up a localized string similar to InputValue = {0}, OutputValue = {1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.PROCESSOR_AND_PROCESS_ARCHITECTURES">
            <summary>
              Looks up a localized string similar to {2}Processor Architecture = {0}{2}Process Machine Word   = {1} bits{2}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.SWITCH_IS_OFF">
            <summary>
              Looks up a localized string similar to OFF.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.SWITCH_IS_ON">
            <summary>
              Looks up a localized string similar to ON.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.SYNCROOT_TOSTRING_TEMPLATE">
            <summary>
              Looks up a localized string similar to {{{0} ({1})}}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TDF_INVALID_ARG_VALUE">
            <summary>
              Looks up a localized string similar to The value of {1} specified for argument {0} is invalid..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TDF_INVALID_ENUM_VALUE">
            <summary>
              Looks up a localized string similar to The new value of {1} specified for the {0} property is invalid.{3}The previous value of {2} is retained..
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TIME_LABEL_LOCAL_LONG">
            <summary>
              Looks up a localized string similar to Local.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TIME_LABEL_LOCAL_SHORT">
            <summary>
              Looks up a localized string similar to LOC.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TIME_LABEL_UTC">
            <summary>
              Looks up a localized string similar to UTC.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_1">
            <summary>
              Looks up a localized string similar to Properties of the Exception object returned by TraceLogger.WriteWithBothTimesLabeledLocalFirst: Message                        = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_2">
            <summary>
              Looks up a localized string similar to Source                         = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_3">
            <summary>
              Looks up a localized string similar to TargetSite.Name                = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_4">
            <summary>
              Looks up a localized string similar to StackTrace                     = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_5">
            <summary>
              Looks up a localized string similar to InnerException.Message         = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_6">
            <summary>
              Looks up a localized string similar to InnerException.Source          = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_7">
            <summary>
              Looks up a localized string similar to InnerException.TargetSite.Name = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_8">
            <summary>
              Looks up a localized string similar to InnerException.StackTrace      = {0}.
            </summary>
        </member>
        <member name="P:WizardWrx.Core.Properties.Resources.TRACEMSG_EXCEPTION_NOT_THROWN_9">
            <summary>
              Looks up a localized string similar to &quot;                                                                                                InnerException                 = [null].
            </summary>
        </member>
        <member name="T:WizardWrx.Cryptography.DigestFile">
            <summary>
            Static methods for computing message digests for files, using the most
            common algorithms.
            
            iMPORTANT: Since files are read in binary, they are loaded directly
            into the hash algorithm as byte arrays. This means that the digest
            of a file of ASCII characters and the hash of the file contents read
            into a CLR string object, which is a string of Unicode characters,
            will differ. The reason for this is that the string of Unicode 
            characters yields a different byte stream than the byte stream that
            came from reading the file in binary mode.
            </summary>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestFile.MD5Hash(System.String)">
             <summary>
             Given the name of a file, return its MD5 message digest as a 32 
             character string of hexadecimal digits.
             </summary>
             <param name="pstrFileName">
             String containing the name of the file to be digested. See Remarks
             for important information about the internal implementation.
             
             iMPORTANT: Since files are read in binary, they are loaded directly
             into the hash algorithm as byte arrays. This means that the digest
             of a file of ASCII characters and the hash of the file contents read
             into a CLR string object, which is a string of Unicode characters,
             will differ. The reason for this is that the string of Unicode 
             characters yields a different byte stream than the byte stream that
             came from reading the file in binary mode.
             </param>
             <returns>
             The message digest, consisting of a string of 32 hexadecimal
             characters. This string is identical with the strings returned by
             the reference implementation, published by Dr. Ronald Rivest, who is
             credited with inventing the MD5 digest algorithm.
             </returns>
            <remarks>
             Since the internal hashing implementations expect byte arrays, the
             input string must be converted. The Encoding.Default.GetBytes method
             is called upon to convert the string into a byte array.
             
             A slightly modified version of the Rivest code, written in ANSI C,
             is the engine in my MD5WIN stand-alone program and my MD5Digest
             Windows Dynamic Link Library.
             
             However, this function uses a MD5CryptoServiceProvider object, which
             provides a managed interface to the Cryptographic Service Provider
             in the host's installation of Microsoft Windows. I chose this over
             the 100% managed implementation for two reasons.
             
             1) The CSP implementation uses native machine code for the
             computation, and should outperform managed code on large plain-texts.
             
             2) By using the native implementation, the CLR is eliminated as a
             potential point of failure due to a weakness in the implementation
             of the algorithm.
            </remarks>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestFile.SHA1Hash(System.String)">
            <summary>
            Given the name of a file, return its SHA-1 message digest as a 32
            character string of hexadecimal digits.
            </summary>
            <param name="pstrFileName">
            String containing the name of the file to be digested.
            
            iMPORTANT: Since files are read in binary, they are loaded directly
            into the hash algorithm as byte arrays. This means that the digest
            of a file of ASCII characters and the hash of the file contents read
            into a CLR string object, which is a string of Unicode characters,
            will differ. The reason for this is that the string of Unicode 
            characters yields a different byte stream than the byte stream that
            came from reading the file in binary mode.
            </param>
            <returns>
            The message digest, consisting of a string of 40 hexadecimal
            characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestFile.SHA256Hash(System.String)">
            <summary>
            Given the name of a file, return its SHA-256 message digest as a 64
            character string of hexadecimal digits.
            </summary>
            <param name="pstrFileName">
            String containing the name of the file to be digested.
            
            iMPORTANT: Since files are read in binary, they are loaded directly
            into the hash algorithm as byte arrays. This means that the digest
            of a file of ASCII characters and the hash of the file contents read
            into a CLR string object, which is a string of Unicode characters,
            will differ. The reason for this is that the string of Unicode 
            characters yields a different byte stream than the byte stream that
            came from reading the file in binary mode.
            </param>
            <returns>
            The message digest, consisting of a string of 64 hexadecimal
            characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestFile.SHA384Hash(System.String)">
            <summary>
            Given the name of a file, return its SHA-384 message digest as a 96
            character string of hexadecimal digits.
            </summary>
            <param name="pstrFileName">
            String containing the name of the file to be digested.
            
            iMPORTANT: Since files are read in binary, they are loaded directly
            into the hash algorithm as byte arrays. This means that the digest
            of a file of ASCII characters and the hash of the file contents read
            into a CLR string object, which is a string of Unicode characters,
            will differ. The reason for this is that the string of Unicode 
            characters yields a different byte stream than the byte stream that
            came from reading the file in binary mode.
            </param>
            <returns>
            The message digest, consisting of a string of 64 hexadecimal
            characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestFile.SHA512Hash(System.String)">
            <summary>
            Given the name of a file, return its SHA-512 message digest as a 128
            character string of hexadecimal digits.
            </summary>
            <param name="pstrFileName">
            String containing the name of the file to be digested.
            
            iMPORTANT: Since files are read in binary, they are loaded directly
            into the hash algorithm as byte arrays. This means that the digest
            of a file of ASCII characters and the hash of the file contents read
            into a CLR string object, which is a string of Unicode characters,
            will differ. The reason for this is that the string of Unicode 
            characters yields a different byte stream than the byte stream that
            came from reading the file in binary mode.
            </param>
            <returns>
            The message digest, consisting of a string of 64 hexadecimal
            characters.
            </returns>
        </member>
        <member name="T:WizardWrx.Cryptography.DigestString">
            <summary>
            Static methods for computing message digests for strings, using the most
            common algorithms.
            </summary>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA256Hash(System.String)">
            <summary>
            Given a string, return its SHA-256 message digest as a 64
            character string of hexadecimal digits.
            </summary>
            <param name="strPlaintext">
            Supply a pointer to the string to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 64
            hexadecimal characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA256Hash(System.Byte[])">
            <summary>
            Given a byte array, return its SHA-256 message digest as a 64
            character string of hexadecimal digits.
            </summary>
            <param name="pabytPlainText">
            Supply a pointer to the byte array to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 64
            hexadecimal characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA384Hash(System.String)">
            <summary>
            Given a string, return its SHA-384 message digest as a 96
            character string of hexadecimal digits.
            </summary>
            <param name="strPlaintext">
            Supply a pointer to the string to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 96
            hexadecimal characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA384Hash(System.Byte[])">
            <summary>
            Given a byte array, return its SHA-384 message digest as a 96
            character string of hexadecimal digits.
            </summary>
            <param name="pabytPlainText">
            Supply a pointer to the byte array to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 96
            hexadecimal characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA512Hash(System.String)">
            <summary>
            Given a string, return its SHA-512 message digest as a 128
            character string of hexadecimal digits.
            </summary>
            <param name="strPlaintext">
            Supply a pointer to the string to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 128
            hexadecimal characters.
            </returns>
        </member>
        <member name="M:WizardWrx.Cryptography.DigestString.SHA512Hash(System.Byte[])">
            <summary>
            Given a byte array, return its SHA-512 message digest as a 128
            character string of hexadecimal digits.
            </summary>
            <param name="pabytPlainText">
            Supply a pointer to the byte array to be digested.
            </param>
            <returns>
            The return value is a message digest, consisting of a string of 128
            hexadecimal characters.
            </returns>
        </member>
        <member name="T:WizardWrx.FileInfoExtension">
            <summary>
            Extend the System.IO.FileInfo class with methods for testing, setting,
            and clearing file attribute flags, including the ability to save and
            restore flags to their initial states.
            </summary>
        </member>
        <member name="T:WizardWrx.FileInfoExtension.enmInitialStatus">
            <summary>
            Define the three possible initial states.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtension.enmInitialStatus.Unknown">
            <value >
            This is the initial state, before the flag is tested.
            </value>
        </member>
        <member name="F:WizardWrx.FileInfoExtension.enmInitialStatus.WasCleared">
            <value>
            The flag was initially in the Cleared state.
            </value>
        </member>
        <member name="F:WizardWrx.FileInfoExtension.enmInitialStatus.WasSet">
            <value>
            The flag was initially in the Set state.
            </value>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.#ctor(System.String)">
            <summary>
            We insist on a file name.
            </summary>
            <param name="pstrFileName">
            String containing the name of a file to process. This string must
            point to an existing file.
            </param>
            <remarks>
            Because of its intended use, this class is designed without a public
            default constructor. I believe that it is extremely unlikely that a
            user would need to serialize an instance of this class.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ArchiveClear">
            <summary>
            Clear the Archive flag.
            </summary>
            <returns>
            Previous state of the Archive flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasArchive property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ArchiveReinstate">
            <summary>
            Restore the initial state of the Archive flag.
            </summary>
            <returns>
            Previous state of the Archive flag.
            </returns>
            <remarks>
            Since the return value is strictly informational, callers may safely
            ignore or discard it.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ArchiveSet">
            <summary>
            Set the Archive flag.
            </summary>
            <returns>
            Previous state of the Archive flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasArchive property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.HiddenClear">
            <summary>
            Clear the Hidden flag.
            </summary>
            <returns>
            Previous state of the Hidden flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasHidden property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.HiddenReinstate">
            <summary>
            Restore the initial state of the Hidden flag.
            </summary>
            <returns>
            Previous state of the Hidden flag.
            </returns>
            <remarks>
            Since the return value is strictly informational, callers may safely
            ignore or discard it.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.HiddenSet">
            <summary>
            Set the Hidden flag.
            </summary>
            <returns>
            Previous state of the Hidden flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasHidden property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ReadOnlyClear">
            <summary>
            Clear the Read ONly flag.
            </summary>
            <returns>
            Previous state of the Read ONly flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasReadOnly property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ReadOnlyReinstate">
            <summary>
            Restore the initial state of the Read Only flag.
            </summary>
            <returns>
            Previous state of the Read ONly flag.
            </returns>
            <remarks>
            Since the return value is strictly informational, callers may safely
            ignore or discard it.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.ReadOnlySet">
            <summary>
            Set the Read Only flag.
            </summary>
            <returns>
            Previous state of the Read ONly flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasReadOnly property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.SystemClear">
            <summary>
            Clear the System flag.
            </summary>
            <returns>
            Previous state of the System flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasSystem property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.SystemReinstate">
            <summary>
            Restore the initial state of the System flag.
            </summary>
            <returns>
            Previous state of the System flag.
            </returns>
            <remarks>
            Since the return value is strictly informational, callers may safely
            ignore or discard it.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtension.SystemSet">
            <summary>
            Set the System flag.
            </summary>
            <returns>
            Previous state of the System flag.
            </returns>
            <remarks>
            Since the initial state of the flag is preserved internally by the
            class, and can be read from the WasSystem property, callers may
            safely ignore or discard the return value.
            </remarks>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.TheFile">
            <summary>
            Return the underlying FileInfo object, which is initialized by the
            constructor.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Archive">
            <summary>
            This property returns the current state of the Archive attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Compressed">
            <summary>
            This property returns the current state of the Compressed attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Encrypted">
            <summary>
            This property returns the current state of the Encrypted attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Hidden">
            <summary>
            This property returns the current state of the Hidden attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.NotContentIndexed">
            <summary>
            This property returns the current state of the NotContentIndexed attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Offline">
            <summary>
            This property returns the current state of the Offline attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.ReadOnly">
            <summary>
            This property returns the current state of the ReadOnly attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.System">
            <summary>
            This property returns the current state of the System attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.Temporary">
            <summary>
            This property returns the current state of the Temporary attribute.
            </summary>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.WasArchive">
            <summary>
            Return the initial state of the Archive flag.
            </summary>
            <remarks>
            The value of this property is meaningless after the
            ArchiveReinstate method is called, and before either ArchiveClear
            or ArchiveSet has been called on an instance.
            </remarks>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.WasReadOnly">
            <summary>
            Return the initial state of the ReadOnly flag.
            </summary>
            <remarks>
            The value of this property is meaningless after the
            ReadOnlyReinstate method is called, and before either ReadOnlyClear
            or ReadOnlySet has been called on an instance.
            </remarks>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.WasHidden">
            <summary>
            Return the initial state of the Hidden flag.
            </summary>
            <remarks>
            The value of this property is meaningless after the
            HiddenReinstate method is called, and before either HiddenClear
            or HiddenSet has been called on an instance.
            </remarks>
        </member>
        <member name="P:WizardWrx.FileInfoExtension.WasSystem">
            <summary>
            Return the initial state of the System flag.
            </summary>
            <remarks>
            The value of this property is meaningless after the
            SystemReinstate method is called, and before either SystemClear
            or SystemSet has been called on an instance.
            </remarks>
        </member>
        <member name="T:WizardWrx.FileInfoExtensionMethods">
            <summary>
            The new extension methods that supersede the instance methods on the
            companion FileInfoExtension class go into a dedicated class, because a
            static class must expose them.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND">
            <summary>
            Unless the specified file exists and is accessible via the current
            user's security token, Windows throws a FileNotFoundException
            Exception. Rather than allow that to happen, this method reports its
            length as -1, a patently invalid value for a file length.
            </summary>
        </member>
        <member name="T:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow">
            <summary>
            Use with ShowFileDetails parameter penmFileDetailsToShow.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.None">
            <summary>
            Show only basic information: no UTC times, only LastWriteTime,
            and no Attributes.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalTime">
            <summary>
            Render all times as Local.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.UtcTime">
            <summary>
            Render all times as UTC.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.CreatedTime">
            <summary>
            Include the Created time.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AccessedTime">
            <summary>
            Include the Accessed time.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Size">
            <summary>
            Include the file size in bytes.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Attributes">
            <summary>
            Include the file attributes, both as a mask and as
            human-readable values.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc">
            <summary>
            Render time stamps as both Local and UTC.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimes">
            <summary>
            Report all three time stamps.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc">
            <summary>
            Report all times, showing both Local and UTC time stamps.
            </summary>
        </member>
        <member name="F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Everything">
            <summary>
            Show everything.
            </summary>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.ComputeTokenEnd(System.Int32,System.Int32,System.String)">
            <summary>
            Given <paramref name="pintPosTokenBegin"/>, the position of the
            beginning of a substring, <paramref name="pintPosTokenEnd"/>, the
            position of the token that marks the end of the substring, and the
            token, itself, represented by <paramref name="pstrToken"/>, from
            which to determine its length, return the length of the substring,
            inclusive of its terminal token.
            </summary>
            <param name="pintPosTokenBegin">
            Integer containing the position at which the substring of interest
            begins
            </param>
            <param name="pintPosTokenEnd">
            Integer containing the position at which the token that marks the
            end of the substring of interest begins
            </param>
            <param name="pstrToken">
            String containing the token that marks the end of the substring of
            interest
            </param>
            <returns>
            The return value is the length of the substring of interest,
            inclusive of its terminal token.
            </returns>
            <remarks>
            Though intended for use by the static constructor, this method may
            warrant being exposed as a public static method for wider use.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear(System.IO.FileInfo)">
            <summary>
            Clear the Archive FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the Archive attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)">
            <summary>
            Reinstate the Archive flag on the specified file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmInitialStatus">
            Specify the FileInfoExtension.enmInitialStatus value returned by the last call to 
            FileAttributeArchiveClear.
            </param>
            <returns>
            If the Archive attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet(System.IO.FileInfo)">
            <summary>
            Set the Archive FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the Archive attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear(System.IO.FileInfo)">
            <summary>
            Clear the Hidden FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the Hidden attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)">
            <summary>
            Reinstate the Hidden flag on the specified file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmInitialStatus">
            Specify the FileInfoExtension.enmInitialStatus value returned by the last call to 
            FileAttributeArchiveClear.
            </param>
            <returns>
            If the Hidden attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet(System.IO.FileInfo)">
            <summary>
            Set the Hidden FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the Hidden attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear(System.IO.FileInfo)">
            <summary>
            Clear the ReadOnly FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the ReadOnly attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)">
            <summary>
            Reinstate the ReadOnly flag on the specified file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmInitialStatus">
            Specify the FileInfoExtension.enmInitialStatus value returned by the last call to 
            FileAttributeArchiveClear.
            </param>
            <returns>
            If the ReadOnly attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet(System.IO.FileInfo)">
            <summary>
            Set the ReadOnly FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the ReadOnly attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear(System.IO.FileInfo)">
            <summary>
            Clear the System FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the specified bit (It's usually just one.) is set on entry, the
            return value is WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)">
            <summary>
            Reinstate the System flag on the specified file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmInitialStatus">
            Specify the FileInfoExtension.enmInitialStatus value returned by the last call to 
            FileAttributeArchiveClear.
            </param>
            <returns>
            If the System attribute is set on entry, the return value is
            WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet(System.IO.FileInfo)">
            <summary>
            Set the System FileAttributes on a file.
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <returns>
            If the specified bit (It's usually just one.) is set on entry, the
            return value is WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeClear(System.IO.FileInfo,System.IO.FileAttributes)">
            <summary>
            Clear the specified FileAttributes bit(s).
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmFileAttributes">
            This argument specifies the member(s) of the FileAttributes bitwise
            enumeration to clear.
            </param>
            <returns>
            If the specified bit (It's usually just one.) is set on entry, the
            return value is WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.FileAttributeSet(System.IO.FileInfo,System.IO.FileAttributes)">
            <summary>
            Set the specified FileAttributes bit(s).
            </summary>
            <param name="pfi">
            As an extension method, the first argument must be a reference to
            the instance that invoked it, which is used in much the same way as
            the implicit this parameter that leads the list of parameters for a
            call to any C# instance method.
            </param>
            <param name="penmFileAttributes">
            This argument specifies the member(s) of the FileAttributes bitwise
            enumeration to clear.
            </param>
            <returns>
            If the specified bit (It's usually just one.) is set on entry, the
            return value is WasSet; otherwise, it is WasCleared.
            </returns>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.ShowFileDetails(System.IO.FileInfo,WizardWrx.FileInfoExtensionMethods.FileDetailsToShow,System.String,System.Boolean,System.Boolean)">
            <summary>
            This is a general-purpose method for reporting details about a file.
            </summary>
            <param name="pfi">
            The framework supplies a reference to the FileInfo instance with
            which the call is associated.
            </param>
            <param name="penmFileDetailsToShow">
            Use one or more members of the FileDetailsToShow enumeration to
            specify the details to display. The FileDetailsToShow enumeration is
            a bit mask, and the enumeration defines the combinations that are
            most likely to be useful as additional members.
            
            The default value is FileDetailsToShow.Everything.
            </param>
            <param name="pstrLabel">
            The label string is optional and, if specified, appears at the start
            of the returned string. String magic is thereafter employed to keep
            subsequent lines of text aligned vertically.
            
            The default value is NULL, which resolves internally to the empty
            string.
            </param>
            <param name="pfPrefixWithNewline">
            If TRUE, the whole string begins with a platform-dependent newline.
            Otherwise, the string begins with the label specified by parameter
            <paramref name="pstrLabel"/>, if any, followed by the absolute file
            name.
            
            The default value is FALSE.
            </param>
            <param name="pfSuffixWithNewline">
            If TRUE, the string is terminated with a platform-dependent newline.
            Otherwise, the string ends with the last value specified by the
            <paramref name="penmFileDetailsToShow"/> bit mask.
            
            The default value is FALSE.
            </param>
            <returns>
            The return value is a human-readable multi-line report suitable for
            display on a console log, event log, print file, or message box.
            When the file is absent, its length is reported as -1.
            </returns>
            <see href="https://docs.microsoft.com/en-us/dotnet/api/system.io.fileinfo.length?view=netframework-4.8#System_IO_FileInfo_Length"/>
        </member>
        <member name="M:WizardWrx.FileInfoExtensionMethods.ComputeLengthToReport(System.IO.FileInfo)">
            <summary>
            The cleanest way to handle this special case is by way of a private
            method that takes the whole FileInfo reference, since the outcome is
            dependent upon the value of its Exists property, along with the more
            obvious dependency upon the Length property.
            </summary>
            <param name="pfi">
            This method receives a reference to the FileInfo object that was fed
            into the calling method, ShowFileDetails.
            </param>
            <returns>
            The NumericFormats.NUMBER_PER_REG_SETTINGS_0D custom format string
            is applied to the Length property to return a string representation
            of its Length property.
            </returns>
        </member>
        <member name="T:WizardWrx.FileNameTricks">
            <summary>
            This class exposes numerous static methods for manipulating file names.
            Unlike the objects in the System.File namespace, these methods don't 
            need a real file object. All work on strings that represent file names.
            </summary>
        </member>
        <member name="T:WizardWrx.FileNameTricks.TerminaBackslash">
            <summary>
            Use a member of this enumeration with FileDirName and PathFixup, to
            specify whether you want a path string with or without a trailing
            backslash.
            </summary>
            <see cref="M:WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)"/>
            <see cref="M:WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)"/>
        </member>
        <member name="F:WizardWrx.FileNameTricks.TerminaBackslash.Include">
            <summary>
            Include the trailing backslash, for example, if you intend to
            append another string containing a relative path name or an
            unqualified file name.
            </summary>
        </member>
        <member name="F:WizardWrx.FileNameTricks.TerminaBackslash.Omit">
            <summary>
            Exclude the trailing backslash, for example, if you intend to
            display the name in an unambiguous context.
            </summary>
        </member>
        <member name="F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM">
            <summary>
            Use this to insert an extension delimiter into a file specification,
            since there seems to be nothing in the System.IO namespace.
            </summary>
            <remarks>
            Strangely, I haven't found a property that returns the extension delimiter.
            </remarks>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER"/>
            <seealso cref="F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE"/>
        </member>
        <member name="F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE">
            <summary>
            </summary>
            Use this to insert a multiple-character wild card character into a
            Windows or Unix file name mask.
            <remarks>
            There doesn't appear to be any provision for generating these from anything
            in the System.IO namespace.
            </remarks>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER"/>
            <seealso cref="F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM"/>
        </member>
        <member name="F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE">
            <summary>
            Use this to insert a multiple-character wild card character into a
            Windows or Unix file name mask.
            </summary>
            <remarks>
            There doesn't appear to be any provision for generating these from anything
            in the System.IO namespace.
            </remarks>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER"/>
            <seealso cref="F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM"/>
        </member>
        <member name="F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER">
            <summary>
            Along with the OS extension delimiter, the sequence of volume
            separator, followed immediately by a directory separator, is
            undefined, though one could easily be constructed at run time,
            although such a construction wouldn't qualify as a constant.
            </summary>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM"/>
            <seealso cref="F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM"/>
        </member>
        <member name="F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM">
            <summary>
            The server delimiter string.
            </summary>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE"/>
            <seealso cref="F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE"/>
        </member>
        <member name="M:WizardWrx.FileNameTricks.EnsureHasTerminalBackslash(System.String)">
            <summary>
            Ensure that a path string has NO terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed to HAVE a terminal backslash.
            </returns>
            <remarks>
            This method is deprecated. Use PathAddBackslash.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileNameTricks.EnsureNoTerminalBackslash(System.String)">
            <summary>
            Ensure that a path string has a terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed NOT to have a terminal backslash.
            </returns>
            <remarks>
            This method is deprecated. Use PathRemoveBackslash.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathAddBackslash(System.String)">
            <summary>
            Ensure that a path string has NO terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed to HAVE a terminal backslash.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathAddBackslashDeprecated1(System.String)">
            <summary>
            Ensure that a path string has NO terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed to HAVE a terminal backslash.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathAddBackslashDeprecated2(System.String)">
            <summary>
            Ensure that a path string has NO terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed to HAVE a terminal backslash.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathMakeRelative(System.String,System.String)">
            <summary>
            Given a path, such as the fully qualified name of a resource DLL, and
            a second fully qualified name, such as that of the program directory
            or current working directory, compute a relative path to the first
            named path.
            </summary>
            <param name="pstrFQPath">
            This string is the fully qualified path for which a relative path is
            required. This string may be the name of a file or a directory, but
            it must exist in the file system.
            </param>
            <param name="pstrDirectoryRelativeTo">
            This string is the fully qualified path relative to which a path to
            pstrFQPath is required. This string may be the name of a file or a
            directory, but it must exist in the file system. Whether you supply
            a file name or that of its directory, the outcome is the same, since
            this has no effect on the relative path to pstrFQPath.
            </param>
            <returns>
            The returned string is a relative path string, ready for use.
            </returns>
            <remarks>
            This method uses methods of the System.Uri class to perform its path
            math, taking advantage of the fact that a path in the file system is
            a valid URI.
            </remarks>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathRemoveBackslash(System.String)">
            <summary>
            Ensure that a path string has a terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String to evaluate and change if needed.
            </param>
            <returns>
            Path string that is guaranteed NOT to have a terminal backslash.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)">
            <summary>
            Extract the directory name from a fully qualified file name.
            </summary>
            <param name="pstrFQFN">
            String containing file name to evaluate.
            </param>
            <param name="penmTerminaBackslash">
            A member of the TerminaBackslash, which specifies whether the
            returned string should have a terminal backslash.
            </param>
            <returns>
            If the function succeeds, the return value is the directory name
            stripped of its file name.
            </returns>
            <see cref="T:WizardWrx.FileNameTricks.TerminaBackslash"/>
        </member>
        <member name="M:WizardWrx.FileNameTricks.FileExtn(System.String)">
            <summary>
            Given a string that contains a partially or fully qualified file
            name, return the extension, without the delimiting dot.
            </summary>
            <param name="pstrFQFN">
            File name string to evaluate.
            </param>
            <returns>
            Extension, less the delimiting dot.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.FQFBasename(System.String)">
            <summary>
            Extract the fully qualified base name, that is, all but the
            extension, from a partially or fully qualified file name.
            </summary>
            <param name="pstrFQFN">
            Fully or partially qualified file name to evaluate.
            </param>
            <returns>
            All of pstrFQFN except its extension and extension delimiter.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.MakeFQFN(System.String,System.String)">
            <summary>
            Given a file name and a default directory, which may be a null
            reference or an empty string, return a file name that is guaranteed
            to be fully qualified.
            </summary>
            <param name="pstrUQFN">
            String which is assumed to be a relative file name.
            </param>
            <param name="pstrDefaultDir">
            String to use as a default path, unless argument pstrUQFN is a fully
            qualified file name.
            
            If this value is null, or an empty string, the current working
            directory is used.
            </param>
            <returns>
            String that contains a string that is guaranteed to represent a
            fully qualified file name.
            </returns>
        </member>
        <member name="M:WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)">
            <summary>
            Originally a private method, this method returns a path (directory)
            name string that is guaranteed to meet the specified requirement,
            with respect to presence or absence of a terminal backslash.
            </summary>
            <param name="pstrInputPath">
            String containing path (directory) name to evaluate.
            </param>
            <param name="penmBackslash">
            A member of the TerminaBackslash, which specifies whether the
            returned string should have a terminal backslash.
            </param>
            <returns>
            Path (directory) name string that is guaranteed to either have, or
            omit, a terminal backslash, as specified.
            </returns>
            <see cref="T:WizardWrx.FileNameTricks.TerminaBackslash"/>
        </member>
        <member name="M:WizardWrx.FileNameTricks.UQFBasename(System.String)">
            <summary>
            Given a string that represents the name of a file, extract only the
            base name (EXCLUDING the extension).
            </summary>
            <param name="pstrFQFN">
            String to evaluate.
            </param>
            <returns>
            Base name extracted from string. This means the unqualified file
            name, less its directory and its extension.
            </returns>
        </member>
        <member name="T:WizardWrx.GenericSingletonBase`1">
            <summary>
            Abstract class GenericSingletonBase is a complete implementation of the
            Singleton design pattern that takes full advantage of the Microsoft .NET
            Framework. Please see the Remarks for further details.
            </summary>
            <typeparam name="T">
            This class uses a recursive constraint on T, to require it to be derived
            from this base class.
            </typeparam>
            <remarks>
            The optimizations in this implementation take advantage of a guarantee
            made by the framework that it won't bother to call a static constructor
            on a class until its first use. Moreover, a static constructor is never
            called more than once, no matter how many subsequent references to the
            class occur.
            
            Taking advantage of these features of the framework eliminates the need
            for synchronization, and replaces a method call with a direct reference
            to the static read only property that returns a reference to the one and
            only instance.
            </remarks>
        </member>
        <member name="F:WizardWrx.GenericSingletonBase`1.PRIVATE_CTOR_OK">
            <summary>
            The static GenericSingletonBase constructor uses this flag as the
            second of two arguments to Activator.CreateInstance, to tell it that
            a private constructor is acceptable, which meets a requirement of
            the Singleton design pattern.
            </summary>
        </member>
        <member name="M:WizardWrx.GenericSingletonBase`1.#ctor">
            <summary>
            The private constructor has no real work to do, but it must exist to
            prevent the framework from generating a public constructor, which
            would violate a critical constraint of the Singleton design pattern.
            </summary>
            <remarks>
            This property is marked protected to give derived classes direct
            access to it, which their static members require. For example, in
            ExceptionLogger, the static initializer has more work to do that it
            cannot start until an instance exists.
            </remarks>
        </member>
        <member name="M:WizardWrx.GenericSingletonBase`1.#cctor">
            <summary>
            The static constructor initializes the private static 
            _genTheOnlyInstance member that holds the reference to the one and
            only instance of the derived class.
            </summary>
            <remarks>
            I had to stop and think for a minute about why the first token in
            the r-value is the upper case T, enclosed in parentheses. Then, I
            realized that it is an explicit cast.
            
            More obvious, due to recent experience adding a static constructor
            to another class, is that the static constructor cannot have an
            access modifier, and is, by definition, private. This simplification
            of the Singleton design pattern takes advantage of the fact that the
            framework won't run the static constructor until the first reference
            to the class arises.
            </remarks>
        </member>
        <member name="F:WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance">
            <summary>
            This static member holds the reference to the one and only instance
            of the derived class that is permitted.
            </summary>
            <remarks>
            This property is marked protected to give derived classes direct
            access to it, which their static members require. For example, in
            ExceptionLogger, the static initializer has more work to do that it
            cannot start until an instance exists.
            </remarks>
        </member>
        <member name="P:WizardWrx.GenericSingletonBase`1.TheOnlyInstance">
            <summary>
            This implementation simplifies access to the single instance by way
            of this static read-only property that returns the reference to the
            instance stored in its one and only private static member.
            </summary>
            <remarks>
            The sweet thing about this implementation is that your code doesn't
            need a copy of the reference, since a tail call on the static
            property is sufficient.
            </remarks>
        </member>
        <member name="M:WizardWrx.GenericSingletonBase`1.GetTheSingleInstance">
            <summary>
            Implement the traditional GetTheSingleInstance method for obtaining
            a reference to a Singleton object.
            </summary>
            <returns>
            This method should always succeed by returning a reference to the
            one and only instance of the derived class.
            </returns>
        </member>
        <member name="T:WizardWrx.ListHelpers">
            <summary>
            This class exposes methods for merging sorted lists of items, and to
            simplify working with the values returned through the IComparable 
            interface.
            </summary>
        </member>
        <member name="T:WizardWrx.ListHelpers.CompareResult">
            <summary>
            The CompareTwoOfAKind method returns a member of this enumeration,
            providing for the CompareTo method of the IComparable interface that
            it encapsulates with a tad of syntactic sugar.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.CompareResult.LessThan">
            <summary>
            Second argument, pComparand, is less than the first argument,
            pReference.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.CompareResult.EqualTo">
            <summary>
            Both arguments are equal.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.CompareResult.GreaterThan">
            <summary>
            Second argument, pComparand, is greater than the first argument,
            pReference.
            </summary>
        </member>
        <member name="T:WizardWrx.ListHelpers.MergeSource">
            <summary>
            This enumeration is used internally by the MergeNewItemsIntoArray
            method, where its use simplifies management of its internal state.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.MergeSource.Undetermined">
            <summary>
            This is the state at the beginning of the first iteration, until
            method CompareTwoOfAKind evaluates the first item in each list.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.MergeSource.AddItemFromMasterList">
            <summary>
            The outcome of the comparison is a decision to add the current
            item in the master list, which comes before the current item in
            the list of new items.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.MergeSource.AddItemFromNewList">
            <summary>
            The outcome of the comparison is a decision to add the current
            item in the list of new items, which is either a newer version
            of the current item in the master list, or a completely new item
            that comes next in the sort order defined by the class CompareTo
            method.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.MergeSource.FinishFromMasterList">
            <summary>
            All items in the list of new items have been merged. Finish by
            appending the remaining items in the master list, all of which
            follow the last item in the list of new items in the sort order
            defined by the class CompareTo method.
            </summary>
        </member>
        <member name="F:WizardWrx.ListHelpers.MergeSource.FinishFromNewItemsList">
            <summary>
            All items in the master list have been merged. Fihish by
            appending the remaining items in the list of new items, all of
            which follow the last item in the list of new items in the sort
            order defined by the class CompareTo method.
            </summary>
        </member>
        <member name="M:WizardWrx.ListHelpers.CompareTwoOfAKind``1(``0,``0)">
            <summary>
            Compare two objects of a kind. See Remarks.
            </summary>
            <typeparam name="T">
            Both comparands must implement the IComparable interface.
            </typeparam>
            <param name="pReference">
            The object against which to make the comparison.
            </param>
            <param name="pComparand">
            A second object of the same type against which to compare.
            </param>
            <returns>
            The return value is a member of the CompareResult enumeration, which
            reduces evaluation of results returned by the CompareTo method to a
            three-case switch statement.
            </returns>
            <exception cref="T:System.NullReferenceException">
            A NullReferenceException exception is thrown when pReference is null.
            The CompareTo method of the object's IComparable interface is
            expected to return a LessThan result when pComparand is null. See
            Remarks.
            </exception>
            <remarks>
            This method encapsulates the CompareTo method of a class T,
            returning a member of the CompareResult enumeration in place of the
            arbitrary zero or positive or negative integer specified in the
            IComparable interface. This syntactic sugar enables its return value
            to be processed by a switch block, rather than a nested IF block.
            
            Whether or not I wrote it into the this, calling CompareTo on a null
            pReference object would elicit a NullReference exception. Having the
            application throw the exception permits it to supply a more
            informative message than the one that the CLR would have generated.
            For a two-argument function, the generic message is ambiguous.
            </remarks>
        </member>
        <member name="M:WizardWrx.ListHelpers.MergeNewItemsIntoArray``1(``0[],``0[])">
            <summary>
            Merge two sorted lists, returning a new sorted list containg the new
            or updated items from a second list. Please see Remarks.
            </summary>
            <typeparam name="T">
            All three lists (both inputs, paMasterList and paNewItems, and the
            returned list) must contain objects of the same type, and that type
            must implement the IComparable interface and have a parameterless
            default constructor.
            </typeparam>
            <param name="paMasterList">
            This array is the master list. Items without matching items in list
            paNewItems are preserved. Please see Remarks.
            </param>
            <param name="paNewItems">
            An item that matches an item in list paMasterList replaces it. An
            item that doesn't match any existing item in list paMasterList is
            merged into it. Please see Remarks.
            </param>
            <returns>
            The returned list contains everything in list paNewItems, and
            everything in list paMasterList that has no matching item in list
            paMasterList. Please see Remarks. Since both input lists are sorted,
            the new list is also sorted.
            </returns>
            <remarks>
            The goal of this routine is to merge two lists, the first of which
            is treated as a master list, into which new and updated items from
            from the second list are merged.
            
            Merging is based on comparing items from both lists based on the
            values returned by their respective CompareTo methods. Values that
            return zero (equality) are merged by replacing the value from the
            first list, represented by the first argument (paMasterList) with
            that from the second list, represented by the second argument
            (paNewItems).
            
            This algorithm imposes four requirements on its inputs.
            
            1) Both input arrays must be composed of objects of the same type.
            
            2) That type must implement the IComparable interface.
            
            3) That type must have a default constructor.
            
            4) Both input arrays must be sorted.
            
            In return, it makes the following four guarantees.
            
            1) Every item in array paNewItems will become part of the new list.
            
            2) Every item in array paMasterList that has no matching value in
            array paNewItems will become part of the new list.
            
            3) Every item in array paNewItems that matches an item in array
            paMasterList replaces that matching item.
            
            4) Every item in array paNewItems that doesn't match any item in
            paMasterList is added to the list.
            
            On input, both lists must be sorted, which is the first reason that
            the objects in the arrays must implement IComparable. The second
            reason is that this routine must compare the two lists in order to
            merge them correctly. The comparison happens in CompareTwoOfAKind, a
            companion routine that also takes generics meeting the first of the
            two specified constraints.
            </remarks>
        </member>
        <member name="T:WizardWrx.Logic">
            <summary>
            This sealed class exposes methods that encapsulate many common, tricky
            loop state tests.
            
            Since static classes are implicitly sealed, this class cannot be inherited.
            </summary>
        </member>
        <member name="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its first
            iteration.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintInitialValue">
            Specify the integer initial value.
            </param>
            <returns>
            This function returns TRUE if the index of a FOR loop is at its
            initial value, indicating the first iteration of the loop.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its last
            iteration, given that the limit criterion is pintLoopIndex is
            greater than pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the next increment of the loop index
            would set one less than pintLimit, stopping the loop without another
            iteration.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its last
            iteration, given that the limit criterion is pintLoopIndex is
            greater than or equal to pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the next increment of the loop index
            would set equal to pintLimit, stopping the loop without another
            iteration.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its last
            iteration, given that the limit criterion is pintLoopIndex is
            greater than pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the next increment of the loop index
            would set one less than pintLimit, stopping the loop without another
            iteration.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its last
            iteration, given that the limit criterion is pintLoopIndex is less
            than or equal to pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the next increment of the loop index
            would set it equal to pintLimit, stopping the loop without another
            iteration.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on its last
            iteration, given that the limit criterion is pintLoopIndex is less
            than pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the next increment of the loop index
            would set it equal to pintLimit, stopping the loop without another
            iteration.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex is on a
            subsequent iteration.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintInitialValue">
            Specify the integer initial value.
            </param>
            <returns>
            This function returns TRUE if the index of a FOR loop has passed its
            initial value, indicating that it is on a subsequent iteration of
            the loop.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex has one or more
            iteration to go, given that the limit criterion is pintLoopIndex is
            equal to pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the index and limit indicate that one
            or more iterations remain.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex has one or more
            iteration to go, given that the limit criterion is pintLoopIndex is
            greater than or equal to pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the index and limit indicate that one
            or more iterations remain.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex has one or more
            iteration to go, given that the limit criterion is pintLoopIndex is
            greater than pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the index and limit indicate that one
            or more iterations remain.
            </returns>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex has one or more
            iteration to go, given that the limit criterion is pintLoopIndex is less
            than or equal to pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the index and limit indicate that one
            or more iterations remain.
            </returns>
            <remarks>
            Sometimes, it is more sensible to test whether there are iterations
            remaining.
            </remarks>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)">
            <summary>
            Return TRUE if the FOR loop driven by pintLoopIndex has one or more
            iteration to go, given that the limit criterion is pintLoopIndex is less
            than pintLimit.
            </summary>
            <param name="pintLoopIndex">
            Specify the integer loop index.
            </param>
            <param name="pintLimit">
            Specify the integer limit value.
            </param>
            <returns>
            This function returns TRUE if the index and limit indicate that one
            or more iterations remain.
            </returns>
            <remarks>
            Sometimes, it is more sensible to test whether there are iterations
            remaining.
            </remarks>
            <seealso cref="M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)"/>
            <seealso cref="M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WizardWrx.Logic.Unless(System.Boolean)">
            <summary>
            Return the inverse of the truth value of an expression.
            </summary>
            <param name="pfUnlessWhat">
            Specify the expression to invert.
            </param>
            <returns>
            Return TRUE if pfUnlessWhat is FALSE, and vice vers.
            </returns>
            <remarks>
            I shamelessly borrowed this idiom from Perl, with full credit to
            Larry Wall, and implemented it as a macro for the C and C++ source
            code preprocessors about a decade ago. I don't know why it's taken
            me this long to realize that it is equally easy to implement in C#,
            and the implementation is sufficiently small that the code optimizer
            will almost certainly inline it, so that its performance impact is
            equivalent to the C/C++ macro.
            
            The C# implementation is not quite as neat as the C/C++ macro.
            </remarks>
        </member>
        <member name="T:WizardWrx.NumberFormatters">
            <summary>
            This static class exposes methods to further simplify formatting of
            integers, floating point (single precision real numbers) and double
            precision real numbers. For integers, these methods cover both decimal
            and the most frequently used hexadecimal representations, spanning from
            two through sixteen hexadecimal glyphs.
            </summary>
            <remarks>
            Since everything returns a string, the values can be appended to arrays
            of format items to use as inputs to the most open-ended overload of the
            string.Format method.
            </remarks>
        </member>
        <member name="M:WizardWrx.NumberFormatters.DecimalNumber(System.Double,System.Int32)">
            <summary>
            Format any double precision number per the Regional Settings,
            overriding the digits past the decimal point to render a specified
            number of significant digits to the right of the decimal point.
            </summary>
            <param name="pdblDecimalNumber">
            Floating point value to be formatted
            </param>
            <param name="pintSignificantDigits">
            Number of significant digits to display
            </param>
            <returns>
            Floating point value, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.DecimalNumber(System.Single,System.Int32)">
            <summary>
            Format any floating point number per the Regional Settings, 
            overriding the digits past the decimal point to render a specified
            number of significant digits to the right of the decimal point.
            </summary>
            <param name="pfltDecimalNumber">
            Floating point value to be formatted
            </param>
            <param name="pintSignificantDigits">
            Number of significant digits to display
            </param>
            <returns>
            Floating point value, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.DollarsAndCents(System.Double)">
            <summary>
            Format any double precision number per the Regional Settings, 
            overriding the digits past the decimal point to render dollars and
            cents.
            </summary>
            <param name="pdblDollarsAndCents">
            Floating point value to be formatted
            </param>
            <returns>
            Floating point value, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.DollarsAndCents(System.Single)">
            <summary>
            Format any floating point number per the Regional Settings, 
            overriding the digits past the decimal point to render dollars and
            cents.
            </summary>
            <param name="pfltDollarsAndCents">
            Floating point value to be formatted
            </param>
            <returns>
            Floating point value, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Hexadecimal2(System.Int32)">
            <summary>
            Format any integer to display as a minimum of two hexadecimal
            "digits."
            </summary>
            <param name="pintAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Hexadecimal4(System.Int32)">
            <summary>
            Format any integer to display as a minimum of four hexadecimal
            "digits."
            </summary>
            <param name="pintAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Hexadecimal8(System.Int32)">
            <summary>
            Format any integer to display as a minimum of eight hexadecimal
            "digits."
            </summary>
            <param name="pintAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Hexadecimal16(System.Int64)">
            <summary>
            Format any long integer to display as a minimum of sixteen hexadecimal
            "digits."
            </summary>
            <param name="plngAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Integer(System.Int32)">
            <summary>
            Format any integer per the Regional Settings, overriding the digits
            past the decimal point to render an integer.
            </summary>
            <param name="pintAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="M:WizardWrx.NumberFormatters.Integer(System.Int64)">
            <summary>
            Format any long integer per the Regional Settings, overriding the
            digits past the decimal point to render an long integer.
            </summary>
            <param name="plngAnyInteger">
            Integer to be formatted
            </param>
            <returns>
            Formatted integer, ready to display
            </returns>
        </member>
        <member name="T:WizardWrx.RecoveredException">
            <summary>
            Override the Exception class, so that the Source, StackTrace, and
            TargetSite properties can be directly initialized.
            </summary>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor">
            <summary>
            The default constructor must be marked as private, so that it cannot
            be called.
            </summary>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor(System.String)">
            <summary>
            The usual constructor that takes a Message must also be marked as
            private, so that it cannot be called, either.
            </summary>
            <param name="message">
            The usual message property, available to all Exception consumers
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor(System.String,System.Exception)">
            <summary>
            The usual constructor that takes a <paramref name="message"/> and an
            <paramref name="innerException"/> must also be hidden from view.
            </summary>
            <param name="message">
            The usual message property, available to all Exception consumers
            </param>
            <param name="innerException">
            The usual InnerException property, available to all Exception consumers
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Call this method when you have only a message to record.
            </summary>
            <param name="message">
            The usual message property, available to all Exception consumers
            </param>
            <param name="Source"></param>
            Gets or sets the name of the application or the object that causes the error
            <param name="StackTrace">
            Gets a string representation of the immediate frames on the call stack
            </param>
            <param name="TargetSite">
            Gets the method that throws the current exception
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor(System.String,System.Exception,System.String,System.String,System.String)">
            <summary>
            Call this method when you have an InnerException Exception to preserve.
            </summary>
            <param name="message">
            The usual message property, available to all Exception consumers
            </param>
            <param name="innerException">
            The usual InnerException property, available to all Exception consumers
            </param>
            <param name="Source"></param>
            Gets or sets the name of the application or the object that causes the error
            <param name="StackTrace">
            Gets a string representation of the immediate frames on the call stack
            </param>
            <param name="TargetSite">
            Gets the method that throws the current exception
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Enable serialization by implementing the protected constructor that
            can recreate an exception from serialization data.
            </summary>
            <param name="info">
            Specify the SerializationInfo object from which to reconstruct the
            RecoveredException.
            </param>
            <param name="context">
            Specify the StreamingContext object from which to reconstruct the
            RecoveredException.
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.InitializeInstance(System.String,System.String,System.String)">
            <summary>
            Both public constructors call this little routine to initialize the
            three properties that are usually initalized by the runtime system.
            </summary>
            <param name="source">
            Gets or sets the name of the application or the object that causes the error
            </param>
            <param name="stackTrace">
            Gets a string representation of the immediate frames on the call stack
            </param>
            <param name="targetSite">
            Gets the method that throws the current exception
            </param>
        </member>
        <member name="M:WizardWrx.RecoveredException.PruneStackTrace(System.String)">
            <summary>
            If the stack trace originated from the System.Environment property,
            its first two entries are irrelevant, and should be discarded. This
            routine makes that happen.
            </summary>
            <param name="pstrStackTrace"></param>
            This method receives the stack trace that was passed into the
            sonctructor.
            <returns>
            If the stack trace came from the System.Environment.StackTrace
            property, its first two entries are discarded. Otherwise, the whole
            string is returned.
            </returns>
        </member>
        <member name="P:WizardWrx.RecoveredException.Source">
            <summary>
            This is a stand-in for the Source property that is usually set
            by the runtime environment when an exception is thrown.
            </summary>
        </member>
        <member name="P:WizardWrx.RecoveredException.StackTrace">
            <summary>
            This is a stand-in for the StackTrace property that is usually set
            by the runtime environment when an exception is thrown.
            </summary>
        </member>
        <member name="P:WizardWrx.RecoveredException.TargetSite">
            <summary>
            This is a stand-in for the TargetSite property that is usually set
            by the runtime environment when an exception is thrown.
            </summary>
        </member>
        <member name="T:WizardWrx.ReportDetail">
            <summary>
            Instances of this class are generic report details, with labels and
            formats for printing them.
            </summary>
        </member>
        <member name="T:WizardWrx.ReportDetail.ItemDisplayOrder">
            <summary>
            This one-member structure prevents the Common Language Runtime from
            misdirecting the signed integer Value argument of a constructor,
            which might have a valid value of zero, into a constructor that
            expects a DisplayOrder value, which is prohibited from being zero.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.ItemDisplayOrder.Order">
            <summary>
            With some help from an IComparable implementation, this governs
            the order of appearance of items in the report.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetail.ItemDisplayOrder.#ctor(System.Int32)">
            <summary>
            Hide the display order value, a signed integer, from the CLR.
            </summary>
            <param name="itemdisplayorder">
            Specify the unsigned integer display order value to hide inside
            this structure.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit(WizardWrx.ReportDetail.ItemDisplayOrder)~System.Int32">
            <summary>
            Implicitly convert an ItemDisplayOrder to its true type, which
            is signed integer.
            </summary>
            <param name="itemdisplayorder">
            Specify the ItemDisplayOrder to be implicitly cast to unsigned
            integer.
            </param>
            <returns>
            The return value is the signed integer that is wrapped inside
            this structure.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit(System.Int32)~WizardWrx.ReportDetail.ItemDisplayOrder">
            <summary>
            Explicitly convert an unsigned integer to the ItemDisplayOrder
            type that is intended to protect it from receiving signed
            integers that are intended to be treated as report values.
            </summary>
            <param name="pintItemdisplayorder">
            The return value is the input value, wrapped in a new
            ItemDisplayOrder structure.
            </param>
            <returns>
            The return value is an ItemDisplayOrder structure wrapped around
            the specified integer.
            </returns>
            <remarks>
            This operator must be explicit to coerce use of an explicit cast
            to steer the CLR to bind to the desired ReportDetail constructor.
            </remarks>
        </member>
        <member name="M:WizardWrx.ReportDetail.ItemDisplayOrder.CompareTo(WizardWrx.ReportDetail.ItemDisplayOrder)">
            <summary>
            This method implements iComparable for instances of the 
            ItemDisplayOrder structure.
            </summary>
            <param name="itemDisplayOrder">
            Specify the ItemDisplayOrder to be compared against the current
            instance.
            </param>
            <returns>
            The return value is a standard CompareTo result, applied to the
            integers wrapped inside the two operands.
            </returns>
        </member>
        <member name="T:WizardWrx.ReportDetail.State">
            <summary>
            This enumeration keeps track of the state of the instance.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.Empty">
            <summary>
            The instance is empty.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveLabel">
            <summary>
            The Label property has been set.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveValueObject">
            <summary>
            The Value property has been set.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveValueString">
            <summary>
            The DisplayValue property has been set.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveListOrder">
            <summary>
            The ListOrder property has been set.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveFormatItems">
            <summary>
            Either the SupplementaryDetails property is set, or it can 
            inherit an array from the static DetailFormatItems property.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveValue">
            <summary>
            One or both of the DsiplayValue and Value properties has been set.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.State.HaveLabelAndValue">
            <summary>
            The Label property has been set, as has either or both of the Value properties.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.DEFAULT_FORMAT">
            <summary>
            Use this format for reports, unless the caller overrides it.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.THROW_ON_INVALID_STATE">
            <summary>
            When the FormatDetail method is called before the object is fully
            initialized, throw an System.InvalidOperationException exception.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetail.RETURN_ON_INVALID_STATE">
            <summary>
            When the FormatDetail method is called before the object is fully
            initialized, return an error message. Since the returned value is
            expected to go into a file of some kind (which may be a print file),
            this is a much cheaper way of handling the exception. However, as is
            almost always true, there is a cost, because throwing an exception
            typically causes the application to return a nonzero exit code, but
            writing it into a file yields an exit code of zero.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.ThrowOnInvalidState">
            <summary>
            The state of this flag determines what happens when FormatDetail is
            called when the object is partially initialized.
            
            The default action, False (RETURN_ON_INVALID_STATE) is the behavior
            originally programmed into it.
            
            When set to True, (THROW_ON_INVALID_STATE), the message that would
            have been returned becomes the Message property of an 
            System.InvalidOperationException exception.
            </summary>
        </member>
        <member name="T:WizardWrx.ReportDetail.LabelChangedEventArgs">
            <summary>
            The LabelChanged event needs to pass two integers to the event sink.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            LabelChangedEventArgs has one public constructor, which creates
            and fully initializes the instance. 
            </summary>
            <param name="pintNewLength">
            The new length can't simply be added.
            </param>
            <param name="pintOldLength">
            The old length can bear any relation to the new length.
            </param>
        </member>
        <member name="P:WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength">
            <summary>
            The new length is added to the accumulated total.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength">
            <summary>
            The old length is subtracted from the total.
            </summary>
        </member>
        <member name="E:WizardWrx.ReportDetail.LabelChanged">
            <summary>
            Delegates register here.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetail.OnLabelChanged(WizardWrx.ReportDetail.LabelChangedEventArgs)">
            <summary>
            Raise this event to signal listeners that the length of the label
            changed.
            </summary>
            <param name="e">
            The LabelChangedEventArgs method is populated with the new and old
            label length, so that only the difference is added to the total.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor">
            <summary>
            The default constructor creates an empty ReportDetail.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String)">
            <summary>
            Create a ReportDetail, and set its Label property.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder)">
            <summary>
            Create a ReportDetail, and set its Label and DisplayOrder
            properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)">
            <summary>
            Create a ReportDetail, and set its Label, DisplayOrder, and 
            DisplayFormat, and SupplementaryDetails properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])">
            <summary>
            Create a ReportDetail, and set its Label, DisplayOrder, 
            DisplayFormat properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
            <param name="supplementarydetails">
            Override the default SupplementaryDetails property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object)">
            <summary>
            Create a ReportDetail, and set its Label and Value properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="pobjValue">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder)">
            <summary>
            Create a ReportDetail, and set its Label and Value properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="value">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)">
            <summary>
            Create a ReportDetail, and set its Label, Value, DisplayOrder, and
            DisplayFormat properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="value">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])">
            <summary>
            Create a ReportDetail, and set its Label, Value, DisplayOrder,
            DisplayFormat, and SupplementaryDetails properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="value">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
            <param name="supplementarydetails">
            Override the default SupplementaryDetails property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.String)">
            <summary>
            Create a ReportDetail, and set its Label and DisplayValue properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)">
            <summary>
            Create a ReportDetail, and set its Label and DisplayValue properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)">
            <summary>
            Create a ReportDetail, and set its Label, DisplayValue,
            DisplayOrder, and DisplayFormat properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])">
            <summary>
            Create a ReportDetail, and set its Label, DisplayValue,
            DisplayOrder, DisplayFormat, and SupplementaryDetails properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
            <param name="supplementarydetails">
            Override the default SupplementaryDetails property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String)">
            <summary>
            Create a ReportDetail, and set its Label. native value, and
            DisplayValue properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="pobjValue">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)">
            <summary>
            Create a ReportDetail, and set its Label. native value, 
            DisplayValue, and DisplayOrder properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="pobjValue">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)">
            <summary>
            Create a ReportDetail, and set its Label. native value, 
            DisplayValue, DisplayOrder, and DisplayFormat properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="pobjValue">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])">
            <summary>
            Create a ReportDetail, and set its Label. native value, 
            DisplayValue, DisplayOrder, DisplayFormat, and SupplementaryDetails
            properties.
            </summary>
            <param name="label">
            Initial value for label, which can be neither null, nor empty.
            </param>
            <param name="pobjValue">
            Initial data value, as an Object, which MAY be a null reference.
            </param>
            <param name="displayvalue">
            Initial string representation of data value, which MAY be a null
            reference or an empty string.
            </param>
            <param name="itemdisplayorder">
            DisplayOrder must be greater than zero.
            </param>
            <param name="displayformat">
            Override the default DisplayFormat property.
            </param>
            <param name="supplementarydetails">
            Override the default SupplementaryDetails property.
            </param>
        </member>
        <member name="P:WizardWrx.ReportDetail.DetailState">
            <summary>
            Report on the state of the instance, for evaluating its readiness
            for use on a report.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.DisplayFormat">
            <summary>
            Get or set the default format string to use with the label and value
            to display an item on a report. See remarks for critical
            information.
            </summary>
            <remarks>
            The first three format items, {0}, {1}, and {2} are reserved for the
            label, value, and item number. Additional format items, if any, are
            populated from the objects in the SupplementaryDetails array.
            
            The FormatDetail method creates a new object array with enough room
            to hold the SupplementaryDetails array, plus three, fills it by
            inserting the label, value, and item number into the first three
            slots, and appending the SupplementaryDetails array, if it exists,
            and passes the whole array to string.Format.
            
            Unless its value differs from the current static (default) value,
            this property stays NULL. When callers query this property, the
            static property is returned if the instance property is null. Hence,
            the property behaves like a instance property, without wasting space
            to store duplicates of the default value. Hence, output routines
            need not check both properties.
            </remarks>
        </member>
        <member name="P:WizardWrx.ReportDetail.SupplementaryDetails">
            <summary>
            This property gives read/write access to the SupplementaryDetails
            property, an array of Objects for use with the DisplayFormat
            property. See remarks for critical information.
            </summary>
            <seealso cref="P:WizardWrx.ReportDetail.DisplayFormat"/>
        </member>
        <member name="P:WizardWrx.ReportDetail.DisplayOrder">
            <summary>
            Get or set the unsigned integer that determines the order in which
            this item is returned from a sorted collection.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.DisplayValue">
            <summary>
            Get or set the string representation of data value, which MAY be a 
            null reference or an empty string.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.Label">
            <summary>
            New value for label, which can be neither null, nor empty.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetail.Value">
            <summary>
            Gets or sets the data value, as an Object, which MAY be a null
            reference.
            
            Please see Remarks for important details.
            </summary>
            <remarks>
            To make the class a tad more robust, if the rhe property is null,
            the DisplayValue is returned, unless it is also null. This gets
            around an ambiguity that causes the constructor to put a String into
            the DisplayValue property, unless it is downcast to Object.
            </remarks>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatDetail">
            <summary>
            Return a formatted detail record, ready to print.
            </summary>
            <returns>
            The return value is a formatted string, if a label and value are
            present. Otherwise, an error message is returned for printing.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatDetail(System.UInt32)">
            <summary>
            Return a formatted detail record, ready to print.
            </summary>
            <param name="puintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            The return value is a string that can be fed directly to a WriteLine
            method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatDetail(System.UInt32,System.UInt32)">
            <summary>
            Return a formatted detail record, ready to print.
            </summary>
            <param name="puintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="puintTotalitems">
            Specify the total number of items in the list, which becomes part of
            the third format item, {2}, in the detail item format string.
            </param>
            <returns>
            The return value is a string that can be fed directly to a WriteLine
            method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatDetail(System.Int32)">
            <summary>
            Return a formatted detail record, ready to print.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            The return value is a string that can be fed directly to a WriteLine
            method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatDetail(System.Int32,System.UInt32)">
            <summary>
            Return a formatted detail record, ready to print.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="puintTotalitems">
            Specify the total number of items in the list, which becomes part of
            the third format item, {2}, in the detail item format string.
            </param>
            <returns>
            The return value is a string that can be fed directly to a WriteLine
            method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.GetPaddedLabel(System.Int32)">
            <summary>
            Return a padded label string.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            If this instance has a label, pad it as indicated, otherwise, behave
            as if FormatDetail got the call.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.GetPaddedLabel(System.UInt32)">
            <summary>
            Return a padded label string.
            </summary>
            <param name="puintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            If this instance has a label, pad it as indicated, otherwise, behave
            as if FormatDetail got the call.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.GetPaddedValue(System.Int32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)">
            <summary>
            Return an aligned field item string.
            </summary>
            <param name="pintWidthOfWidestValue">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestValue property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="penmAlignment">
            Specify Left or Right. Format items, per se, don't support center
            alignment.
            </param>
            <param name="pstrFormatString">
            Specify a Standard Numeric, Date, or Text format string or a custom
            string composed around a standard string.
            </param>
            <returns>
            The returned string is ready to insert into a complete format string
            for use with string.Format, Console.WriteLine, and their numerous
            cousins.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.GetPaddedValue(System.UInt32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)">
            <summary>
            Return an aligned field item string.
            </summary>
            <param name="puintWidthOfWidestValue">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestValue property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="penmAlignment">
            Specify Left or Right. Format items don't support center alignment.
            </param>
            <param name="pstrFormatString">
            Specify a Standard Numeric, Date, or Text format string or a custom
            string composed around a standard string.
            </param>
            <returns>
            The returned string is ready to insert into a complete format string
            for use with string.Format, Console.WriteLine, and their numerous
            cousins.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.TestState(WizardWrx.ReportDetail.State)">
            <summary>
            Determine whether the condition represented by a member of the State
            enumeration is true.
            </summary>
            <param name="penmState">
            The member of the State enumeration to evaluate.
            </param>
            <returns>
            True if State is true, else False.
            </returns>
        </member>
        <member name="P:WizardWrx.ReportDetail.DetailFormat">
            <summary>
            This property gives read/write access to the DetailFormat property,
            a string that is shared by all instances. See remarks for critical
            information.
            </summary>
            <remarks>
            The first two format items, {0} and {1}, are reserved for the label
            and value properties. Additional format items, if any, may be filled
            from the DetailFormatItems array.
            </remarks>
        </member>
        <member name="P:WizardWrx.ReportDetail.DetailFormatItems">
            <summary>
            This property gives read/write access to the DetailFormatItems
            property, an array of Objects that is shared by all instances. See 
            remarks for critical information.
            </summary>
            <remarks>
            The first two format items, {0} and {1}, are reserved for the label
            and value properties. Additional format items, if any, may be filled
            from this array.
            
            The instance message formatter takes items from this array as needed
            to fill the remaining format items.
            </remarks>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatLabelAndValue(System.Int32,System.UInt32)">
            <summary>
            This method encapsulates the code that runs in both FormatDetail
            methods unless the label property is uninitialized.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="puintTotalitems">
            Specify the total number of items in the list, which becomes part of
            the third format item, {2}, in the detail item format string.
            </param>
            <returns>
            The returned string can be passed directly to any WriteLine method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatLabelWithPadding(System.Int32)">
            <summary>
            This routine implements both overloads of GetPaddedLabel.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            If this instance has a label, pad it as indicated, otherwise, behave
            as if FormatDetail got the call.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.FormatValueWithPadding(System.Int32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)">
            <summary>
            This private method implements both overloads of GetPaddedValue.
            </summary>
            <param name="pintWidthOfWidestValue">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestValue property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <param name="penmAlignment">
            Specify Left or Right. Format items, per se, don't support center
            alignment.
            </param>
            <param name="pstrFormatString">
            Specify a Standard Numeric, Date, or Text format string or a custom
            string composed around a standard string.
            </param>
            <returns>
            The returned string is ready to insert into a complete format string
            for use with string.Format, Console.WriteLine, and their numerous
            cousins.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.GatherFormatItemValues(System.String,System.String,System.UInt32)">
            <summary>
            Gather the label, value, item number, and extra items, if any, into
            one array of objects.
            </summary>
            <param name="label">
            Specify the field label, which replaces the first format item, {0}.
            </param>
            <param name="displayvalue">
            Specify the field value, which replaces the second format item, {1}.
            </param>
            <param name="puintTotalitems">
            Specify the total number of items in the list, or zero to suppress
            its inclusion in the report details.
            </param>
            <returns>
            The return value is an array of generic Object variables, ready to
            pass into the static string.Format method, or any of the others that
            have the same signature.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.SelectLabel(System.Int32)">
            <summary>
            If the ReportDetails is initialized (not null), return a padded
            label. Otherwise, return a unpadded label.
            </summary>
            <param name="pintWidthOfWidestLabel">
            Specify the length, in characters, of the longest string 
            representation of all items in a collection. The intent is that the
            details for a report go into a ReportDetails collection, which has a
            WidthOfWidestLabel property that was originally acquired indirectly,
            through a reference to the collection that originally occupied this
            slot in the argument list.
            </param>
            <returns>
            if puintWidthOfWidestLabel is greater than zero, GetPaddedLabel is
            called on this instance, passing the puintWidthOfWidestLabel value
            for its use. Otherwise, the label stored in the instance is returned
            as is.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportDetail.ReportMissingLabel">
            <summary>
            Either return a message, or put it into an System.InvalidOperationException
            exception if the ThrowOnInvalidState property is set to TRUE. 
            
            Please see the associated Remarks topic.
            </summary>
            <returns>
            Unless ThrowOnInvalidState is true, return a message that takes the
            place of the expected message on the report.
            
            Please see the associated Remarks topic.
            </returns>
            <remarks>
            When this happens, look for your error in the routine that created
            the instance that reported the error. 
            
            If  the static ThrowOnInvalidState property is True, your program
            throws an System.InvalidOperationException exception. Otherwise, the same
            message that would have gone into the exception report is recorded
            on the report.
            </remarks>
        </member>
        <member name="T:WizardWrx.ReportDetails">
            <summary>
            This class holds the details for a report. Static object locks are used
            throughout to ensure synchronized access.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT">
            <summary>
            The default increment value is 100. With automatic incrementation,
            this is almost certainly overkill. On the other hand, the
            applications that I anticipate for this class should have plenty of
            headroom in the provided unsigned integer.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetails.Add(WizardWrx.ReportDetail)">
            <summary>
            Override the New method in the base class, because it's lots cheaper
            than using an event.
            </summary>
            <param name="prDtl">
            The ReportDetail item to add to the collection.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetails.#ctor">
            <summary>
            Construct an empty list.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetails.#ctor(System.Collections.Generic.ICollection{WizardWrx.ReportDetail})">
            <summary>
            Construct a list with an initial capacity sufficient to hold the
            whole ICollection, but check them in one by one.
            </summary>
            <param name="pICollection">
            The collection from which to construct the list. Any member that is
            a ReportDetail is added. Others are discarded, so that the finished
            collection is homogeneous.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetails.#ctor(System.Int32)">
            <summary>
            Construct an empty list, with a specified initial capacity.
            </summary>
            <param name="pintCapacity">
            Set the initial capacity of the list to this value.
            </param>
        </member>
        <member name="P:WizardWrx.ReportDetails.GroupDetails">
            <summary>
            Gets or sets the value (contents) of the GroupDetails array of
            generic object variables intended for inclusion in reports.
            </summary>
            <remarks>
            Use this array to store objects intended to appear in multiple lines
            of a report, such as a description of their source, creation date,
            or similar attributes that apply to the collection as a whole.
            </remarks>
        </member>
        <member name="P:WizardWrx.ReportDetails.Increment">
            <summary>
            Unless the object being added has one of its own, the local Add
            method multiplies the count, plus 1, by this increment to set its
            DisplayOrder property.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetails.WidthOfWidestLabel">
            <summary>
            Gets the width, in characters, of the widest label.
            
            If the class is empty, the return value is zero.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned">
            <summary>
            Gets the width, in characters, of the widest label, as an unsigned 
            integer.
            
            If the class is empty, the return value is zero.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetails.WidthOfWidestValue">
            <summary>
            Gets the width, in characters, of the widest value in the
            collection.
            </summary>
        </member>
        <member name="P:WizardWrx.ReportDetails.WidthOfWidestValueUnsigned">
            <summary>
            Gets the width, in characters, of the widest value in the
            collection, as an unsigned integer.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetails.ListAllItems">
            <summary>
            List each item in a new line on the system console.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportDetails.ListAllItems(System.IO.TextWriter)">
            <summary>
            List each item in a new line on the specified TextWriter.
            </summary>
            <param name="pswOut">
            Specify the open TextWriter on which to write the report.
            </param>
        </member>
        <member name="M:WizardWrx.ReportDetails.ListAllItemsInArray">
            <summary>
            Fill an array of strings with report items.
            </summary>
            <returns>
            The return value is an array of strings, one per item in the
            collection. Each string is a report item, ready to send to a text
            file or for further modification, since the lines aren't terminated.
            </returns>
        </member>
        <member name="T:WizardWrx.ReportHelpers">
            <summary>
            This static class exposes methods to help prepare strings for use on
            reports.
            </summary>
        </member>
        <member name="T:WizardWrx.ReportHelpers.Alignment">
            <summary>
            Set the penmAlignment argument of the AdjustToMaximumWidth method to
            a member of this enumeration.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportHelpers.Alignment.Left">
            <summary>
            Align text to left.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportHelpers.Alignment.Right">
            <summary>
            Align text to right.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportHelpers.DOUBLE_SPACE">
            <summary>
            Overlooked constant - two consecutive spaces.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportHelpers.EMBEDDED_TAB">
            <summary>
            Tab characters, as they must be entered into resource (.RESX) strings.
            </summary>
        </member>
        <member name="F:WizardWrx.ReportHelpers.OUTPUT_TAB">
            <summary>
            Tab characters, as they must appear in the string before it can be
            used.
            </summary>
        </member>
        <member name="M:WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String)">
            <summary>
            Given a formatted string for a label row, generate a format string
            for the corresponding detail row.
            </summary>
            <param name="pstrReportLabels">
            Label string for which to generate a detail string.
            </param>
            <returns>
            String, for use with string.Format method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String,System.Char)">
            <summary>
            Given a formatted string for a label row, generate a format string
            for the corresponding detail row.
            </summary>
            <param name="pstrReportLabels">
            Label string for which to generate a detail string.
            </param>
            <param name="pchrFieldSeparator">
            Character to use in lieu of TAB as field separator.
            </param>
            <returns>
            String, for use with string.Format method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportHelpers.MaxStringLength``1(System.Collections.Generic.List{``0})">
            <summary>
            Given an array of objects of any type, return the length of the
            longest string made from them. See Remarks.
            </summary>
            <typeparam name="T">
            This is a generic method; its argument may be of any type. This 
            method needs only its ToString method.
            </typeparam>
            <param name="plstObjs">
            This argument expects an array of objects, which may be of different
            kinds.
            
            Since the generic List class has a constructor that takes an array,
            which it copies into the new list that it returns, you can use this
            method to process arrays by specifying a new List of the appropriate
            type for this argument.
            For additional information, please see the Remarks section.
            </param>
            <example>
            The following example returns the length of the longest string 
            contained in array astrLinesFromFile, an array of strings.
            
            int intLogestLine = WizardWrx.ReportHelpers.MaxStringLength ( new List&lt;string&gt; ( astrLinesFromFile ) );
            
            Note use of the List constructor, which transforms the array into a
            disposable generic List.
            </example>
            <returns>
            The return value is the length of the longest string made from the
            objects in the input array. Since it is intended for use with the
            PadRight method on a string, it is cast to int. See Remarks.
            </returns>
            <remarks>
            The goal of this routine is to determine the maximum number of
            characters required to represent any of a collection of objects such
            as labels or members of an enumerated type. This method has at least
            three use cases.
            
            1) Pad the strings to a uniform length, so that all of a set of
            labeled values aligns vertically.
            
            2) Construct a key from several substrings, such that the substrings
            are of uniform length, and the keys can be grouped by any of the
            leading substrings, and ordered by the values of the last substring.
            
            3) Construct a composite format string that reserves enough room for
            the widest item in the list, so that whatever follows it on a report
            line aligns vertically.
            </remarks>
        </member>
        <member name="M:WizardWrx.ReportHelpers.CreateFormatString(System.String,System.Char)">
            <summary>
            Given a formatted string for a label row, generate a format string
            for the corresponding detail row. See Remarks.
            </summary>
            <param name="pstrReportLabels">
            Label string for which to generate a detail string.
            </param>
            <param name="pchrFieldSeparator">
            Character to use in lieu of TAB as field separator.
            </param>
            <returns>
            String, for use with string.Format method.
            </returns>
        </member>
        <member name="M:WizardWrx.ReportHelpers.CreateLastToken(System.String,System.Char)">
            <summary>
            The last token is appended without a field delimiter. See Remarks.
            </summary>
            <param name="pstrTokenTemplate">
            The token used for the preceding operations is fed into this routine
            to have its delimiter removed. See Remarks.
            </param>
            <param name="pchrFieldSeparator">
            Obviously, this routine needs a copy of the delimiter character, but
            its use is a bit more complex. See Remarks.
            </param>
            <returns>
            Regardless of whether the delimiter is a TAB, which requires special
            handling, or another character, the return value is a bare token.
            See Remarks.
            </returns>
            <remarks>
            Since they are escaped when entered into a .NET resource (.RESX)
            file, such TAB characters must be handled a tad differently, using
            the doubly escaped token that represents a TAB character embedded in
            a resource string as the first argument to the Replace method on the
            input string, pstrTokenTemplate. To cover the case where the string
            is a constant, embedded in the source file, this case must call the
            Replace method on the new string returned by the first Replace call,
            passing a string representation of the regular TAB character, since
            the replacement is the empty string.
            
            In all other cases, the Replace method is called once, using the
            actual delimiter character, pchrFieldSeparator.
            </remarks>
        </member>
        <member name="T:WizardWrx.StringExtensions">
            <summary>
            This is a class of extension methods for performing common tasks not
            provided by the System.String class. All but the four Pad methods are
            derived from long established routines in companion class StringTricks.
            
            Just as importing the System.Linq namespace makes its generic extension
            methods visible, importing the root WizardWrx namespace, accompanied by
            a reference to WizardWrx.Core, makes these methods visible on every
            instance of System.string.
            
            Rather than create ane entirely new class to support one small method, I
            extended this class to cover RenderEvenWhenNull, even though it is a
            generic method.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.DEFAULT_TOKEN_DELM">
            <summary>
            Default token terminator string used by the version of public static
            method, MakeToken, which takes one argument.
            </summary>
        </member>
        <member name="M:WizardWrx.StringExtensions.ApplyFixups(System.String,WizardWrx.Core.StringFixups.StringFixup[])">
            <summary>
            Call this extension method to perform a one-off string
            transformation.
            </summary>
            <param name="pstrIn">
            Input string to transform by applying <paramref name="pafixupPairs"/>
            </param>
            <param name="pafixupPairs">
            Array of StringFixup objects to apply to <paramref name="pstrIn"/>
            </param>
            <returns>
            The <paramref name="pstrIn"/>, transformed by applying each
            <paramref name="pafixupPairs"/> StringFixup to it in turn
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.AppendFullStopIfMissing(System.String)">
            <summary>
            Unless the last character of the input string is a period (full
            stop), append one to the returned string.
            </summary>
            <param name="pstrInput">
            Specify the input string to evaluate and edit as needed.
            </param>
            <returns>
            The input string is returned with a period appended to it. If it already
            has one, the input string is returned unchanged.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ArrayOfOne(System.Char)">
            <summary>
            Return a one-element array containing the input character, for use
            as input to the Split method of the System.string class.
            </summary>
            <param name="pchrTheCharacter">
            Specify the character to be copied into an array of one.
            </param>
            <returns>
            The return value is an array of one element, ready to feed to the
            string.split method, or anything else that needs an array of one
            character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ArrayOfOne(System.String)">
            <summary>
            Return a one-element array containing the input string, for use
            as input to the Split method of the System.string class.
            </summary>
            <param name="pstrTheString">
            Specify the string to be copied into an array of one.
            </param>
            <returns>
            The return value is an array of one element, ready to feed to the
            string.split method, or anything else that needs an array of one
            string.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.CapitalizeWords(System.String)">
            <summary>
            Return the input string with each word capitalized.
            </summary>
            <param name="pstr">
            The string to process is implicitly passed in by this extension method.
            </param>
            <returns>
            The input string is returned with each of its words capitalized. If the
            string is already capitalized, this has no effect. Subsequent letters are
            coerced to lower case.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.Chop(System.String)">
            <summary>
            Return a new string with the terminal newline, if present, removed.
            </summary>
            <param name="pstrIn">
            Specify the string to be chopped.
            </param>
            <returns>
            The chopped string is returned, minus its newline if it contained
            one. This method treats all newlines equally, meaning that any of
            the following items is treated as a newline.
            
            1) Environment.Newline
            2) SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN, a bare carriage return (0x0D)
            3) SpecialStrings.STRING_SPLIT_LINEFEED, a bare line feed (0x0A)
            </returns>
            <see cref="F:WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN"/>
            <see cref="F:WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED"/>
            <see cref="P:System.Environment.NewLine"/>
        </member>
        <member name="M:WizardWrx.StringExtensions.CountCharacterOccurrences(System.String,System.Char)">
             <summary>
             Strangely, the String class is missing an important static method to
             count occurrences of a specified character within a string. This is
             that missing method.
             </summary>
             <param name="pstrSource">
             Specify the string in which to count occurrences of substring 
             pstrToCount.
            
             If pstrSource is null or empty, the method returns zero.
             
             Since this is an extension method, pstrIn is supplied by the BCL
             when it binds this method to an instance of System.string.
             </param>
             <param name="pchrToCount">
             Specify the substring to count in string pstrSource. An empty string
             causes the method to return MagicNumbers.STRING_INDEXOF_NOT_FOUND,
             or -1.
             </param>
             <returns>
             The return value is the number of times, if any, that string
             pstrToCount occurs in string pstrSource, or
             MagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either
             null reference or empty the empty string.
             </returns>
             <remarks>
             This method implements the only overload of the string.IndexOf
             method that takes a character as its second argument for which I
             have yet to make use. There is currently no implementation of the
             overload that stops looking after scanning count characters, nor do
             I have immediate plans to implement one, though it wouldn't be hard.
             
             This method uses the same algorithm as CountSubstrings, except that
             its second argument is a single character, which CANNOT be the NULL
             character.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.CountSubstrings(System.String,System.String)">
             <summary>
             Strangely, the String class is missing an important static method to
             count substrings within a string. This is that missing method.
             </summary>
             <param name="pstrSource">
             Specify the string in which to count occurrences of substring 
             pstrToCount.
            
             If pstrSource is null or empty, the method returns zero.
             
             Since this is an extension method, pstrIn is supplied by the BCL
             when it binds this method to an instance of System.string.
             </param>
             <param name="pstrToCount">
             Specify the substring to count in string pstrSource. An empty string
             causes the method to return MagicNumbers.STRING_INDEXOF_NOT_FOUND,
             or -1.
             </param>
             <returns>
             The return value is the number of times, if any, that string
             pstrToCount occurs in string pstrSource, or
             MagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either
             null reference or empty the empty string.
             </returns>
             <remarks>
             This method implements the only overloads of the string.IndexOf
             method that takes a string as its second argument for which I
             have yet to make use. There is currently no implementation of the
             overloads that stops looking after scanning count characters, nor do
             I have immediate plans to implement one, though it wouldn't be hard.
             
             This method is implemented by calling the second overload, which has
             an additional argument through which to specify a string comparison
             algorithm, since the algorithms required to implement both are
             otherwise identical.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.CountSubstrings(System.String,System.String,System.StringComparison)">
             <summary>
             Strangely, the String class is missing an important static method to
             count substrings within a string. This is that missing method.
             </summary>
             <param name="pstrSource">
             Specify the string in which to count occurrences of substring
             pstrToCount.
            
             If pstrSource is null or empty, the method returns zero.
             
             Since this is an extension method, pstrIn is supplied by the BCL
             when it binds this method to an instance of System.string.
             </param>
             <param name="pstrToCount">
             Specify the substring to count in string pstrSource.
             
             The empty string causes the method to return 
             MagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.
             </param>
             <param name="penmComparisonType">
             Specify a member of the System.StringComparison enumeration, which
             defines the rules for performing the comparison.
             </param>
             <returns>
             The return value is the number of times, if any, that string
             pstrToCount occurs in string pstrSource, zero if pstrSource is a
             null reference or the empty string, or 
             MagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either
             a null reference or the empty string.
             </returns>
             <remarks>
             This method implements the only overloads of the string.IndexOf
             method that takes a string as its second argument for which I
             have yet to make use. There is currently no implementation of the
             overloads that stops looking after scanning count characters, nor do
             I have immediate plans to implement one, though it wouldn't be hard.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String)">
             <summary>
             Return an array of integers, each a position of substring
             <paramref name="pstrToCount"/> in string <paramref name="pstrSource"/>.
             </summary>
             <param name="pstrSource">
             Specify the string in which to count occurrences of substring
             pstrToCount.
            
             If pstrSource is null or empty, the method returns zero.
             
             Since this is an extension method, pstrIn is supplied by the BCL
             when it binds this method to an instance of System.string.
             </param>
             <param name="pstrToCount">
             Specify the substring to count in string pstrSource.
             
             The empty string causes the method to return 
             MagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.
             </param>
             <returns>
             When the method succeeds, its return value is an array of integers,
             each of which is the position of an occurrence of <paramref name="pstrToCount"/>
             in <paramref name="pstrToCount"/>, following the search algorithm
             dictated by StringComparison.CurrentCulture. When either of the two
             string parameters is a null reference or the empty string, the
             return value is NULL, for which callers must test. Since either
             string could be empty or a null reference, in normal operations, it
             seemed appropriate to treat such a case as routine, rather than
             throwing an exception. Conversely, when both strings are valid, but
             <paramref name="pstrToCount"/> never occurs in <paramref name="pstrSource"/>,
             the return value is an empty array.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String,System.StringComparison)">
             <summary>
             Return an array of integers, each a position of substring
             <paramref name="pstrToCount"/> in string <paramref name="pstrSource"/>.
             </summary>
             <param name="pstrSource">
             Specify the string in which to count occurrences of substring
             pstrToCount.
            
             If pstrSource is null or empty, the method returns zero.
             
             Since this is an extension method, pstrIn is supplied by the BCL
             when it binds this method to an instance of System.string.
             </param>
             <param name="pstrToCount">
             Specify the substring to count in string pstrSource.
             
             The empty string causes the method to return 
             MagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.
             </param>
             <param name="penmComparisonType">
             Specify a member of the System.StringComparison enumeration, which
             defines the rules for performing the comparison.
             </param>
             <returns>
             When the method succeeds, its return value is an array of integers,
             each of which is the position of an occurrence of <paramref name="pstrToCount"/>
             in <paramref name="pstrToCount"/>, following the search algorithm
             dictated by <paramref name="penmComparisonType"/>. When either of
             the two string parameters is a null reference or the empty string,
             the return value is NULL, for which callers must test. Since either
             string could be empty or a null reference, in normal operations, it
             seemed appropriate to treat such a case as routine, rather than
             throwing an exception. Conversely, when both strings are valid, but
             <paramref name="pstrToCount"/> never occurs in <paramref name="pstrSource"/>,
             the return value is an empty array.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)">
            <summary>
            Scan a string for environment string delimiter characters left
            behind by an environment string expansion.
            </summary>
            <param name="pstrInput">
            Specify a string that has had its environment strings expanded.
            </param>
            <returns>
            The return value is the count of remaining environment string
            delimiters. Please see the remarks for additional information.
            </returns>
            <remarks>
            There are two reasons that such delimiters might be left behind.
            
            1) The input string contains environment strings that have no like
            named strings in the environment block that belongs to the process.
            
            2) The input string contains a malformed string that is missing one
            of its delimiting tokens.
            
            This routine wraps CountSubstrings, supplying the required token,
            which is defined as public character constant in SpecialCharacters,
            a sibling class. Since you could as well call that routine directly,
            this routine is syntactic sugar.
            </remarks>
            <seealso cref="M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:WizardWrx.StringExtensions.EncloseInChar(System.String,System.Char)">
            <summary>
            Append a specified character to both ends of a string, unless it is
            already present.
            </summary>
            <param name="pstrIn">
            Specify the string to evaluate, which may, or may not, end with the
            character specified in pchrEnd.
            
            Since this is an extension method, pstrIn is supplied by the BCL
            when it binds this method to an instance of System.string.
            </param>
            <param name="pchrEnd">
            Specify the character to append, if absent.
            </param>
            <returns>
            The return value is a new string that is guaranteed to have exactly
            one of the character specified in pchrEnd at each end.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.EnsureFirstCharIs(System.String,System.Char)">
            <summary>
            Return a string that is guaranteed to start with a specified character.
            </summary>
            <param name="pstrInput"></param>
            Evaluate this string, and return it as is if it already starts with
            the specified character. Otherwise, return the specified character,
            followed by the input string.
            <param name="pchrMustBeFirst">
            Ensure that the first character in the string is this one.
            </param>
            <returns>
            The returned string is guaranteed to start with the specified character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.EnsureLastCharIs(System.String,System.Char)">
            <summary>
            Return a string that is guaranteed to end with a specified character.
            </summary>
            <param name="pstrInput"></param>
            Evaluate this string, and return it as is if it already ends with
            the specified character. Otherwise, return a copy with the specified
            character appended.
            <param name="pchrMustBeLast">
            Ensure that the last character in the string is this one.
            </param>
            <returns>
            The returned string is guaranteed to end with the specified character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.EnumFromString``1(System.String)">
            <summary>
            Convert a string to the equivalent instance of a specified
            enumeration type.
            </summary>
            <typeparam name="T">
            The specified type must be a valid Enum type. The method infers the
            type from the value specified in angle brackets following the method
            name in the invocation.
            </typeparam>
            <param name="pstrEnumAsString">
            Specify the string to convert.
            </param>
            <returns>
            If the function succeeds, the return value is a member of the
            specified enumeration.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            An InvalidOperationException exception arises when the input string
            cannot be converted. The message specifies the expected type and the
            failing input value, along with the Message property on the original
            FormatException excetpion, which is preserved as the InnerException
            property on the thrown InvalidOperationException.
            </exception>
            <remarks>
            This method requires version 7.3 or later of the C# compiler, for
            which the project configuration contains a setting.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.Int32,System.Int32)">
            <summary>
            Extract the substring bounded by the characters at either end of it.
            </summary>
            <param name="pstrWholeString">
            Specify the string from which to extract the substring.
            
            Since this is an extension method, the CLR supplies this argument
            when it binds the method to an instance of the System.string class.
            </param>
            <param name="pintPosBegin">
            Specify the position, as it would be reported by IndexOf, of the 
            character that bounds the left end of the desired substring.
            </param>
            <param name="pintPosEnd">
            Specify the position, as it would be reported by IndexOf, of the 
            character that bounds the right end of the desired substring.
            </param>
            <returns>
            The returned substring begins with the character immediately to the
            right of the left hand bounding character, and ending with the last
            character before the right hand bounding character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.String,System.Int32,System.Int32)">
             <summary>
             Extract the substring bounded by the characters at either end of it.
             </summary>
             <param name="pstrWholeString">
             Specify the string from which to extract the substring.
             
             Since this is an extension method, the CLR supplies this argument
             when it binds the method to an instance of the System.string class.
             </param>
             <param name="pstrLeftMarker">
             This overload handles the case where the left boundary is bounded by
             a string. The method needs a copy of the string in order to find the
             true beginning of the substring to extract, and to compute its
             length.
             </param>
             <param name="pintPosBegin">
             This integer is the position, given by IndexOf, of the character
             that bounds the left end of the desired substring.
             </param>
             <param name="pintPosEnd">
             This integer is the position, given by IndexOf, of the character
             that bounds the right end of the desired substring.
             </param>
             <returns>
             The returned substring begins with the character immediately to the
             right of the left hand bounding character, and ending with the last
             character before the right hand bounding character.
            
             Inputs and computed values are thoroughly sanity checked to prevent
             run-time exceptions. If anything is out of order, an empty string is
             returned.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char)">
             <summary>
             Extract a substring that is bounded by a character. See Remarks.
             </summary>
             <param name="pstrWholeString">
             The substring is extracted from this string.
             </param>
             <param name="pchrBoundingCharacter">
             Specify the bounding character. Please see Remarks.
             </param>
             <returns>
             The return value is the desired substring, without its bounding 
             characters. See Remarks.
             </returns>
             <remarks>
             The left and right ends must be bounded by the same character. To
             extract a string bounded on each end by a different character, use
             the next overload.
            
             Inputs and computed values are thoroughly sanity checked to prevent
             run-time exceptions. If anything is out of order, an empty string is
             returned.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char,System.Char)">
             <summary>
             Extract a substring that is bounded by a character. See Remarks.
             </summary>
             <param name="pstrWholeString">
             The substring is extracted from this string.
             </param>
             <param name="pchrLeftBound">
             Specify the character that marks the left end of the string. See
             Remarks.
             </param>
             <param name="pchrRightBound">
             Specify the character that marks the right end of the string. See
             Remarks.
             </param>
             <returns>
             The returned substring begins with the character immediately to the
             right of the left hand bounding substring, and ending with the last
             character before the right hand bounding substring.
             </returns>
             <remarks>
             The left and right ends are expected to be bounded by different
             characters. To  extract a string bounded on each end by the same
             character, use the previous overload.
            
             Inputs and computed values are thoroughly sanity checked to prevent
             run-time exceptions. If anything is out of order, the empty string
             is returned.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.String,System.String)">
             <summary>
             Extract a substring that is bounded by a pair of substrings. See
             Remarks.
             </summary>
             <param name="pstrWholeString">
             Specify the string from which to extract the bounded substring.
             </param>
             <param name="pstrLeftBound">
             Specify the substring that marks the left end of the string. See
             Remarks.
             </param>
             <param name="pstrRightBound">
             Specify the substring that marks the right end of the string. See
             Remarks.
             </param>
             <returns>
             The returned substring begins with the character immediately to the
             right of the left hand bounding substring, and ending with the last
             character before the right hand bounding substring.
             </returns>
             <remarks>
             The left and right ends are expected to be bounded by different
             substrings. To  extract a string bounded on each end by the same
             substring, use the same value for the second and third arguments.
            
             Inputs and computed values are thoroughly sanity checked to prevent
             run-time exceptions. If anything is out of order, an empty string is
             returned.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32)">
            <summary>
            Left pad the string with a specified number of spaces.
            </summary>
            <param name="pstrPadThisString">
            This argument is supplied by the framework when it binds the method
            to an instance of the System.String class.
            </param>
            <param name="paddingCharacterCount">
            Specify the number of space characters to add on the left end of the
            string. Please see the Remarks for important details.
            </param>
            <returns>
            The input string is padded on the left with the specified number of
            space characters.
            
            Please see the Remarks for important details.
            </returns>
            <remarks>
            These methods compensate for the completely logical, if unexpected,
            behavior of the native PadLeft and PadRight methods on the
            System.string class. Their objective is to guarantee that the new
            string is truly padded with a specific number of characters.
            
            The names of the visible arguments differ from my usual Hungarian
            naming convention so that they conform to the naming convention of
            the Base Class Library methods that they wrap.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32,System.Char)">
            <summary>
            Left pad the string with a specified number of some arbitrary
            character.
            </summary>
            <param name="pstrPadThisString">
            This argument is supplied by the framework when it binds the method
            to an instance of the System.String class.
            </param>
            <param name="paddingCharacterCount">
            Specify the number of arbitrary characters to add on the left end of
            the string. Please see the Remarks for important details.
            </param>
            <param name="paddingChar">
            Specify the arbitrary character with which the string is to be padded.
            </param>
            <returns>
            The input string is padded on the left with the specified number of
            the specified arbitrary character.
            
            Please see the Remarks for important details.
            </returns>
            <remarks>
            These methods compensate for the completely logical, if unexpected,
            behavior of the native PadLeft and PadRight methods on the
            System.string class. Their objective is to guarantee that the new
            string is truly padded with a specific number of characters.
            
            The names of the visible arguments differ from my usual Hungarian
            naming convention so that they conform to the naming convention of
            the Base Class Library methods that they wrap.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.MakeToken(System.String)">
             <summary>
             Given a string containing the name of a form control (field) or
             other token, create its place holder token.
             </summary>
             <param name="pstrFieldName">
             String containing the name of the token.
             </param>
             <returns>
             String containing the text of the corresponding template text place
             holder. See Remarks.
             </returns>
             <remarks>
             The string is constructed by appending a standard token delimiter,
             which is a pair of dollar signs, to each end of the string.
            
             The token is exposed as a static property, DEFAULT_TOKEN_DELM.
             </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.MakeToken(System.String,System.String)">
            <summary>
            Given a string containing the name of a form control (field) or
            other token, and another string containing a static token, create
            its place holder token.
            </summary>
            <param name="pstrFieldName">
            Specify the string containing the name of the token.
            </param>
            <param name="pstrTokenEnds">
            Specify the string to attach to both ends of the string specified by
            pstrFieldName to generate the token.
            </param>
            <returns>
            The string is constructed by appending the token delimiter specified
            in argument pstrTokenEnds to both ends of the string specified in
            argument pstrFieldName.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.OldMacLineEndings(System.String)">
            <summary>
            Replace a string that may contain mixed or unwanted line endings
            with a string that contains only the expected line ending type.
            </summary>
            <param name="pstrSource">
            String in which to replace line endings
            </param>
            <returns>
            A copy of <paramref name="pstrSource"/>, with non-coformant line
            endings replaced. A line ending is treated as non-conformant when it
            is an otherwise valid line ending, but isn't a bare CR character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ParseCommentInHTMLComment(System.String)">
             <summary>
             Extract parameters, expressed as key-value pairs, from a standard
             HTML comment.
             </summary>
             <param name="pstrInput">
             String containing a well formed HTML comment, surrounding the
             key-value pairs. If the string is not a well formed HTML comment,
             with a single space between the comment delimiters and the body,
             or the string is null or empty, the returned collection is empty.
             </param>
             <returns>
             A NameValueCollection of parameter names and values, which may be
             empty, but is guaranteed to be returned, empty or not.
             </returns>
             <example>
             <code>
             Parse this: &lt;!-- ForPage=default;UseTable=False --&gt;
             
             Return this:
            
            			=======================
            			Name		Value
            			-----------	-----------
            			ForPage		default
            			UseTable	False
            			=======================
             </code>
             <para>The returned NameValueCollection contains two members.</para>
             <para>Since this method guarantees to return an initialized
             NameValueCollection, the empty collection is allocated by the first
             statement, and is unconditionally returned by the last statement.</para>
             </example>
        </member>
        <member name="M:WizardWrx.StringExtensions.QuoteString(System.String)">
            <summary>
            Append a quote character to both ends of a string, unless it is
            already present.
            </summary>
            <param name="pstrIn">
            String to evaluate, which may, or may not, end with the characterr
            specified in pchrEnd.
            </param>
            <returns>
            String with quote character at both ends.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.RemoveEndChars(System.String,System.Char)">
            <summary>
            Remove ending character, such as brackets, from a string, if present.
            </summary>
            <param name="pstrIn">
            String to evaluate, which may, or may not, end with the characterr
            specified in pchrEnd.
            </param>
            <param name="pchrEnd">
            Character to remove, if present.
            </param>
            <returns>
            String with character pchrEnd removed from both ends.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.RemoveEndQuotes(System.String)">
            <summary>
            Remove ending quotation marks from a string, if present.
            </summary>
            <param name="pstrIn">
            Specify the string to evaluate, which may, or may not, end with
            quotes.
            </param>
            <returns>
            The return value is a new string with ending quotes, if present,
            removed. Otherwise, a copy of the original string is returned.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)">
            <summary>
            For any object of generic type T, return result from calling the
            ToString method on it, unless the instance is a null reference of
            type T. In that case, return either the supplied string or the
            localizable default defined in the string resources expsed by the
            WizardWrx.Common library.
            </summary>
            <typeparam name="T">
            The specified type T must implement IFormattable.
            </typeparam>
            <param name="pgenericObject">
            Pass in a reference to an object of the specified generic type, or a
            null reference to that type.
            </param>
            <param name="pstrValueIfNull">
            Use this optional string parameter to override the default value,
            Common.Properties.Resources.MSG_OBJECT_REFERENCE_IS_NULL. Pass a
            null referencr or omit the parameter to use the default string.
            </param>
            <param name="pstrFormatString">
            Use this optional string parameter to override the default format of
            the value returned by the instance ToString method.
            
            Please see the Remarks.
            </param>
            <param name="pformatProvider">
            Use this optional parameter to override the default format provider
            used by the instance ToString method.
            
            Please see the Remarks.
            </param>
            <returns>
            If <paramref name="pgenericObject"/> is a null reference, return
            Common.Properties.Resources.MSG_OBJECT_REFERENCE_IS_NULL if
            <paramref name="pstrValueIfNull"/> is also a null reference.
            
            If <paramref name="pgenericObject"/> is a null reference and 
            <paramref name="pstrValueIfNull"/> is not, return
            <paramref name="pstrValueIfNull"/>.
            
            Finally, if <paramref name="pgenericObject"/> is not null, call its
            ToString method.
            
            Please see the Remarks.
            </returns>
            <remarks>
            Because this method is generic, it can call the ToString override on
            any object that explicitly implements the IFormattable interface, so
            you derive the benefits of any such override.
            
            The optional <paramref name="pstrFormatString"/> and 
            <paramref name="pformatProvider"/> arguments work in
            tandem with the override on the instance ToString method. To use it
            and the default null reference representation, pass a null reference
            as the value of <paramref name="pstrValueIfNull"/>.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX(System.String)">
            <summary>
            
            </summary>
            <param name="pstrStringFromResX"></param>
            <returns></returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Given a string containing tokens of the form "^^ListKeyValue^^"
            where ListKeyValue is the value of a key in the pnvcList collection,
            which may or may not exist in the collection, replace all such
            tokens with the contents of the like named value in the collection.
            </summary>
            <param name="pstrMsg">
            String containing the message containing the substitution tokens.
            </param>
            <param name="pnvcList">
            A NameValueCollection, in which each key represents a token, and its
            value represents the value to be substituted for it.
            </param>
            <returns>
            String with tokens replaced, and tokens that have no corresponding
            object in the pnvcList collection preserved.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
             <summary>
             Replace place holders (markers) with the value of the corresponding
             form control (field), or a default value, if the field is empty and
             a default is designated.
             </summary>
             <param name="pstrTemplate">
             String containing a template containing the text and place markers.
             </param>
             <param name="pnvcFields">
             NameValueCollection containing the form control (field) values.
             </param>
             <param name="pnvcDefaults">
             NameValueCollection containing the form control (field) or token
             default values.
            
             Default values are optional. If omitted, the method substitutes an
             empty string.
             </param>
             <returns>
             String containing the text in the template, with all tokens
             formatted with default endings replaced by the contents of the
             corresponding, and like named, control (field) on the input form.
            
             Tokens bounded by "##" are replaced by strings from the Session
             variables collection. The same defaults collection is used for both.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
             <summary>
             Given a string containing tokens of the form "^^ListKeyValue^^"
             where ListKeyValue is the value of a key in the pnvcList collection,
             which may or may not exist in the collection, replace all such
             tokens with the contents of the like named value in the collection.
             </summary>
             <param name="pstrMsg">
             String containing the message containing the substitution tokens.
             </param>
             <param name="pdctList">
             A Dictionary, in which each key represents a token, and its value
             represents the value to be substituted for it.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <returns>
             String with tokens replaced, and tokens that have no corresponding
             object in the pnvcList collection preserved.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})">
             <summary>
             Given a string containing tokens of the form "^^ListKeyValue^^"
             where ListKeyValue is the value of a key in the pnvcList collection,
             which may or may not exist in the collection, replace all such
             tokens with the contents of the like named value in the collection.
             </summary>
             <param name="pstrMsg">
             String containing the message containing the substitution tokens.
             </param>
             <param name="pdctList">
             A Dictionary, in which each key represents a token, and its value
             represents the value to be substituted for it.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <param name="pdctDefaults">
             A Dictionary, in which each key represents a token, and its value
             represents the default value to be substituted for it, if there is
             no corresponding key in dictionary pdctList.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <returns>
             String with tokens replaced, and tokens that have no corresponding
             object in the pnvcList OR the pdctDefaults collection preserved.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
             <summary>
             Given a string containing tokens of the form "^^ListKeyValue^^"
             where ListKeyValue is the value of a key in the pnvcList collection,
             which may or may not exist in the collection, replace all such
             tokens with the contents o object.
             </summary>
             <param name="pstrMsg">
             String containing the message containing the substitution tokens.
             </param>
             <param name="pdctList">
             A Dictionary, in which each key represents a token, and its value
             represents the value to be substituted for it.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <param name="pstrFormat">
             Format string, acceptable to the static String.Format method, which
             is used to format the string representation of each object.
            
             The string must contain a "[0}" placeholder, which may occur one or
             more times in the format string, which is replaced by the string
             returned by the ToString method of each object.
             </param>
             <returns>
             String with tokens replaced, and tokens that have no corresponding
             object in the pnvcList collection preserved.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
             <summary>
             Given a string containing tokens of the form "^^ListKeyValue^^"
             where ListKeyValue is the value of a key in the pnvcList collection,
             which may or may not exist in the collection, replace all such
             tokens with the contents of the like named session object.
             </summary>
             <param name="pstrMsg">
             String containing the message containing the substitution tokens.
             </param>
             <param name="pdctList">
             A Dictionary, in which each key represents a token, and its value
             represents the value to be substituted for it.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <param name="pdctDefaults">
             A Dictionary, in which each key represents a token, and its value
             represents the default value to be substituted for it, if there is
             no corresponding key in dictionary pdctList.
            
             The Dictionary may contain anything, as it accepts any Object. The
             required substitution string is obtained by calling the default
             ToString method on each Object. To supply a format string, which
             will be applied to each Object, in turn, use the next overload.
             </param>
             <param name="pstrFormat">
             Format string, acceptable to the static String.Format method, which
             is used to format the string representation of each object.
            
             The string must contain a "[0}" placeholder, which may occur one or
             more times in the format string, which is replaced by the string
             returned by the ToString method of each object.
             </param>
             <returns>
             String with tokens replaced, and tokens that have no corresponding
             object in the pnvcList OR the pdctDefaults collection preserved.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)">
            <summary>
            Display a string that contains unmatched environment strings or
            unmatched environment string delimiters, followed by details about
            the locations of the errors.
            </summary>
            <param name="pstrInput">
            Specify a string that has had its environment strings expanded.
            </param>
            <param name="puintNEnvStrDlms">
            Specify the count of unmatched delimiters. A companion routine,
            UnresolvedEnvironmentStrings, can deliver the count, although the
            call cannot be nested. Please see the remarks.
            </param>
            <param name="puintExitCode">
            This routine is intended to report the error and exit the calling
            console application, returning the specified value as its exit code.
            </param>
            <returns>
            The exit code is passed through, so that the control need not return
            to the caller, but may exit directly or indirectly through 
            Environment.Exit.
            </returns>
            <remarks>
            After the count is written onto the standard error stream, control
            returns to its caller, which may take subsequent actions based upon
            the return value.
            
            Most of the 
            </remarks>
            <see cref="M:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)"/>
        </member>
        <member name="M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32)">
            <summary>
            Display a string that contains unmatched environment strings or
            unmatched environment string delimiters, followed by details about
            the locations of the errors.
            </summary>
            <param name="pstrInput">
            Specify a string that has had its environment strings expanded.
            </param>
            <param name="puintNEnvStrDlms">
            Specify the count of unmatched delimiters. A companion routine,
            UnresolvedEnvironmentStrings, can deliver the count, although the
            call cannot be nested. Please see the remarks.
            </param>
            <returns>
            The return value is a detailed message that shows each unresolved
            string.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32)">
            <summary>
            Right pad the string with a specified number of spaces.
            </summary>
            <param name="pstrPadThisString">
            This argument is supplied by the framework when it binds the method
            to an instance of the System.String class.
            </param>
            <param name="paddingCharacterCount">
            Specify the number of space characters to add on the right end of
            the string.
            
            Please see the Remarks for important details.
            </param>
            <returns>
            The input string is padded on the right with the specified number of
            space characters.
            
            Please see the Remarks for important details.
            </returns>
            <remarks>
            These methods compensate for the completely logical, if unexpected,
            behavior of the native PadLeft and PadRight methods on the
            System.string class. Their objective is to guarantee that the new
            string is truly padded with a specific number of characters.
            
            The names of the visible arguments differ from my usual Hungarian
            naming convention so that they conform to the naming convention of
            the Base Class Library methods that they wrap.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32,System.Char)">
            <summary>
            Left pad the string with a specified number of some arbitrary
            character.
            </summary>
            <param name="pstrPadThisString">
            This argument is supplied by the framework when it binds the method
            to an instance of the System.String class.
            </param>
            <param name="paddingCharacterCount">
            Specify the number of arbitrary characters to add on the right end 
            of the string. Please see the Remarks for important details.
            </param>
            <param name="paddingChar">
            Specify the arbitrary character with which the string is to be padded.
            </param>
            <returns>
            The input string is padded on the right with the specified number of
            the specified arbitrary character.
            
            Please see the Remarks for important details.
            </returns>
            <remarks>
            These methods compensate for the completely logical, if unexpected,
            behavior of the native PadLeft and PadRight methods on the
            System.string class. Their objective is to guarantee that the new
            string is truly padded with a specific number of characters.
            
            The names of the visible arguments differ from my usual Hungarian
            naming convention so that they conform to the naming convention of
            the Base Class Library methods that they wrap.
            </remarks>
        </member>
        <member name="M:WizardWrx.StringExtensions.Truncate(System.String,System.Int32)">
             <summary>
             Supply the missing Truncate function to members of the String class.
             </summary>
             <param name="pstrSource">
             String to truncate, if it is longer than pintMaxLength.
            
             A null string is treated as an empty string, and the return value
             for either is an empty string.
             </param>
             <param name="pintMaxLength">
             Desired maximum length of the returned string. If pstrSource is
             longer than pintMaxLength characters, the first pintMaxLength are
             returned. Otherwise, the whole string is returned.
            
             If pintMaxLength is less than or equal to zero, an empty string is
             returned.
             </param>
             <returns>
             If the string length is less than or equal to the specified maximum
             length, the whole string is returned.
            
             Otherwise, the first pintMaxLength characters are returned.
            
             Regardless, the return value is a new System.String object.
             </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.UnixLineEndings(System.String)">
            <summary>
            Replace a string that may contain mixed or unwanted line endings
            with a string that contains only the expected line ending type.
            </summary>
            <param name="pstrSource">
            String in which to replace line endings
            </param>
            <returns>
            A copy of <paramref name="pstrSource"/>, with non-coformant line
            endings replaced. A line ending is treated as non-conformant when it
            is an otherwise valid line ending, but isn't a bare LF character.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.WindowsLineEndings(System.String)">
            <summary>
            Replace a string that may contain mixed or unwanted line endings
            with a string that contains only the expected line ending type.
            </summary>
            <param name="pstrSource">
            String in which to replace line endings
            </param>
            <returns>
            A copy of <paramref name="pstrSource"/>, with non-coformant line
            endings replaced. A line ending is treated as non-conformant when it
            is an otherwise valid line ending, but doesn't belong to a CR/LF
            character pair.
            </returns>
        </member>
        <member name="F:WizardWrx.StringExtensions.CHAR_SPLIT_OLD_MACINTOSH">
            <summary>
            When private method LineEndingFixup calls SetDesiredLineEnding (also
            private), the latter returns a single-character string that contains
            one of these characters, which becomes the new line ending in the
            string that LineEndingFixup eventually returns when old Macintosh
            line endings are requested.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.CHAR_SPLIT_UNIX">
            <summary>
            When private method LineEndingFixup calls SetDesiredLineEnding (also
            private), the latter returns a single-character string that contains
            one of these characters, which becomes the new line ending in the
            string that LineEndingFixup eventually returns when Unix line
            endings are requested.
            </summary>
        </member>
        <member name="T:WizardWrx.StringExtensions.RequiredLineEndings">
            <summary>
            This enumeration is used internally to specify the line ending type
            that private method LineEndingFixup should return when called by
            UnixLineEndings, WindowsLineEndings, or OldMacLineEndings. The 
            fourth line break combination, LFCR, is unsupported as a return
            type.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.RequiredLineEndings.OldMacintosh">
            <summary>
            Identified line breaks are guaranteed to be bare CR characters.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.RequiredLineEndings.Unix">
            <summary>
            Identified line breaks are guaranteed to be bare LF characters.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.RequiredLineEndings.Windows">
            <summary>
            Identified line breaks are guaranteed to be CR/LF character pairs.
            </summary>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixup(System.String,WizardWrx.StringExtensions.RequiredLineEndings)">
            <summary>
            Methods OldMacLineEndings, UnixLineEndings, and WindowsLineEndings
            call this routine to do their work.
            </summary>
            <param name="pstrSource">
            String in which to replace line endings
            </param>
            <param name="penmRequiredLineEndings">
            Use the RequiredLineEndings enumeration to specify the desired type
            of line endings.
            </param>
            <returns>
            A copy of <paramref name="pstrSource"/>, with non-coformant line
            endings replaced. A line ending is treated as non-conformant when it
            differs from the type indicated by <paramref name="penmRequiredLineEndings"/>.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.PaddedStringLength(System.String,System.Int32)">
            <summary>
            All four LeftPadNChars and RightPadNChars extension methods use the
            same algorithm to compute the overall length of the new string,
            which is fed to the analogous PadLeft or PadRight method, which
            expects the overall string length.
            </summary>
            <param name="pstrPadThisString">
            Since these methods are used internally, a reference to the string
            must be explicitly passed into it.
            </param>
            <param name="paddingCharacterCount">
            The character count is passed through from the extension method 
            argument list.
            </param>
            <returns>
            The returned integer is the overall length that must be passed along
            to the native PadLeft or PadRight method to guarantee that the
            desired number of padding characters are appended to the new string;
            </returns>
            <remarks>
            This method is syntactic sugar that documents the algorithm by which
            the overall length of the new string must be computed, in order to
            coerce the underlying Pad methods to deliver the desired effect. Any
            decent optimizing compiler should render this inline, in registers.
            </remarks>
        </member>
        <member name="T:WizardWrx.StringExtensions.LineEndingFixupState">
            <summary>
            On behalf of public static methods OldMacLineEndings, 
            UnixLineEndings, and WindowsLineEndings, private static method
            LineEndingFixup uses an instance of this class to manage the
            resources required to perform its work. Public method UpdateState
            does most of the work required by LineEndingFixup.
            </summary>
        </member>
        <member name="T:WizardWrx.StringExtensions.LineEndingFixupState.CharacterType">
            <summary>
            This enumeration is used internally to indicate the state of the
            LineEndingFixup state machine.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState.CharacterType.Indeterminate">
            <summary>
            The initial state of the machine is that the last character seen
            is unknown.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState.CharacterType.Other">
            <summary>
            The last character seen isn't a newline character.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState.CharacterType.OldMacintosh">
            <summary>
            The last character seen was a bare CR character, which is either
            the old Macintosh line break character, or belongs to a
            two-character line break.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState.CharacterType.Unix">
            <summary>
            The last character seen was a bare LF character, which is either
            a Unix line break character, or belongs to a two-character line
            break.
            </summary>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.#ctor">
            <summary>
            The constructor is kept private to guarantee that all instances
            are fully initialized.
            </summary>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.#ctor(WizardWrx.StringExtensions.RequiredLineEndings,System.String)">
            <summary>
            The only public constructor initializes an instance for use by
            LineEndingFixup.
            </summary>
            <param name="penmRequiredLineEndings">
            LineEndingFixup uses a member of the RequiredLineEndings
            enumeration to specify the type of line endings to be included
            in the new string that it generates from input string
            <paramref name="pstrInput"/>.
            </param>
            <param name="pstrInput">
            Existing line endings in this string are replaced as needed by
            the type of line endings specified by <paramref name="penmRequiredLineEndings"/>.
            </param>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.GetTransformedString">
            <summary>
            Since the StringBuilder is a reference type, exposing it makes
            it vulnerable to attack. Therefore, it is kept private, and this
            instance method must be explicitly called to get its value as an
            immutable entity, a new string.
            </summary>
            <returns>
            The contents of the StringBuilder in which the transformed
            string is assembled are returned as a new string.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.UpdateState(System.Int32)">
            <summary>
            LineEndingFixup calls this method once for each character in the
            string that was fed into the instance constructor, and once more
            to handle the final character. The algorithm that it implements
            completes all conversions in one pass.
            </summary>
            <param name="pintCurrCharPos">
            The index of the FOR loop within which this routine is called
            identifies the zero-based position within the internal array of
            characters that is constructed from the input string to process.
            </param>
        </member>
        <member name="P:WizardWrx.StringExtensions.LineEndingFixupState.DesiredLineEnding">
            <summary>
            Strictly speaking this string could be left private. Making it
            public as a read-only member is a debugging aid that preserves
            the integrity of the instance.
            </summary>
        </member>
        <member name="P:WizardWrx.StringExtensions.LineEndingFixupState.InputCharacterCount">
            <summary>
            The FOR loop at the heart of LineEndingFixup initializes its
            limit value from this read-only property.
            </summary>
        </member>
        <member name="P:WizardWrx.StringExtensions.LineEndingFixupState.LastCharacter">
            <summary>
            Like DesiredLineEnding, this could be kept private, but is made
            public as a debugging aid.
            </summary>
        </member>
        <member name="P:WizardWrx.StringExtensions.LineEndingFixupState.NewLineEndings">
            <summary>
            Like DesiredLineEnding, this could be kept private, but is made
            public as a debugging aid.
            </summary>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.AppendNewline(System.Int32,WizardWrx.StringExtensions.LineEndingFixupState.CharacterType)">
            <summary>
            Use the current character position relative to the beginning of
            the run of newline characters and the type of the current and
            immediately previous character in the run to determine whether a
            newline should be emitted.
            </summary>
            <param name="pintCurrCharPos">
            The position (offset) of the current character is compared with
            the position of the first character in the current run of
            newline characters to determine whether to append a newline.
            </param>
            <param name="penmCurrentCharacterType"></param>
            <returns></returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.ClassifyThisCharacter(System.Char)">
            <summary>
            Update the LastCharacter property (CharacterType enum).
            </summary>
            <param name="pchrCurrent">
            Pass in the current character, which is about to become the last
            character processed.
            </param>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.IsThisCharANewline(System.Char)">
            <summary>
            Evaluate the character at a specified position in the input
            string, returning TRUE if it is a newline character (CR or LF).
            </summary>
            <param name="pchrThis">
            Specify the character to evaluate.
            </param>
            <returns>
            Return TRUE if the character at the position specified by
            <paramref name="pchrThis"/> is a newline (CR or LF)
            character. Otherwise, return FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.IsRunOfNelines">
            <summary>
            Determine whether the current newline character belongs to a run of them.
            </summary>
            <returns>
            Return TRUE unless _intPosLastNewlineChar is equal to
            ArrayInfo.ARRAY_INVALID_INDEX; otherwise, return FALSE. Though
            this method could go ahead and update _intPosLastNewlineChar, it
            leaves it unchanges, so that its execution is devoid of side
            effects.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.GetCharacterAtOffset(System.Int32)">
            <summary>
            Switch blocks in public instance method UpdateState use this
            routine to return the character at the position (offset)
            specified by <paramref name="pintCurrCharPos"/>.
            </summary>
            <param name="pintCurrCharPos">
            The zero-based offset that was fed into instance method
            UpdateState by its controler, LineEndingFixup
            </param>
            <returns>
            The return value is the character at the specified position
            (offset) in the input string, a copy of which is maintained in
            private character array _achrInputCharacters. Returning this in
            a method exposes the actual character that determines which
            branch of the switch block executes. Otherwise, the debugger
            reports only the return value returned by the property getter.
            It is anticipated that this routine will be optimized away in a
            release build.
            </returns>
        </member>
        <member name="M:WizardWrx.StringExtensions.LineEndingFixupState.SetDesiredLineEnding">
            <summary>
            The public constructor invokes this method once, during the
            initialization phase, to establish the value of the desired line
            ending, which may be a single character or a pair of them.
            </summary>
            <returns>
            The return value is always a string that contains one character or a
            pair of them.
            </returns>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState._achrInputCharacters">
            <summary>
            The constructor initializes this character array from the input
            string. Thereafter, public method UpdateState processes it one
            character at a time.
            </summary>
        </member>
        <member name="F:WizardWrx.StringExtensions.LineEndingFixupState._intPosNewlineRunStart">
            <summary>
            When two or more newline characters appear in a sequence, it is
            essential to determine whether they are a pair and, if so, treat
            them as such.
            </summary>
        </member>
        <member name="P:WizardWrx.StringExtensions.LineEndingFixupState._sbWork">
            <summary>
            Since the StringBuilder is a reference type, exposing it makes
            it vulnerable to attack. Therefore, it is kept private, and a
            public instance method, GetTransformedString, must be explicitly
            called to get its value as a new string, an immutable entity.
            </summary>
        </member>
        <member name="T:WizardWrx.SyncRoot">
            <summary>
            Use instances of this class to provide classes that must be made
            thread-safe with locks over which the class has complete control.
            </summary>
            <remarks>
            Use labeled instances when you expect to have multiple locks active,
            especially during the lifetime of a single method, or across calls to
            two or more related methods.
            
            This class cannot be inherited.
            </remarks>
        </member>
        <member name="F:WizardWrx.SyncRoot._strLabel">
            <summary>
            This string provides internal storage for the optional object label.
            </summary>
        </member>
        <member name="M:WizardWrx.SyncRoot.#ctor">
            <summary>
            Create an unlabeled instance.
            </summary>
        </member>
        <member name="M:WizardWrx.SyncRoot.#ctor(System.String)">
            <summary>
            Create a labeled lockable object.
            </summary>
            <param name="pstrLabel">
            Label to assign to the instance.
            </param>
        </member>
        <member name="P:WizardWrx.SyncRoot.Label">
            <summary>
            Return the label assigned to this instance. Labels are read only.
            You must use the overloaded constructor to create a labeled
            instance.
            </summary>
        </member>
        <member name="M:WizardWrx.SyncRoot.ToString">
            <summary>
            Display the label inside French braces, followed by the fully
            qualified class name, similar to the way many BCL classes render in
            debugger watch windows.
            </summary>
            <returns>
            The returned string is the label, followed by the fully qualified
            class name.
            </returns>
        </member>
        <member name="T:WizardWrx.SysDateFormatters">
            <summary>
            This class implements my stalwart date formatter, ReformatSysDateP6C,
            which I created initially as a Windows Interface Language (WIL, 
            a. k. a. WinBatch) library function, Reformat_Date_YmdHms_P6C, in
            October 2001, although its roots go back much further in my WIL script
            development.
            
            Since static classes are implicitly sealed, this class cannot be inherited.
            </summary>
            <seealso cref="T:WizardWrx.DisplayFormats"/>
            <seealso cref="T:WizardWrx.Core.TimeDisplayFormatter"/>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RSD_TOKENS">
            <summary>
            The strings in this array are the substitution tokens supported by
            the date formatters in this class.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD">
            <summary>
            Apply the following format to a date: YYYY/MM/DD
            
            With respect to the date only, this format confirms to the ISO 8601
            standard for time representation.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_MM_DD_YY">
            <summary>
            Apply the following format to a date: MM/DD/YY
            
            This is the standard short format used in the USA.
            
            Only the date is returned, including only the year of century, and
            the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_MM_DD_YYYY">
            <summary>
            Apply the following format to a date: MM/DD/YYYY
            
            This is the standard format used in the USA.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_DD_MM_YYYY">
            <summary>
            Apply the following format to a date: DD/MM/YYYY
            
            This is the standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_HH_MM">
            <summary>
            Apply the following format to a time: hh:mm
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This is a standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the time is returned, and the hour and minute have leading
            zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_HH_MM_SS">
            <summary>
            Apply the following format to a time: hh:mm:ss
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This is a standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the time is returned, and the hour, minute, and second have 
            leading zeros if any of them is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_HH_MM_SS_TTT">
            <summary>
            Apply the following format to a time: hh:mm:ss.ttt
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            The final token, ttt, is the milliseconds portion of the time,
            which is reported with leading zeros.
            
            This is an extension of a standard format used in most of the
            English speaking world, by all military organizations of which I am
            aware, Europeans, and others who take their lead from any of the
            above groups.
            
            Only the time is returned, and the hour, minute, and second have 
            leading zeros if any of them is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS">
            <summary>
            Apply the following format to a date and time: YYYY/MM/DD hh:mm:ss
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This format conforms fully to the ISO 8601 standard for time
            representation.
            
            The month, day, hour, minute, and second have leading zeros if any
            of them is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT">
            <summary>
            Apply the following format to a date and time: YYYY/MM/DD hh:mm:ss.ttt
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This format conforms fully to the ISO 8601 standard for time
            representation.
            
            The final token, ttt, is the milliseconds portion of the time,
            which is reported with leading zeros.
            
            The month, day, hour, minute, and second have leading zeros if any
            of them is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WWW_DD_MM_YYYY">
            <summary>
            Apply the following format to a date: WWW DD/MM/YYYY
            
            The first token, WWW, represents the three letter abbreviation of
            the weekday name, which is derived from the regional settings in the
            Windows Control Panel. The returned string conforms to the settings
            in the UICulture of the calling thread.
            
            This is the standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WWW_MM_DD_YYYY">
            <summary>
            Apply the following format to a date: WWW DD/MM/YYYY
            
            The first token, WWW, represents the three letter abbreviation of
            the weekday name, which is derived from the regional settings in the
            Windows Control Panel. The returned string conforms to the settings
            in the UICulture of the calling thread.
            
            This is the standard format used in the USA.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WW_DD_MM_YYYY">
            <summary>
            Apply the following format to a date: WW DD/MM/YYYY
            
            The first token, WW, represents enough of the three letter weekday
            name abbreviation, which is derived from the regional settings in
            the Windows Control Panel, to uniquely identify the weekday. The
            returned string conforms to the settings in the UICulture of the
            calling thread.
            
            This is the standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WW_MM_DD_YYYY">
            <summary>
            Apply the following format to a date: WW DD/MM/YYYY
            
            The first token, WW, represents enough of the three letter weekday
            name abbreviation, which is derived from the regional settings in
            the Windows Control Panel, to uniquely identify the weekday. The
            returned string conforms to the settings in the UICulture of the
            calling thread.
            
            This is the standard format used in the USA.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WWWW_DD_MM_YYYY">
            <summary>
            Apply the following format to a date: WWWW DD/MM/YYYY
            
            The first token, WWWW, represents full name of the weekday, which is
            derived from the regional settings in the Windows Control Panel. The
            returned string conforms to the settings in the UICulture of the
            calling thread.
            
            This is the standard format used in most of the English speaking
            world, by all military organizations of which I am aware, Europeans,
            and others who take their lead from any of the above groups.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFD_WWWW_MM_DD_YYYY">
            <summary>
            Apply the following format to a date: WWWW DD/MM/YYYY
            
            The first token, WWWW, represents full name of the weekday, which is
            derived from the regional settings in the Windows Control Panel. The
            returned string conforms to the settings in the UICulture of the
            calling thread.
            
            This is the standard format used in the USA.
            
            Only the date is returned, all four digits of the year are included,
            and the month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFDYYYYMMDD_HHMMSS">
            <summary>
            Apply the following format to a date and time: YYYYMMDD_hhmmss
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This format conforms fully to the ISO 8601 standard for time
            representation.
            
            The month, day, hour, minute, and second have leading zeros if any
            of them is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFDYYYYMMDD">
            <summary>
            Apply the following format to a date and time: YYYYMMDD
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This format conforms fully to the ISO 8601 standard for time
            representation.
            
            The month and day have leading zeros if either is less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.RFDHHMMSS">
            <summary>
            Apply the following format to a date and time: hhmmss
            
            The returned string represents the hours on a 24 hour clock.
            
            At present, 12 hour (AM/PM) representation is unsupported.
            
            This format conforms fully to the ISO 8601 standard for time
            representation.
            
            The hour, minute, and second have leading zeros if any of them is
            less than 10.
            </summary>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT">
            <summary>
            I use this with my SysDateFormatters class to format a date (sans
            time) so that it prints as YYYY/MM/DD.
            
            IMPORTANT: This string specifically targets the methods in the
            SysDateFormatters class. SysDateFormatters strings are incompatible
            with ToString.
            </summary>
            <example>
            2014/09/04
            </example>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT">
            <summary>
            I use this with my SysDateFormatters class to format a date and time
            so that it prints as YYYY/MM/DD HH:MM:SS.
            
            IMPORTANT: This string specifically targets the methods in the
            SysDateFormatters class. SysDateFormatters strings are incompatible
            with ToString.
            </summary>
            <example>
            2014/09/04 16:17:30
            </example>
        </member>
        <member name="F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT">
            <summary>
            I use this with my SysDateFormatters class to format a time (sans
            date) so that it prints as HH:MM:SS.
            
            IMPORTANT: This string specifically targets the methods in the
            SysDateFormatters class. SysDateFormatters strings are incompatible
            with ToString.
            </summary>
            <example>
            16:17:30
            </example>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.FormatDateForShow(System.DateTime)">
            <summary>
            Use my standard format string for displaying date stamps in
            reports, to format a DateTime structure.
            </summary>
            <param name="pdtmTestDate">
            Specify the populated DateTime to be formatted. Since only the date
            goes into the format, the time component MAY be uninitialized.
            </param>
            <returns>
            The return value is a string representation of the date and time,
            rendered according to constant STANDARD_DISPLAY_TIME_FORMAT.
            </returns>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.FormatDateTimeForShow(System.DateTime)">
            <summary>
            Use my standard format string for displaying date/time stamps in
            reports, to format a DateTime structure.
            </summary>
            <param name="pdtmTestDate">
            Specify the populated DateTime to be formatted. Since the date and
            time go into the output string, the entire structure must be
            initialized.
            </param>
            <returns>
            The return value is a string representation of the date and time,
            rendered according to constant STANDARD_DISPLAY_DATE_TIME_FORMAT.
            </returns>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.FormatTimeForShow(System.DateTime)">
            <summary>
            Use my standard format string for displaying time stamps in reports,
            to format a DateTime structure.
            </summary>
            <param name="pdtmTestDate">
            Specify the populated DateTime to be formatted. Since only the time
            goes into the format, the date component MAY be uninitialized.
            </param>
            <returns>
            The return value is a string representation of the date and time,
            rendered according to constant STANDARD_DISPLAY_TIME_FORMAT.
            </returns>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.GetDisplayTimeZone(System.DateTime,System.String)">
            <summary>
            Given a DateTime and a system time zone ID string, return the
            appropriate text to display, depending on whether the specified time
            is standard or Daylight Saving Time.
            </summary>
            <param name="pdtmTestDate">
            Specify the Syatem.DateTime for which the appropriate time zone
            string is required. Both DateTime.MinValue and DateTime.MaxValue are
            invalid; specifying either elicits the empty string.
            </param>
            <param name="pstrTimeZoneID">
            Specify a valid time zone ID string. Please see the Remarks.
            </param>
            <returns>
            If the function succeeds, the return value is the appropriate string
            to display for the given time. Otherwise, the empty string is
            returned or one of several exceptions is thrown, the most likely of
            which is a TimeZoneNotFoundException, which is thrown when the
            specified time zone ID string is invalid.
            </returns>
            <remarks>
            if in doubt, use TimeZoneInfo.GetSystemTimeZones to enumerate the
            time zones installed on the local machine. Invalid time zone strings
            always give rise to one of a number of exceptions, all of which are
            fully described in the documentation of a companion function,
            GetSystemTimeZoneInfo which this routine uses to get the time zone
            information that it needs.
            </remarks>
            <see cref="M:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)"/>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)">
            <summary>
            Given a system time zone ID string, return the corresponding
            TimeZoneInfo object if the specified time zone is defined on the
            local system.
            </summary>
            <param name="pstrTimeZoneID">
            Specify a valid time zone ID string. There are two special IDs,
            LocalTime and UTC, both of which are accessible through static
            properties on the TimeZoneInfo class. Although you could use the ID
            properties with this method, the most efficient way to handle these
            special cases is by reference to the Local property for LocalTime
            and the UTC property for UTC time. (This method could take the same
            shortcut, but I decided that it wasn't worth the extra code and
            testing.
            </param>
            <returns>
            If the function succeeds, the return value is a TimeZoneInfo object,
            populated from the Windows Registry. Otherwise, one of the
            exceptions listed and described below is thrown.
            </returns>
            <exception cref="T:System.OutOfMemoryException">
            You should restart Windows if this happens.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Contact the author of the program. This is something that he or she
            must address.
            </exception>
            <exception cref="T:System.TimeZoneNotFoundException">
            Contact the author of the program. This is something that he or she
            must address.
            </exception>
            <exception cref="T:System.Security.SecurityException">
            Contact your system administrator to inquire about why your program
            is forbidden to read the regional settings from the Windows
            Registry.
            </exception>
            <exception cref="T:System.InvalidTimeZoneException">
            Contact your system support group. A corrupted Windows Registry is a
            rare, but serious matter.
            </exception>
            <exception cref="T:System.Exception">
            Start with your system support group, who may need to request the
            assistance of the author of the program.
            </exception>
            <remarks>
            if in doubt, use TimeZoneInfo.GetSystemTimeZones to enumerate the
            time zones installed on the local machine.
            </remarks>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.ReformatNow(System.String)">
            <summary>
            This method has a nearly exact analogue in the constellations of WIL
            User Defined Functions that gave rise to its immediate predecessor,
            a like named function implemented in straight C, with a little help
            from the Windows National Language Subsystem, which underlies the
            CultureInfo class.
            </summary>
            <param name="pstrFormat">
            This System.String is a combination of tokens and literal text that
            governs the formatting of the date.
            </param>
            <returns>
            The return value is a string containing the current date and time,
            formatted according to the rules spelled out in format string
            pstrFormat.
            </returns>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.ReformatUtcNow(System.String)">
            <summary>
            In the original constellation of WinBatch functions and their C
            descendants, this function took the form of an optional argument to
            ReformatNow. I think I prefer this way.
            </summary>
            <param name="pstrFormat">
            This System.String is a combination of tokens and literal text that
            governs the formatting of the date.
            </param>
            <returns>
            The return value is a string containing the current UTC time,
            formatted according to the rules spelled out in format string
            pstrFormat.
            </returns>
        </member>
        <member name="M:WizardWrx.SysDateFormatters.ReformatSysDate(System.DateTime,System.String)">
            <summary>
            ReformatSysDate is the core function of the constellation of
            routines that grew from the original WIL script. Substitution tokens
            drive construction of a formatted date string.
            </summary>
            <param name="pdtmToFormat">
            This System.DateTime is the time to be formatted.
            </param>
            <param name="pstrFormat">
            This System.String is a combination of tokens and literal text that
            governs the formatting of the date.
            </param>
            <returns>
            The return value is a string containing the date and/or time in
            argument pdtmToFormat, formatted according to the rules spelled out 
            in format string pstrFormat.
            </returns>
        </member>
        <member name="T:WizardWrx.TextBlocks">
            <summary>
            This class defines methods for creating and manipulating bounded text blocks.
            </summary>
        </member>
        <member name="F:WizardWrx.TextBlocks.BLOCK_BEGIN_TEXT">
            <summary>
            My text block begin markers always end with this string.
            </summary>
        </member>
        <member name="F:WizardWrx.TextBlocks.BLOCK_END_TEXT">
            <summary>
            My text block ending markers always end with this string.
            </summary>
        </member>
        <member name="M:WizardWrx.TextBlocks.#ctor">
            <summary>
            The default constructor creates an empty class. Its MarkerText
            property must be set before its other properties are useful.
            </summary>
        </member>
        <member name="M:WizardWrx.TextBlocks.#ctor(System.String)">
            <summary>
            This overload creates an empty class, and initializes its MarkerText
            property.
            </summary>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
        </member>
        <member name="M:WizardWrx.TextBlocks.#ctor(System.String,System.String)">
            <summary>
            This overload creates an empty class, and initializes its rInputData
            and MarkerText properties.
            </summary>
            <param name="pstrInputData">
            String containing text from which marked blocks will be extracted.
            Also sets the InputData property.
            </param>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
        </member>
        <member name="P:WizardWrx.TextBlocks.InputData">
            <summary>
            String from which to extract blocks.
            </summary>
        </member>
        <member name="P:WizardWrx.TextBlocks.MarkerText">
            <summary>
            This is the text that forms the middle (and variable) part of the
            TextBlocks marker strings.
            </summary>
        </member>
        <member name="P:WizardWrx.TextBlocks.Prefix">
            <summary>
            Construct, on the fly, and return, the block prefix.
            </summary>
        </member>
        <member name="P:WizardWrx.TextBlocks.Suffix">
            <summary>
            Construct, on the fly, and return, the block suffix.
            </summary>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlock">
            <summary>
            Extract a block marked by text constructed from the string in the
            MarkerText property from the text in the InputData property.
            </summary>
            <returns>
            Text between block markers. If the prefix marker is followed by a
            newline, the newline is removed. Likewise, if the suffix marker is
            preceded by a newline, that newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlock(System.String)">
            <summary>
            Extract a block marked by text constructed from the string in
            argument pstrMarkerText from the text in the InputData property, and
            update the MarkerText property.
            </summary>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
            <returns>
            Text between block markers. If the prefix marker is followed by a
            newline, the newline is removed. Likewise, if the suffix marker is
            preceded by a newline, that newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlock(System.String,System.String)">
            <summary>
            Extract a block marked by text constructed from the string in
            argument pstrMarkerText from the text in argument pstrInputData.
            Update the InputData and MarkerText properties.
            </summary>
            <param name="pstrInputData">
            String containing text from which marked blocks will be extracted.
            Also sets the InputData property.
            </param>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
            <returns>
            Text between block markers. If the prefix marker is followed by a
            newline, the newline is removed. Likewise, if the suffix marker is
            preceded by a newline, that newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlockToArray">
            <summary>
            Extract a block marked by text constructed from the string in
            argument pstrMarkerText from the text in argument pstrInputData.
            Update the InputData and MarkerText properties.
            </summary>
            <returns>
            Array of strings containing the text between block markers. If the
            prefix marker is followed by a newline, the newline is removed.
            Likewise, if the suffix marker is preceded by a newline, that
            newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlockToArray(System.String)">
            <summary>
            Extract a block marked by text constructed from the string in
            argument pstrMarkerText from the text in argument pstrInputData.
            Update the InputData and MarkerText properties.
            </summary>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
            <returns>
            Array of strings containing the text between block markers. If the
            prefix marker is followed by a newline, the newline is removed.
            Likewise, if the suffix marker is preceded by a newline, that
            newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.ExtractBlockToArray(System.String,System.String)">
            <summary>
            Extract a block marked by text constructed from the string in
            argument pstrMarkerText from the text in argument pstrInputData.
            Update the InputData and MarkerText properties.
            </summary>
            <param name="pstrInputData">
            String containing text from which marked blocks will be extracted.
            Also sets the InputData property.
            </param>
            <param name="pstrMarkerText">
            String containing text from which marker prefixes and suffixes are
            constructed. Also sets the MarkerText property.
            </param>
            <returns>
            Array of strings containing the text between block markers. If the
            prefix marker is followed by a newline, the newline is removed.
            Likewise, if the suffix marker is preceded by a newline, that
            newline is also removed.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.CharToArray(System.Char)">
            <summary>
            Return a one-element array containing the input character.
            </summary>
            <param name="pchr">
            Character to place into the returned array.
            </param>
            <returns>
            Array of characters, containing exactly one element, which contains
            the single input character.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.StringOfLinesToArray(System.String)">
            <summary>
            Split a string containing lines of text into an array of strings.
            </summary>
            <param name="pstrLines">
            String containing lines of text, terminated by CR/LF pairs.
            </param>
            <returns>
            Array of strings, one line per string. Blank lines are preserved as
            empty strings.
            </returns>
        </member>
        <member name="M:WizardWrx.TextBlocks.StringOfLinesToArray(System.String,System.StringSplitOptions)">
            <summary>
            Split a string containing lines of text into an array of strings,
            as modified by the StringSplitOptions flag.
            </summary>
            <param name="pstrLines">
            String containing lines of text, terminated by CR/LF pairs.
            </param>
            <param name="penmStringSplitOptions">
            A member of the StringSplitOptions enumeration, presumably other
            than StringSplitOptions.None, which is assumed by the first
            overload. The only option supported by version 2 of the Microsoft
            .NET CLR is RemoveEmptyEntries.
            </param>
            <returns>
            Array of strings, one line per string. Blank lines are preserved as
            empty strings unless penmStringSplitOptions is RemoveEmptyEntries,
            as is most likely to be the case.
            </returns>
            <remarks>
            Use this overload to convert a string, discarding blank lines.
            </remarks>
        </member>
        <member name="M:WizardWrx.TextBlocks.StringToArray(System.String)">
            <summary>
            Return a one-element array containing the input string.
            </summary>
            <param name="pstr">
            String to place into the returned array.
            </param>
            <returns>
            Array of strings, containing exactly one element, which contains
            the single input string.
            </returns>
        </member>
    </members>
</doc>
