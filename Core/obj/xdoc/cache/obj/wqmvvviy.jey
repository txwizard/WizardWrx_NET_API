id: WizardWrx.Core
language: CSharp
name:
  Default: WizardWrx.Core
qualifiedName:
  Default: WizardWrx.Core
type: Assembly
modifiers: {}
items:
- id: WizardWrx
  commentId: N:WizardWrx
  language: CSharp
  name:
    CSharp: WizardWrx
    VB: WizardWrx
  nameWithType:
    CSharp: WizardWrx
    VB: WizardWrx
  qualifiedName:
    CSharp: WizardWrx
    VB: WizardWrx
  type: Namespace
  assemblies:
  - WizardWrx.Core
  modifiers: {}
  items:
  - id: WizardWrx.DateTimeExtensions
    commentId: T:WizardWrx.DateTimeExtensions
    language: CSharp
    name:
      CSharp: DateTimeExtensions
      VB: DateTimeExtensions
    nameWithType:
      CSharp: DateTimeExtensions
      VB: DateTimeExtensions
    qualifiedName:
      CSharp: WizardWrx.DateTimeExtensions
      VB: WizardWrx.DateTimeExtensions
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/DateTimeExtensions.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: DateTimeExtensions
      path: ../Core/DateTimeExtensions.cs
      startLine: 79
    summary: "\nThis class implements two overloads of DateOfMostRecentWeekdayDay, a\nstatic method, implemented as an extension method on the System.DateTime\ntype. The two overloads accept their one externally visible argment as\neither a DayOfWeek enumeration member or its integral value.\n"
    example: []
    syntax:
      content:
        CSharp: public static class DateTimeExtensions
        VB: Public Module DateTimeExtensions
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - isExtensionMethod: true
      id: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime,System.DayOfWeek)
      commentId: M:WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime,System.DayOfWeek)
      language: CSharp
      name:
        CSharp: DateOfMostRecentWeekday(DateTime, DayOfWeek)
        VB: DateOfMostRecentWeekday(DateTime, DayOfWeek)
      nameWithType:
        CSharp: DateTimeExtensions.DateOfMostRecentWeekday(DateTime, DayOfWeek)
        VB: DateTimeExtensions.DateOfMostRecentWeekday(DateTime, DayOfWeek)
      qualifiedName:
        CSharp: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime, System.DayOfWeek)
        VB: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime, System.DayOfWeek)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/DateTimeExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DateOfMostRecentWeekday
        path: ../Core/DateTimeExtensions.cs
        startLine: 114
      summary: "\nGiven a date and a day of the week, return the date of the most\nrecent instance of the specified day of the week.\n"
      remarks: "\nSince enumerated types can be freely converted to and from integers,\nand a program stands a fair chance of having the weekday specified\nin terms of either, two versions of this method are offered. Since\nintegers are easier to manipulate, the overload that accepts the\ninteger representation of the weekday implements both; the overload\nthat takes the enumeration casts it to integer and calls the other\noverload, through which it returns.\n"
      example:
      - "\nWhen <code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code> is 03/08/2022 and\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">penmDayOfWeek</code> is Sunday, the return value is\nSunday, 03/06/2022.\n"
      syntax:
        content:
          CSharp: public static DateTime DateOfMostRecentWeekday(this DateTime pdtmThisDate, DayOfWeek penmDayOfWeek)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function DateOfMostRecentWeekday(pdtmThisDate As Date, penmDayOfWeek As DayOfWeek) As Date
        parameters:
        - id: pdtmThisDate
          type: System.DateTime
          description: "\nSpecify the DateTime to serve as the reference point against which\ncalculate the most recent weekday given by <code data-dev-comment-type=\"paramref\" class=\"paramref\">penmDayOfWeek</code>.\n"
        - id: penmDayOfWeek
          type: System.DayOfWeek
          description: "\nSpecify the weekday in terms of the DayOfWeek enumeration for which the\nweekday nearest to <code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code> is desired.\n"
        return:
          type: System.DateTime
          description: "\nThe return value is the date, represented as a DateTime object, for\nwhich the DayOfWeek property is the value specified by\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">penmDayOfWeek</code> that is the most recent instance of\nthe specified weekday that is on or before the date specified by\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code>.\n"
      overload: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime,System.Int32)
      commentId: M:WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime,System.Int32)
      language: CSharp
      name:
        CSharp: DateOfMostRecentWeekday(DateTime, Int32)
        VB: DateOfMostRecentWeekday(DateTime, Int32)
      nameWithType:
        CSharp: DateTimeExtensions.DateOfMostRecentWeekday(DateTime, Int32)
        VB: DateTimeExtensions.DateOfMostRecentWeekday(DateTime, Int32)
      qualifiedName:
        CSharp: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime, System.Int32)
        VB: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday(System.DateTime, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/DateTimeExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DateOfMostRecentWeekday
        path: ../Core/DateTimeExtensions.cs
        startLine: 158
      summary: "\nGiven a date and a day of the week, return the date of the most\nrecent instance of the specified day of the week.\n"
      remarks: "\nSince enumerated types can be freely converted to and from integers,\nand a program stands a fair chance of having the weekday specified\nin terms of either, two versions of this method are offered. Since\nintegers are easier to manipulate, the overload that accepts the\ninteger representation of the weekday implements both; the overload\nthat takes the enumeration casts it to integer and calls the other\noverload, through which it returns.\n"
      example:
      - "\nWhen <code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code> is 03/08/2022 and\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pintDayOfWeekIndex</code> is Sunday, the return value is\nSunday, 03/06/2022.\n"
      syntax:
        content:
          CSharp: public static DateTime DateOfMostRecentWeekday(this DateTime pdtmThisDate, int pintDayOfWeekIndex)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function DateOfMostRecentWeekday(pdtmThisDate As Date, pintDayOfWeekIndex As Integer) As Date
        parameters:
        - id: pdtmThisDate
          type: System.DateTime
          description: "\nSpecify the DateTime to serve as the reference point against which\ncalculate the most recent weekday given by <code data-dev-comment-type=\"paramref\" class=\"paramref\">pintDayOfWeekIndex</code>.\n"
        - id: pintDayOfWeekIndex
          type: System.Int32
          description: "\nSpecify the weekday in terms of the integer that maps to the intended\nDayOfWeek enumeration value for which the weekday nearest to\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code> is desired.\n"
        return:
          type: System.DateTime
          description: "\nThe return value is the date, represented as a DateTime object, for\nwhich the DayOfWeek property is the value specified as integer\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pintDayOfWeekIndex</code> that is the most recent instance of\nthe specified weekday that is on or before the date specified by\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmThisDate</code>.\n"
      overload: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.FileInfoExtension
    commentId: T:WizardWrx.FileInfoExtension
    language: CSharp
    name:
      CSharp: FileInfoExtension
      VB: FileInfoExtension
    nameWithType:
      CSharp: FileInfoExtension
      VB: FileInfoExtension
    qualifiedName:
      CSharp: WizardWrx.FileInfoExtension
      VB: WizardWrx.FileInfoExtension
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileInfoExtension.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: FileInfoExtension
      path: ../Core/FileInfoExtension.cs
      startLine: 125
    summary: "\nExtend the System.IO.FileInfo class with methods for testing, setting,\nand clearing file attribute flags, including the ability to save and\nrestore flags to their initial states.\n"
    example: []
    syntax:
      content:
        CSharp: public class FileInfoExtension
        VB: Public Class FileInfoExtension
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.FileInfoExtension.#ctor(System.String)
      commentId: M:WizardWrx.FileInfoExtension.#ctor(System.String)
      language: CSharp
      name:
        CSharp: FileInfoExtension(String)
        VB: FileInfoExtension(String)
      nameWithType:
        CSharp: FileInfoExtension.FileInfoExtension(String)
        VB: FileInfoExtension.FileInfoExtension(String)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.FileInfoExtension(System.String)
        VB: WizardWrx.FileInfoExtension.FileInfoExtension(System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/FileInfoExtension.cs
        startLine: 165
      summary: "\nWe insist on a file name.\n"
      remarks: "\nBecause of its intended use, this class is designed without a public\ndefault constructor. I believe that it is extremely unlikely that a\nuser would need to serialize an instance of this class.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfoExtension(string pstrFileName)
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public Sub New(pstrFileName As String)
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of a file to process. This string must\npoint to an existing file.\n"
      overload: WizardWrx.FileInfoExtension.#ctor*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ArchiveClear
      commentId: M:WizardWrx.FileInfoExtension.ArchiveClear
      language: CSharp
      name:
        CSharp: ArchiveClear()
        VB: ArchiveClear()
      nameWithType:
        CSharp: FileInfoExtension.ArchiveClear()
        VB: FileInfoExtension.ArchiveClear()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ArchiveClear()
        VB: WizardWrx.FileInfoExtension.ArchiveClear()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArchiveClear
        path: ../Core/FileInfoExtension.cs
        startLine: 186
      summary: "\nClear the Archive flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasArchive property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ArchiveClear()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ArchiveClear As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Archive flag.\n"
      overload: WizardWrx.FileInfoExtension.ArchiveClear*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ArchiveReinstate
      commentId: M:WizardWrx.FileInfoExtension.ArchiveReinstate
      language: CSharp
      name:
        CSharp: ArchiveReinstate()
        VB: ArchiveReinstate()
      nameWithType:
        CSharp: FileInfoExtension.ArchiveReinstate()
        VB: FileInfoExtension.ArchiveReinstate()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ArchiveReinstate()
        VB: WizardWrx.FileInfoExtension.ArchiveReinstate()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArchiveReinstate
        path: ../Core/FileInfoExtension.cs
        startLine: 217
      summary: "\nRestore the initial state of the Archive flag.\n"
      remarks: "\nSince the return value is strictly informational, callers may safely\nignore or discard it.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ArchiveReinstate()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ArchiveReinstate As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Archive flag.\n"
      overload: WizardWrx.FileInfoExtension.ArchiveReinstate*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ArchiveSet
      commentId: M:WizardWrx.FileInfoExtension.ArchiveSet
      language: CSharp
      name:
        CSharp: ArchiveSet()
        VB: ArchiveSet()
      nameWithType:
        CSharp: FileInfoExtension.ArchiveSet()
        VB: FileInfoExtension.ArchiveSet()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ArchiveSet()
        VB: WizardWrx.FileInfoExtension.ArchiveSet()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArchiveSet
        path: ../Core/FileInfoExtension.cs
        startLine: 254
      summary: "\nSet the Archive flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasArchive property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ArchiveSet()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ArchiveSet As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Archive flag.\n"
      overload: WizardWrx.FileInfoExtension.ArchiveSet*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.HiddenClear
      commentId: M:WizardWrx.FileInfoExtension.HiddenClear
      language: CSharp
      name:
        CSharp: HiddenClear()
        VB: HiddenClear()
      nameWithType:
        CSharp: FileInfoExtension.HiddenClear()
        VB: FileInfoExtension.HiddenClear()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.HiddenClear()
        VB: WizardWrx.FileInfoExtension.HiddenClear()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HiddenClear
        path: ../Core/FileInfoExtension.cs
        startLine: 288
      summary: "\nClear the Hidden flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasHidden property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus HiddenClear()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function HiddenClear As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Hidden flag.\n"
      overload: WizardWrx.FileInfoExtension.HiddenClear*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.HiddenReinstate
      commentId: M:WizardWrx.FileInfoExtension.HiddenReinstate
      language: CSharp
      name:
        CSharp: HiddenReinstate()
        VB: HiddenReinstate()
      nameWithType:
        CSharp: FileInfoExtension.HiddenReinstate()
        VB: FileInfoExtension.HiddenReinstate()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.HiddenReinstate()
        VB: WizardWrx.FileInfoExtension.HiddenReinstate()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HiddenReinstate
        path: ../Core/FileInfoExtension.cs
        startLine: 319
      summary: "\nRestore the initial state of the Hidden flag.\n"
      remarks: "\nSince the return value is strictly informational, callers may safely\nignore or discard it.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus HiddenReinstate()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function HiddenReinstate As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Hidden flag.\n"
      overload: WizardWrx.FileInfoExtension.HiddenReinstate*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.HiddenSet
      commentId: M:WizardWrx.FileInfoExtension.HiddenSet
      language: CSharp
      name:
        CSharp: HiddenSet()
        VB: HiddenSet()
      nameWithType:
        CSharp: FileInfoExtension.HiddenSet()
        VB: FileInfoExtension.HiddenSet()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.HiddenSet()
        VB: WizardWrx.FileInfoExtension.HiddenSet()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HiddenSet
        path: ../Core/FileInfoExtension.cs
        startLine: 356
      summary: "\nSet the Hidden flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasHidden property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus HiddenSet()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function HiddenSet As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Hidden flag.\n"
      overload: WizardWrx.FileInfoExtension.HiddenSet*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ReadOnlyClear
      commentId: M:WizardWrx.FileInfoExtension.ReadOnlyClear
      language: CSharp
      name:
        CSharp: ReadOnlyClear()
        VB: ReadOnlyClear()
      nameWithType:
        CSharp: FileInfoExtension.ReadOnlyClear()
        VB: FileInfoExtension.ReadOnlyClear()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ReadOnlyClear()
        VB: WizardWrx.FileInfoExtension.ReadOnlyClear()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReadOnlyClear
        path: ../Core/FileInfoExtension.cs
        startLine: 390
      summary: "\nClear the Read ONly flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasReadOnly property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ReadOnlyClear()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ReadOnlyClear As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Read ONly flag.\n"
      overload: WizardWrx.FileInfoExtension.ReadOnlyClear*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ReadOnlyReinstate
      commentId: M:WizardWrx.FileInfoExtension.ReadOnlyReinstate
      language: CSharp
      name:
        CSharp: ReadOnlyReinstate()
        VB: ReadOnlyReinstate()
      nameWithType:
        CSharp: FileInfoExtension.ReadOnlyReinstate()
        VB: FileInfoExtension.ReadOnlyReinstate()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ReadOnlyReinstate()
        VB: WizardWrx.FileInfoExtension.ReadOnlyReinstate()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReadOnlyReinstate
        path: ../Core/FileInfoExtension.cs
        startLine: 421
      summary: "\nRestore the initial state of the Read Only flag.\n"
      remarks: "\nSince the return value is strictly informational, callers may safely\nignore or discard it.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ReadOnlyReinstate()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ReadOnlyReinstate As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Read ONly flag.\n"
      overload: WizardWrx.FileInfoExtension.ReadOnlyReinstate*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.ReadOnlySet
      commentId: M:WizardWrx.FileInfoExtension.ReadOnlySet
      language: CSharp
      name:
        CSharp: ReadOnlySet()
        VB: ReadOnlySet()
      nameWithType:
        CSharp: FileInfoExtension.ReadOnlySet()
        VB: FileInfoExtension.ReadOnlySet()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ReadOnlySet()
        VB: WizardWrx.FileInfoExtension.ReadOnlySet()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReadOnlySet
        path: ../Core/FileInfoExtension.cs
        startLine: 458
      summary: "\nSet the Read Only flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasReadOnly property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus ReadOnlySet()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function ReadOnlySet As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the Read ONly flag.\n"
      overload: WizardWrx.FileInfoExtension.ReadOnlySet*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.SystemClear
      commentId: M:WizardWrx.FileInfoExtension.SystemClear
      language: CSharp
      name:
        CSharp: SystemClear()
        VB: SystemClear()
      nameWithType:
        CSharp: FileInfoExtension.SystemClear()
        VB: FileInfoExtension.SystemClear()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.SystemClear()
        VB: WizardWrx.FileInfoExtension.SystemClear()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SystemClear
        path: ../Core/FileInfoExtension.cs
        startLine: 492
      summary: "\nClear the System flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasSystem property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus SystemClear()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function SystemClear As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the System flag.\n"
      overload: WizardWrx.FileInfoExtension.SystemClear*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.SystemReinstate
      commentId: M:WizardWrx.FileInfoExtension.SystemReinstate
      language: CSharp
      name:
        CSharp: SystemReinstate()
        VB: SystemReinstate()
      nameWithType:
        CSharp: FileInfoExtension.SystemReinstate()
        VB: FileInfoExtension.SystemReinstate()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.SystemReinstate()
        VB: WizardWrx.FileInfoExtension.SystemReinstate()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SystemReinstate
        path: ../Core/FileInfoExtension.cs
        startLine: 523
      summary: "\nRestore the initial state of the System flag.\n"
      remarks: "\nSince the return value is strictly informational, callers may safely\nignore or discard it.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus SystemReinstate()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function SystemReinstate As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the System flag.\n"
      overload: WizardWrx.FileInfoExtension.SystemReinstate*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.SystemSet
      commentId: M:WizardWrx.FileInfoExtension.SystemSet
      language: CSharp
      name:
        CSharp: SystemSet()
        VB: SystemSet()
      nameWithType:
        CSharp: FileInfoExtension.SystemSet()
        VB: FileInfoExtension.SystemSet()
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.SystemSet()
        VB: WizardWrx.FileInfoExtension.SystemSet()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SystemSet
        path: ../Core/FileInfoExtension.cs
        startLine: 560
      summary: "\nSet the System flag.\n"
      remarks: "\nSince the initial state of the flag is preserved internally by the\nclass, and can be read from the WasSystem property, callers may\nsafely ignore or discard the return value.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")]

            public FileInfoExtension.enmInitialStatus SystemSet()
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.")>

            Public Function SystemSet As FileInfoExtension.enmInitialStatus
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nPrevious state of the System flag.\n"
      overload: WizardWrx.FileInfoExtension.SystemSet*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed.
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.FileInfoExtension.TheFile
      commentId: P:WizardWrx.FileInfoExtension.TheFile
      language: CSharp
      name:
        CSharp: TheFile
        VB: TheFile
      nameWithType:
        CSharp: FileInfoExtension.TheFile
        VB: FileInfoExtension.TheFile
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.TheFile
        VB: WizardWrx.FileInfoExtension.TheFile
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TheFile
        path: ../Core/FileInfoExtension.cs
        startLine: 587
      summary: "\nReturn the underlying FileInfo object, which is initialized by the\nconstructor.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfo TheFile { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property TheFile As FileInfo
        parameters: []
        return:
          type: System.IO.FileInfo
      overload: WizardWrx.FileInfoExtension.TheFile*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Archive
      commentId: P:WizardWrx.FileInfoExtension.Archive
      language: CSharp
      name:
        CSharp: Archive
        VB: Archive
      nameWithType:
        CSharp: FileInfoExtension.Archive
        VB: FileInfoExtension.Archive
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Archive
        VB: WizardWrx.FileInfoExtension.Archive
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Archive
        path: ../Core/FileInfoExtension.cs
        startLine: 594
      summary: "\nThis property returns the current state of the Archive attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Archive { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Archive As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Archive*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Compressed
      commentId: P:WizardWrx.FileInfoExtension.Compressed
      language: CSharp
      name:
        CSharp: Compressed
        VB: Compressed
      nameWithType:
        CSharp: FileInfoExtension.Compressed
        VB: FileInfoExtension.Compressed
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Compressed
        VB: WizardWrx.FileInfoExtension.Compressed
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Compressed
        path: ../Core/FileInfoExtension.cs
        startLine: 601
      summary: "\nThis property returns the current state of the Compressed attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Compressed { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Compressed As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Compressed*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Encrypted
      commentId: P:WizardWrx.FileInfoExtension.Encrypted
      language: CSharp
      name:
        CSharp: Encrypted
        VB: Encrypted
      nameWithType:
        CSharp: FileInfoExtension.Encrypted
        VB: FileInfoExtension.Encrypted
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Encrypted
        VB: WizardWrx.FileInfoExtension.Encrypted
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Encrypted
        path: ../Core/FileInfoExtension.cs
        startLine: 608
      summary: "\nThis property returns the current state of the Encrypted attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Encrypted { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Encrypted As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Encrypted*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Hidden
      commentId: P:WizardWrx.FileInfoExtension.Hidden
      language: CSharp
      name:
        CSharp: Hidden
        VB: Hidden
      nameWithType:
        CSharp: FileInfoExtension.Hidden
        VB: FileInfoExtension.Hidden
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Hidden
        VB: WizardWrx.FileInfoExtension.Hidden
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Hidden
        path: ../Core/FileInfoExtension.cs
        startLine: 615
      summary: "\nThis property returns the current state of the Hidden attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Hidden { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Hidden As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Hidden*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.NotContentIndexed
      commentId: P:WizardWrx.FileInfoExtension.NotContentIndexed
      language: CSharp
      name:
        CSharp: NotContentIndexed
        VB: NotContentIndexed
      nameWithType:
        CSharp: FileInfoExtension.NotContentIndexed
        VB: FileInfoExtension.NotContentIndexed
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.NotContentIndexed
        VB: WizardWrx.FileInfoExtension.NotContentIndexed
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: NotContentIndexed
        path: ../Core/FileInfoExtension.cs
        startLine: 622
      summary: "\nThis property returns the current state of the NotContentIndexed attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool NotContentIndexed { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property NotContentIndexed As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.NotContentIndexed*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Offline
      commentId: P:WizardWrx.FileInfoExtension.Offline
      language: CSharp
      name:
        CSharp: Offline
        VB: Offline
      nameWithType:
        CSharp: FileInfoExtension.Offline
        VB: FileInfoExtension.Offline
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Offline
        VB: WizardWrx.FileInfoExtension.Offline
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Offline
        path: ../Core/FileInfoExtension.cs
        startLine: 629
      summary: "\nThis property returns the current state of the Offline attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Offline { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Offline As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Offline*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.ReadOnly
      commentId: P:WizardWrx.FileInfoExtension.ReadOnly
      language: CSharp
      name:
        CSharp: ReadOnly
        VB: ReadOnly
      nameWithType:
        CSharp: FileInfoExtension.ReadOnly
        VB: FileInfoExtension.ReadOnly
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.ReadOnly
        VB: WizardWrx.FileInfoExtension.ReadOnly
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReadOnly
        path: ../Core/FileInfoExtension.cs
        startLine: 636
      summary: "\nThis property returns the current state of the ReadOnly attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool ReadOnly { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property ReadOnly As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.ReadOnly*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.System
      commentId: P:WizardWrx.FileInfoExtension.System
      language: CSharp
      name:
        CSharp: System
        VB: System
      nameWithType:
        CSharp: FileInfoExtension.System
        VB: FileInfoExtension.System
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.System
        VB: WizardWrx.FileInfoExtension.System
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: System
        path: ../Core/FileInfoExtension.cs
        startLine: 643
      summary: "\nThis property returns the current state of the System attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool System { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property System As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.System*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.Temporary
      commentId: P:WizardWrx.FileInfoExtension.Temporary
      language: CSharp
      name:
        CSharp: Temporary
        VB: Temporary
      nameWithType:
        CSharp: FileInfoExtension.Temporary
        VB: FileInfoExtension.Temporary
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.Temporary
        VB: WizardWrx.FileInfoExtension.Temporary
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Temporary
        path: ../Core/FileInfoExtension.cs
        startLine: 650
      summary: "\nThis property returns the current state of the Temporary attribute.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public bool Temporary { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property Temporary As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.FileInfoExtension.Temporary*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.WasArchive
      commentId: P:WizardWrx.FileInfoExtension.WasArchive
      language: CSharp
      name:
        CSharp: WasArchive
        VB: WasArchive
      nameWithType:
        CSharp: FileInfoExtension.WasArchive
        VB: FileInfoExtension.WasArchive
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.WasArchive
        VB: WizardWrx.FileInfoExtension.WasArchive
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasArchive
        path: ../Core/FileInfoExtension.cs
        startLine: 662
      summary: "\nReturn the initial state of the Archive flag.\n"
      remarks: "\nThe value of this property is meaningless after the\nArchiveReinstate method is called, and before either ArchiveClear\nor ArchiveSet has been called on an instance.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfoExtension.enmInitialStatus WasArchive { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property WasArchive As FileInfoExtension.enmInitialStatus
        parameters: []
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
      overload: WizardWrx.FileInfoExtension.WasArchive*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.WasReadOnly
      commentId: P:WizardWrx.FileInfoExtension.WasReadOnly
      language: CSharp
      name:
        CSharp: WasReadOnly
        VB: WasReadOnly
      nameWithType:
        CSharp: FileInfoExtension.WasReadOnly
        VB: FileInfoExtension.WasReadOnly
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.WasReadOnly
        VB: WizardWrx.FileInfoExtension.WasReadOnly
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasReadOnly
        path: ../Core/FileInfoExtension.cs
        startLine: 674
      summary: "\nReturn the initial state of the ReadOnly flag.\n"
      remarks: "\nThe value of this property is meaningless after the\nReadOnlyReinstate method is called, and before either ReadOnlyClear\nor ReadOnlySet has been called on an instance.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfoExtension.enmInitialStatus WasReadOnly { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property WasReadOnly As FileInfoExtension.enmInitialStatus
        parameters: []
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
      overload: WizardWrx.FileInfoExtension.WasReadOnly*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.WasHidden
      commentId: P:WizardWrx.FileInfoExtension.WasHidden
      language: CSharp
      name:
        CSharp: WasHidden
        VB: WasHidden
      nameWithType:
        CSharp: FileInfoExtension.WasHidden
        VB: FileInfoExtension.WasHidden
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.WasHidden
        VB: WizardWrx.FileInfoExtension.WasHidden
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasHidden
        path: ../Core/FileInfoExtension.cs
        startLine: 686
      summary: "\nReturn the initial state of the Hidden flag.\n"
      remarks: "\nThe value of this property is meaningless after the\nHiddenReinstate method is called, and before either HiddenClear\nor HiddenSet has been called on an instance.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfoExtension.enmInitialStatus WasHidden { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property WasHidden As FileInfoExtension.enmInitialStatus
        parameters: []
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
      overload: WizardWrx.FileInfoExtension.WasHidden*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.FileInfoExtension.WasSystem
      commentId: P:WizardWrx.FileInfoExtension.WasSystem
      language: CSharp
      name:
        CSharp: WasSystem
        VB: WasSystem
      nameWithType:
        CSharp: FileInfoExtension.WasSystem
        VB: FileInfoExtension.WasSystem
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.WasSystem
        VB: WizardWrx.FileInfoExtension.WasSystem
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasSystem
        path: ../Core/FileInfoExtension.cs
        startLine: 698
      summary: "\nReturn the initial state of the System flag.\n"
      remarks: "\nThe value of this property is meaningless after the\nSystemReinstate method is called, and before either SystemClear\nor SystemSet has been called on an instance.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")]

            public FileInfoExtension.enmInitialStatus WasSystem { get; }
          VB: >-
            <Obsolete("The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.")>

            Public ReadOnly Property WasSystem As FileInfoExtension.enmInitialStatus
        parameters: []
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
      overload: WizardWrx.FileInfoExtension.WasSystem*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: The FileInfoExtension instance methods that modify FileAttributes are being retired in favor of the extension methods on FileInfo declared herein. These methods will eventually be removed, as will the instance properties and storage.
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
  - id: WizardWrx.FileInfoExtension.enmInitialStatus
    commentId: T:WizardWrx.FileInfoExtension.enmInitialStatus
    language: CSharp
    name:
      CSharp: FileInfoExtension.enmInitialStatus
      VB: FileInfoExtension.enmInitialStatus
    nameWithType:
      CSharp: FileInfoExtension.enmInitialStatus
      VB: FileInfoExtension.enmInitialStatus
    qualifiedName:
      CSharp: WizardWrx.FileInfoExtension.enmInitialStatus
      VB: WizardWrx.FileInfoExtension.enmInitialStatus
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileInfoExtension.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: enmInitialStatus
      path: ../Core/FileInfoExtension.cs
      startLine: 130
    summary: "\nDefine the three possible initial states.\n"
    example: []
    syntax:
      content:
        CSharp: public enum enmInitialStatus
        VB: Public Enum enmInitialStatus
    extensionMethods:
    - WizardWrx.FileInfoExtension.enmInitialStatus.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.FileInfoExtension.enmInitialStatus.Unknown
      commentId: F:WizardWrx.FileInfoExtension.enmInitialStatus.Unknown
      language: CSharp
      name:
        CSharp: Unknown
        VB: Unknown
      nameWithType:
        CSharp: FileInfoExtension.enmInitialStatus.Unknown
        VB: FileInfoExtension.enmInitialStatus.Unknown
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.enmInitialStatus.Unknown
        VB: WizardWrx.FileInfoExtension.enmInitialStatus.Unknown
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Unknown
        path: ../Core/FileInfoExtension.cs
        startLine: 135
      example: []
      syntax:
        content:
          CSharp: Unknown = 0
          VB: Unknown = 0
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nThis is the initial state, before the flag is tested.\n"
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtension.enmInitialStatus.WasCleared
      commentId: F:WizardWrx.FileInfoExtension.enmInitialStatus.WasCleared
      language: CSharp
      name:
        CSharp: WasCleared
        VB: WasCleared
      nameWithType:
        CSharp: FileInfoExtension.enmInitialStatus.WasCleared
        VB: FileInfoExtension.enmInitialStatus.WasCleared
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.enmInitialStatus.WasCleared
        VB: WizardWrx.FileInfoExtension.enmInitialStatus.WasCleared
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasCleared
        path: ../Core/FileInfoExtension.cs
        startLine: 140
      example: []
      syntax:
        content:
          CSharp: WasCleared = 1
          VB: WasCleared = 1
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nThe flag was initially in the Cleared state.\n"
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtension.enmInitialStatus.WasSet
      commentId: F:WizardWrx.FileInfoExtension.enmInitialStatus.WasSet
      language: CSharp
      name:
        CSharp: WasSet
        VB: WasSet
      nameWithType:
        CSharp: FileInfoExtension.enmInitialStatus.WasSet
        VB: FileInfoExtension.enmInitialStatus.WasSet
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtension.enmInitialStatus.WasSet
        VB: WizardWrx.FileInfoExtension.enmInitialStatus.WasSet
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtension.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WasSet
        path: ../Core/FileInfoExtension.cs
        startLine: 145
      example: []
      syntax:
        content:
          CSharp: WasSet = 2
          VB: WasSet = 2
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nThe flag was initially in the Set state.\n"
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.FileInfoExtensionMethods
    commentId: T:WizardWrx.FileInfoExtensionMethods
    language: CSharp
    name:
      CSharp: FileInfoExtensionMethods
      VB: FileInfoExtensionMethods
    nameWithType:
      CSharp: FileInfoExtensionMethods
      VB: FileInfoExtensionMethods
    qualifiedName:
      CSharp: WizardWrx.FileInfoExtensionMethods
      VB: WizardWrx.FileInfoExtensionMethods
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileInfoExtensionMethods.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: FileInfoExtensionMethods
      path: ../Core/FileInfoExtensionMethods.cs
      startLine: 109
    summary: "\nThe new extension methods that supersede the instance methods on the\ncompanion FileInfoExtension class go into a dedicated class, because a\nstatic class must expose them.\n"
    example: []
    syntax:
      content:
        CSharp: public static class FileInfoExtensionMethods
        VB: Public Module FileInfoExtensionMethods
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
      commentId: F:WizardWrx.FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
      language: CSharp
      name:
        CSharp: LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
        VB: LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
      nameWithType:
        CSharp: FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
        VB: FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
        VB: WizardWrx.FileInfoExtensionMethods.LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LENGTH_REPORTED_WHEN_FILE_NOT_FOUND
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 117
      summary: "\nUnless the specified file exists and is accessible via the current\nuser&apos;s security token, Windows throws a FileNotFoundException\nException. Rather than allow that to happen, this method reports its\nlength as -1, a patently invalid value for a file length.\n"
      example: []
      syntax:
        content:
          CSharp: public const int LENGTH_REPORTED_WHEN_FILE_NOT_FOUND = -1
          VB: Public Const LENGTH_REPORTED_WHEN_FILE_NOT_FOUND As Integer = -1
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeArchiveClear(FileInfo)
        VB: FileAttributeArchiveClear(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeArchiveClear(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeArchiveClear(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeArchiveClear
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 355
      summary: "\nClear the Archive FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeArchiveClear(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeArchiveClear(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Archive attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      language: CSharp
      name:
        CSharp: FileAttributeArchiveReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileAttributeArchiveReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeArchiveReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileInfoExtensionMethods.FileAttributeArchiveReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeArchiveReinstate
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 378
      summary: "\nReinstate the Archive flag on the specified file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeArchiveReinstate(this FileInfo pfi, FileInfoExtension.enmInitialStatus penmInitialStatus)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeArchiveReinstate(pfi As FileInfo, penmInitialStatus As FileInfoExtension.enmInitialStatus) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmInitialStatus
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nSpecify the FileInfoExtension.enmInitialStatus value returned by the last call to \nFileAttributeArchiveClear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Archive attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeArchiveSet(FileInfo)
        VB: FileAttributeArchiveSet(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeArchiveSet(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeArchiveSet(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeArchiveSet
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 406
      summary: "\nSet the Archive FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeArchiveSet(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeArchiveSet(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Archive attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeHiddenClear(FileInfo)
        VB: FileAttributeHiddenClear(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeHiddenClear(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeHiddenClear(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeHiddenClear
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 427
      summary: "\nClear the Hidden FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeHiddenClear(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeHiddenClear(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Hidden attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      language: CSharp
      name:
        CSharp: FileAttributeHiddeneReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileAttributeHiddeneReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeHiddeneReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileInfoExtensionMethods.FileAttributeHiddeneReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeHiddeneReinstate
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 450
      summary: "\nReinstate the Hidden flag on the specified file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeHiddeneReinstate(this FileInfo pfi, FileInfoExtension.enmInitialStatus penmInitialStatus)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeHiddeneReinstate(pfi As FileInfo, penmInitialStatus As FileInfoExtension.enmInitialStatus) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmInitialStatus
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nSpecify the FileInfoExtension.enmInitialStatus value returned by the last call to \nFileAttributeArchiveClear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Hidden attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeHiddenSet(FileInfo)
        VB: FileAttributeHiddenSet(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeHiddenSet(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeHiddenSet(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeHiddenSet
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 478
      summary: "\nSet the Hidden FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeHiddenSet(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeHiddenSet(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the Hidden attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeReadOnlyClear(FileInfo)
        VB: FileAttributeReadOnlyClear(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeReadOnlyClear(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeReadOnlyClear(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeReadOnlyClear
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 499
      summary: "\nClear the ReadOnly FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeReadOnlyClear(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeReadOnlyClear(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the ReadOnly attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      language: CSharp
      name:
        CSharp: FileAttributeReadOnlyReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileAttributeReadOnlyReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeReadOnlyReinstate
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 522
      summary: "\nReinstate the ReadOnly flag on the specified file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeReadOnlyReinstate(this FileInfo pfi, FileInfoExtension.enmInitialStatus penmInitialStatus)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeReadOnlyReinstate(pfi As FileInfo, penmInitialStatus As FileInfoExtension.enmInitialStatus) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmInitialStatus
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nSpecify the FileInfoExtension.enmInitialStatus value returned by the last call to \nFileAttributeArchiveClear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the ReadOnly attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeReadOnlySet(FileInfo)
        VB: FileAttributeReadOnlySet(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeReadOnlySet(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeReadOnlySet(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeReadOnlySet
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 550
      summary: "\nSet the ReadOnly FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeReadOnlySet(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeReadOnlySet(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the ReadOnly attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeSystemClear(FileInfo)
        VB: FileAttributeSystemClear(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeSystemClear(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeSystemClear(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeSystemClear
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 571
      summary: "\nClear the System FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeSystemClear(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeSystemClear(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the specified bit (It&apos;s usually just one.) is set on entry, the\nreturn value is WasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate(System.IO.FileInfo,WizardWrx.FileInfoExtension.enmInitialStatus)
      language: CSharp
      name:
        CSharp: FileAttributeSystemReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileAttributeSystemReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeSystemReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
        VB: FileInfoExtensionMethods.FileAttributeSystemReinstate(FileInfo, FileInfoExtension.enmInitialStatus)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate(System.IO.FileInfo, WizardWrx.FileInfoExtension.enmInitialStatus)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeSystemReinstate
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 594
      summary: "\nReinstate the System flag on the specified file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeSystemReinstate(this FileInfo pfi, FileInfoExtension.enmInitialStatus penmInitialStatus)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeSystemReinstate(pfi As FileInfo, penmInitialStatus As FileInfoExtension.enmInitialStatus) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmInitialStatus
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nSpecify the FileInfoExtension.enmInitialStatus value returned by the last call to \nFileAttributeArchiveClear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the System attribute is set on entry, the return value is\nWasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet(System.IO.FileInfo)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: FileAttributeSystemSet(FileInfo)
        VB: FileAttributeSystemSet(FileInfo)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeSystemSet(FileInfo)
        VB: FileInfoExtensionMethods.FileAttributeSystemSet(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet(System.IO.FileInfo)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet(System.IO.FileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeSystemSet
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 622
      summary: "\nSet the System FileAttributes on a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeSystemSet(this FileInfo pfi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeSystemSet(pfi As FileInfo) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the specified bit (It&apos;s usually just one.) is set on entry, the\nreturn value is WasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeClear(System.IO.FileInfo,System.IO.FileAttributes)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeClear(System.IO.FileInfo,System.IO.FileAttributes)
      language: CSharp
      name:
        CSharp: FileAttributeClear(FileInfo, FileAttributes)
        VB: FileAttributeClear(FileInfo, FileAttributes)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeClear(FileInfo, FileAttributes)
        VB: FileInfoExtensionMethods.FileAttributeClear(FileInfo, FileAttributes)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeClear(System.IO.FileInfo, System.IO.FileAttributes)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeClear(System.IO.FileInfo, System.IO.FileAttributes)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeClear
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 647
      summary: "\nClear the specified FileAttributes bit(s).\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeClear(this FileInfo pfi, FileAttributes penmFileAttributes)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeClear(pfi As FileInfo, penmFileAttributes As FileAttributes) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmFileAttributes
          type: System.IO.FileAttributes
          description: "\nThis argument specifies the member(s) of the FileAttributes bitwise\nenumeration to clear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the specified bit (It&apos;s usually just one.) is set on entry, the\nreturn value is WasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeClear*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.FileAttributeSet(System.IO.FileInfo,System.IO.FileAttributes)
      commentId: M:WizardWrx.FileInfoExtensionMethods.FileAttributeSet(System.IO.FileInfo,System.IO.FileAttributes)
      language: CSharp
      name:
        CSharp: FileAttributeSet(FileInfo, FileAttributes)
        VB: FileAttributeSet(FileInfo, FileAttributes)
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileAttributeSet(FileInfo, FileAttributes)
        VB: FileInfoExtensionMethods.FileAttributeSet(FileInfo, FileAttributes)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileAttributeSet(System.IO.FileInfo, System.IO.FileAttributes)
        VB: WizardWrx.FileInfoExtensionMethods.FileAttributeSet(System.IO.FileInfo, System.IO.FileAttributes)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileAttributeSet
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 680
      summary: "\nSet the specified FileAttributes bit(s).\n"
      example: []
      syntax:
        content:
          CSharp: public static FileInfoExtension.enmInitialStatus FileAttributeSet(this FileInfo pfi, FileAttributes penmFileAttributes)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function FileAttributeSet(pfi As FileInfo, penmFileAttributes As FileAttributes) As FileInfoExtension.enmInitialStatus
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nAs an extension method, the first argument must be a reference to\nthe instance that invoked it, which is used in much the same way as\nthe implicit this parameter that leads the list of parameters for a\ncall to any C# instance method.\n"
        - id: penmFileAttributes
          type: System.IO.FileAttributes
          description: "\nThis argument specifies the member(s) of the FileAttributes bitwise\nenumeration to clear.\n"
        return:
          type: WizardWrx.FileInfoExtension.enmInitialStatus
          description: "\nIf the specified bit (It&apos;s usually just one.) is set on entry, the\nreturn value is WasSet; otherwise, it is WasCleared.\n"
      overload: WizardWrx.FileInfoExtensionMethods.FileAttributeSet*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.FileInfoExtensionMethods.ShowFileDetails(System.IO.FileInfo,WizardWrx.FileInfoExtensionMethods.FileDetailsToShow,System.String,System.Boolean,System.Boolean)
      commentId: M:WizardWrx.FileInfoExtensionMethods.ShowFileDetails(System.IO.FileInfo,WizardWrx.FileInfoExtensionMethods.FileDetailsToShow,System.String,System.Boolean,System.Boolean)
      language: CSharp
      name:
        CSharp: ShowFileDetails(FileInfo, FileInfoExtensionMethods.FileDetailsToShow, String, Boolean, Boolean)
        VB: ShowFileDetails(FileInfo, FileInfoExtensionMethods.FileDetailsToShow, String, Boolean, Boolean)
      nameWithType:
        CSharp: FileInfoExtensionMethods.ShowFileDetails(FileInfo, FileInfoExtensionMethods.FileDetailsToShow, String, Boolean, Boolean)
        VB: FileInfoExtensionMethods.ShowFileDetails(FileInfo, FileInfoExtensionMethods.FileDetailsToShow, String, Boolean, Boolean)
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.ShowFileDetails(System.IO.FileInfo, WizardWrx.FileInfoExtensionMethods.FileDetailsToShow, System.String, System.Boolean, System.Boolean)
        VB: WizardWrx.FileInfoExtensionMethods.ShowFileDetails(System.IO.FileInfo, WizardWrx.FileInfoExtensionMethods.FileDetailsToShow, System.String, System.Boolean, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ShowFileDetails
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 742
      summary: "\nThis is a general-purpose method for reporting details about a file.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ShowFileDetails(this FileInfo pfi, FileInfoExtensionMethods.FileDetailsToShow penmFileDetailsToShow = FileInfoExtensionMethods.FileDetailsToShow.LocalTime | FileInfoExtensionMethods.FileDetailsToShow.UtcTime | FileInfoExtensionMethods.FileDetailsToShow.CreatedTime | FileInfoExtensionMethods.FileDetailsToShow.AccessedTime | FileInfoExtensionMethods.FileDetailsToShow.Size | FileInfoExtensionMethods.FileDetailsToShow.Attributes | FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc | FileInfoExtensionMethods.FileDetailsToShow.AllTimes | FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc | FileInfoExtensionMethods.FileDetailsToShow.Everything, string pstrLabel = null, bool pfPrefixWithNewline = false, bool pfSuffixWithNewline = false)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ShowFileDetails(pfi As FileInfo, penmFileDetailsToShow As FileInfoExtensionMethods.FileDetailsToShow = FileInfoExtensionMethods.FileDetailsToShow.LocalTime Or FileInfoExtensionMethods.FileDetailsToShow.UtcTime Or FileInfoExtensionMethods.FileDetailsToShow.CreatedTime Or FileInfoExtensionMethods.FileDetailsToShow.AccessedTime Or FileInfoExtensionMethods.FileDetailsToShow.Size Or FileInfoExtensionMethods.FileDetailsToShow.Attributes Or FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc Or FileInfoExtensionMethods.FileDetailsToShow.AllTimes Or FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc Or FileInfoExtensionMethods.FileDetailsToShow.Everything, pstrLabel As String = Nothing, pfPrefixWithNewline As Boolean = False, pfSuffixWithNewline As Boolean = False) As String
        parameters:
        - id: pfi
          type: System.IO.FileInfo
          description: "\nThe framework supplies a reference to the FileInfo instance with\nwhich the call is associated.\n"
        - id: penmFileDetailsToShow
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
          description: "\nUse one or more members of the FileDetailsToShow enumeration to\nspecify the details to display. The FileDetailsToShow enumeration is\na bit mask, and the enumeration defines the combinations that are\nmost likely to be useful as additional members.\n\nThe default value is FileDetailsToShow.Everything.\n"
        - id: pstrLabel
          type: System.String
          description: "\nThe label string is optional and, if specified, appears at the start\nof the returned string. String magic is thereafter employed to keep\nsubsequent lines of text aligned vertically.\n\nThe default value is NULL, which resolves internally to the empty\nstring.\n"
        - id: pfPrefixWithNewline
          type: System.Boolean
          description: "\nIf TRUE, the whole string begins with a platform-dependent newline.\nOtherwise, the string begins with the label specified by parameter\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrLabel</code>, if any, followed by the absolute file\nname.\n\nThe default value is FALSE.\n"
        - id: pfSuffixWithNewline
          type: System.Boolean
          description: "\nIf TRUE, the string is terminated with a platform-dependent newline.\nOtherwise, the string ends with the last value specified by the\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">penmFileDetailsToShow</code> bit mask.\n\nThe default value is FALSE.\n"
        return:
          type: System.String
          description: "\nThe return value is a human-readable multi-line report suitable for\ndisplay on a console log, event log, print file, or message box.\nWhen the file is absent, its length is reported as -1.\n"
      overload: WizardWrx.FileInfoExtensionMethods.ShowFileDetails*
      see:
      - linkType: HRef
        linkId: https://docs.microsoft.com/en-us/dotnet/api/system.io.fileinfo.length?view=netframework-4.8#System_IO_FileInfo_Length
        altText: https://docs.microsoft.com/en-us/dotnet/api/system.io.fileinfo.length?view=netframework-4.8#System_IO_FileInfo_Length
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
    commentId: T:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
    language: CSharp
    name:
      CSharp: FileInfoExtensionMethods.FileDetailsToShow
      VB: FileInfoExtensionMethods.FileDetailsToShow
    nameWithType:
      CSharp: FileInfoExtensionMethods.FileDetailsToShow
      VB: FileInfoExtensionMethods.FileDetailsToShow
    qualifiedName:
      CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileInfoExtensionMethods.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: FileDetailsToShow
      path: ../Core/FileInfoExtensionMethods.cs
      startLine: 122
    summary: "\nUse with ShowFileDetails parameter penmFileDetailsToShow.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Flags]

          public enum FileDetailsToShow : byte
        VB: >-
          <Flags>

          Public Enum FileDetailsToShow As Byte
    extensionMethods:
    - WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    attributes:
    - type: System.FlagsAttribute
      ctor: System.FlagsAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.None
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.None
      language: CSharp
      name:
        CSharp: None
        VB: None
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.None
        VB: FileInfoExtensionMethods.FileDetailsToShow.None
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.None
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.None
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: None
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 129
      summary: "\nShow only basic information: no UTC times, only LastWriteTime,\nand no Attributes.\n"
      example: []
      syntax:
        content:
          CSharp: None = 0
          VB: None = 0
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalTime
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalTime
      language: CSharp
      name:
        CSharp: LocalTime
        VB: LocalTime
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.LocalTime
        VB: FileInfoExtensionMethods.FileDetailsToShow.LocalTime
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalTime
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalTime
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LocalTime
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 134
      summary: "\nRender all times as Local.\n"
      example: []
      syntax:
        content:
          CSharp: LocalTime = 1
          VB: LocalTime = 1
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.UtcTime
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.UtcTime
      language: CSharp
      name:
        CSharp: UtcTime
        VB: UtcTime
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.UtcTime
        VB: FileInfoExtensionMethods.FileDetailsToShow.UtcTime
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.UtcTime
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.UtcTime
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: UtcTime
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 139
      summary: "\nRender all times as UTC.\n"
      example: []
      syntax:
        content:
          CSharp: UtcTime = 2
          VB: UtcTime = 2
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
      language: CSharp
      name:
        CSharp: CreatedTime
        VB: CreatedTime
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
        VB: FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.CreatedTime
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CreatedTime
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 144
      summary: "\nInclude the Created time.\n"
      example: []
      syntax:
        content:
          CSharp: CreatedTime = 4
          VB: CreatedTime = 4
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
      language: CSharp
      name:
        CSharp: AccessedTime
        VB: AccessedTime
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
        VB: FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AccessedTime
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AccessedTime
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 149
      summary: "\nInclude the Accessed time.\n"
      example: []
      syntax:
        content:
          CSharp: AccessedTime = 8
          VB: AccessedTime = 8
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Size
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Size
      language: CSharp
      name:
        CSharp: Size
        VB: Size
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.Size
        VB: FileInfoExtensionMethods.FileDetailsToShow.Size
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Size
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Size
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Size
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 154
      summary: "\nInclude the file size in bytes.\n"
      example: []
      syntax:
        content:
          CSharp: Size = 16
          VB: Size = 16
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Attributes
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Attributes
      language: CSharp
      name:
        CSharp: Attributes
        VB: Attributes
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.Attributes
        VB: FileInfoExtensionMethods.FileDetailsToShow.Attributes
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Attributes
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Attributes
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Attributes
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 160
      summary: "\nInclude the file attributes, both as a mask and as\nhuman-readable values.\n"
      example: []
      syntax:
        content:
          CSharp: Attributes = 32
          VB: Attributes = 32
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
      language: CSharp
      name:
        CSharp: LocalAndUtc
        VB: LocalAndUtc
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
        VB: FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.LocalAndUtc
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LocalAndUtc
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 165
      summary: "\nRender time stamps as both Local and UTC.\n"
      example: []
      syntax:
        content:
          CSharp: LocalAndUtc = 3
          VB: LocalAndUtc = 3
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimes
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimes
      language: CSharp
      name:
        CSharp: AllTimes
        VB: AllTimes
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.AllTimes
        VB: FileInfoExtensionMethods.FileDetailsToShow.AllTimes
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimes
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimes
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AllTimes
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 170
      summary: "\nReport all three time stamps.\n"
      example: []
      syntax:
        content:
          CSharp: AllTimes = 12
          VB: AllTimes = 12
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
      language: CSharp
      name:
        CSharp: AllTimesWithUtc
        VB: AllTimesWithUtc
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
        VB: FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.AllTimesWithUtc
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AllTimesWithUtc
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 175
      summary: "\nReport all times, showing both Local and UTC time stamps.\n"
      example: []
      syntax:
        content:
          CSharp: AllTimesWithUtc = 15
          VB: AllTimesWithUtc = 15
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Everything
      commentId: F:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Everything
      language: CSharp
      name:
        CSharp: Everything
        VB: Everything
      nameWithType:
        CSharp: FileInfoExtensionMethods.FileDetailsToShow.Everything
        VB: FileInfoExtensionMethods.FileDetailsToShow.Everything
      qualifiedName:
        CSharp: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Everything
        VB: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.Everything
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileInfoExtensionMethods.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Everything
        path: ../Core/FileInfoExtensionMethods.cs
        startLine: 180
      summary: "\nShow everything.\n"
      example: []
      syntax:
        content:
          CSharp: Everything = 63
          VB: Everything = 63
        return:
          type: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.FileNameTricks
    commentId: T:WizardWrx.FileNameTricks
    language: CSharp
    name:
      CSharp: FileNameTricks
      VB: FileNameTricks
    nameWithType:
      CSharp: FileNameTricks
      VB: FileNameTricks
    qualifiedName:
      CSharp: WizardWrx.FileNameTricks
      VB: WizardWrx.FileNameTricks
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileNameTricks.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: FileNameTricks
      path: ../Core/FileNameTricks.cs
      startLine: 148
    summary: "\nThis class exposes numerous static methods for manipulating file names.\nUnlike the objects in the System.File namespace, these methods don&apos;t \nneed a real file object. All work on strings that represent file names.\n"
    example: []
    syntax:
      content:
        CSharp: public static class FileNameTricks
        VB: Public Module FileNameTricks
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      language: CSharp
      name:
        CSharp: OS_EXTENSION_DELIM
        VB: OS_EXTENSION_DELIM
      nameWithType:
        CSharp: FileNameTricks.OS_EXTENSION_DELIM
        VB: FileNameTricks.OS_EXTENSION_DELIM
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
        VB: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OS_EXTENSION_DELIM
        path: ../Core/FileNameTricks.cs
        startLine: 185
      summary: "\nUse this to insert an extension delimiter into a file specification,\nsince there seems to be nothing in the System.IO namespace.\n"
      remarks: "\nStrangely, I haven&apos;t found a property that returns the extension delimiter.\n"
      example: []
      syntax:
        content:
          CSharp: public const char OS_EXTENSION_DELIM = '.'
          VB: Public Const OS_EXTENSION_DELIM As Char = "."c
        return:
          type: System.Char
      seealso:
      - linkId: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
        commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      - linkId: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
        commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER: 
        WizardWrx.FileNameTricks.UNC_SERVER_DELIM: 
        WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE: 
        WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE: 
    - id: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      language: CSharp
      name:
        CSharp: OS_WILD_CARD_MULTIPLE
        VB: OS_WILD_CARD_MULTIPLE
      nameWithType:
        CSharp: FileNameTricks.OS_WILD_CARD_MULTIPLE
        VB: FileNameTricks.OS_WILD_CARD_MULTIPLE
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
        VB: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OS_WILD_CARD_MULTIPLE
        path: ../Core/FileNameTricks.cs
        startLine: 199
      summary: "\n"
      remarks: "\nThere doesn&apos;t appear to be any provision for generating these from anything\nin the System.IO namespace.\n"
      example: []
      syntax:
        content:
          CSharp: public const char OS_WILD_CARD_MULTIPLE = '*'
          VB: Public Const OS_WILD_CARD_MULTIPLE As Char = "*"c
        return:
          type: System.Char
      seealso:
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      - linkId: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
        commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      - linkId: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
        commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      - linkId: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
        commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE: 
        WizardWrx.FileNameTricks.OS_EXTENSION_DELIM: 
        WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER: 
        WizardWrx.FileNameTricks.UNC_SERVER_DELIM: 
    - id: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      language: CSharp
      name:
        CSharp: OS_WILD_CARD_SINGLE
        VB: OS_WILD_CARD_SINGLE
      nameWithType:
        CSharp: FileNameTricks.OS_WILD_CARD_SINGLE
        VB: FileNameTricks.OS_WILD_CARD_SINGLE
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
        VB: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OS_WILD_CARD_SINGLE
        path: ../Core/FileNameTricks.cs
        startLine: 213
      summary: "\nUse this to insert a multiple-character wild card character into a\nWindows or Unix file name mask.\n"
      remarks: "\nThere doesn&apos;t appear to be any provision for generating these from anything\nin the System.IO namespace.\n"
      example: []
      syntax:
        content:
          CSharp: public const char OS_WILD_CARD_SINGLE = '?'
          VB: Public Const OS_WILD_CARD_SINGLE As Char = "?"c
        return:
          type: System.Char
      seealso:
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      - linkId: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
        commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      - linkId: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
        commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      - linkId: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
        commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE: 
        WizardWrx.FileNameTricks.OS_EXTENSION_DELIM: 
        WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER: 
        WizardWrx.FileNameTricks.UNC_SERVER_DELIM: 
    - id: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      language: CSharp
      name:
        CSharp: OS_DRIVE_PATH_DELIMITER
        VB: OS_DRIVE_PATH_DELIMITER
      nameWithType:
        CSharp: FileNameTricks.OS_DRIVE_PATH_DELIMITER
        VB: FileNameTricks.OS_DRIVE_PATH_DELIMITER
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
        VB: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OS_DRIVE_PATH_DELIMITER
        path: ../Core/FileNameTricks.cs
        startLine: 226
      summary: "\nAlong with the OS extension delimiter, the sequence of volume\nseparator, followed immediately by a directory separator, is\nundefined, though one could easily be constructed at run time,\nalthough such a construction wouldn&apos;t qualify as a constant.\n"
      example: []
      syntax:
        content:
          CSharp: public const string OS_DRIVE_PATH_DELIMITER = ":\\"
          VB: Public Const OS_DRIVE_PATH_DELIMITER As String = ":\"
        return:
          type: System.String
      seealso:
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      - linkId: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
        commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      - linkId: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
        commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE: 
        WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE: 
        WizardWrx.FileNameTricks.OS_EXTENSION_DELIM: 
        WizardWrx.FileNameTricks.UNC_SERVER_DELIM: 
    - id: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      language: CSharp
      name:
        CSharp: UNC_SERVER_DELIM
        VB: UNC_SERVER_DELIM
      nameWithType:
        CSharp: FileNameTricks.UNC_SERVER_DELIM
        VB: FileNameTricks.UNC_SERVER_DELIM
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
        VB: WizardWrx.FileNameTricks.UNC_SERVER_DELIM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: UNC_SERVER_DELIM
        path: ../Core/FileNameTricks.cs
        startLine: 236
      summary: "\nThe server delimiter string.\n"
      example: []
      syntax:
        content:
          CSharp: public const string UNC_SERVER_DELIM = "\\\\"
          VB: Public Const UNC_SERVER_DELIM As String = "\\"
        return:
          type: System.String
      seealso:
      - linkId: WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
        commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
      - linkId: WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
        commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
      - linkId: WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
        commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
      references:
        WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER: 
        WizardWrx.FileNameTricks.OS_EXTENSION_DELIM: 
        WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE: 
        WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE: 
    - id: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash(System.String)
      commentId: M:WizardWrx.FileNameTricks.EnsureHasTerminalBackslash(System.String)
      language: CSharp
      name:
        CSharp: EnsureHasTerminalBackslash(String)
        VB: EnsureHasTerminalBackslash(String)
      nameWithType:
        CSharp: FileNameTricks.EnsureHasTerminalBackslash(String)
        VB: FileNameTricks.EnsureHasTerminalBackslash(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash(System.String)
        VB: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnsureHasTerminalBackslash
        path: ../Core/FileNameTricks.cs
        startLine: 253
      summary: "\nEnsure that a path string has NO terminal backslash.\n"
      remarks: "\nThis method is deprecated. Use PathAddBackslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string EnsureHasTerminalBackslash(string pstrInputPath)
          VB: Public Shared Function EnsureHasTerminalBackslash(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed to HAVE a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash(System.String)
      commentId: M:WizardWrx.FileNameTricks.EnsureNoTerminalBackslash(System.String)
      language: CSharp
      name:
        CSharp: EnsureNoTerminalBackslash(String)
        VB: EnsureNoTerminalBackslash(String)
      nameWithType:
        CSharp: FileNameTricks.EnsureNoTerminalBackslash(String)
        VB: FileNameTricks.EnsureNoTerminalBackslash(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash(System.String)
        VB: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnsureNoTerminalBackslash
        path: ../Core/FileNameTricks.cs
        startLine: 272
      summary: "\nEnsure that a path string has a terminal backslash.\n"
      remarks: "\nThis method is deprecated. Use PathRemoveBackslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string EnsureNoTerminalBackslash(string pstrInputPath)
          VB: Public Shared Function EnsureNoTerminalBackslash(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed NOT to have a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathAddBackslash(System.String)
      commentId: M:WizardWrx.FileNameTricks.PathAddBackslash(System.String)
      language: CSharp
      name:
        CSharp: PathAddBackslash(String)
        VB: PathAddBackslash(String)
      nameWithType:
        CSharp: FileNameTricks.PathAddBackslash(String)
        VB: FileNameTricks.PathAddBackslash(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathAddBackslash(System.String)
        VB: WizardWrx.FileNameTricks.PathAddBackslash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathAddBackslash
        path: ../Core/FileNameTricks.cs
        startLine: 288
      summary: "\nEnsure that a path string has NO terminal backslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathAddBackslash(string pstrInputPath)
          VB: Public Shared Function PathAddBackslash(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed to HAVE a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.PathAddBackslash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1(System.String)
      commentId: M:WizardWrx.FileNameTricks.PathAddBackslashDeprecated1(System.String)
      language: CSharp
      name:
        CSharp: PathAddBackslashDeprecated1(String)
        VB: PathAddBackslashDeprecated1(String)
      nameWithType:
        CSharp: FileNameTricks.PathAddBackslashDeprecated1(String)
        VB: FileNameTricks.PathAddBackslashDeprecated1(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1(System.String)
        VB: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathAddBackslashDeprecated1
        path: ../Core/FileNameTricks.cs
        startLine: 312
      summary: "\nEnsure that a path string has NO terminal backslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathAddBackslashDeprecated1(string pstrInputPath)
          VB: Public Shared Function PathAddBackslashDeprecated1(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed to HAVE a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2(System.String)
      commentId: M:WizardWrx.FileNameTricks.PathAddBackslashDeprecated2(System.String)
      language: CSharp
      name:
        CSharp: PathAddBackslashDeprecated2(String)
        VB: PathAddBackslashDeprecated2(String)
      nameWithType:
        CSharp: FileNameTricks.PathAddBackslashDeprecated2(String)
        VB: FileNameTricks.PathAddBackslashDeprecated2(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2(System.String)
        VB: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathAddBackslashDeprecated2
        path: ../Core/FileNameTricks.cs
        startLine: 340
      summary: "\nEnsure that a path string has NO terminal backslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathAddBackslashDeprecated2(string pstrInputPath)
          VB: Public Shared Function PathAddBackslashDeprecated2(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed to HAVE a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathMakeRelative(System.String,System.String)
      commentId: M:WizardWrx.FileNameTricks.PathMakeRelative(System.String,System.String)
      language: CSharp
      name:
        CSharp: PathMakeRelative(String, String)
        VB: PathMakeRelative(String, String)
      nameWithType:
        CSharp: FileNameTricks.PathMakeRelative(String, String)
        VB: FileNameTricks.PathMakeRelative(String, String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathMakeRelative(System.String, System.String)
        VB: WizardWrx.FileNameTricks.PathMakeRelative(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathMakeRelative
        path: ../Core/FileNameTricks.cs
        startLine: 386
      summary: "\nGiven a path, such as the fully qualified name of a resource DLL, and\na second fully qualified name, such as that of the program directory\nor current working directory, compute a relative path to the first\nnamed path.\n"
      remarks: "\nThis method uses methods of the System.Uri class to perform its path\nmath, taking advantage of the fact that a path in the file system is\na valid URI.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathMakeRelative(string pstrFQPath, string pstrDirectoryRelativeTo)
          VB: Public Shared Function PathMakeRelative(pstrFQPath As String, pstrDirectoryRelativeTo As String) As String
        parameters:
        - id: pstrFQPath
          type: System.String
          description: "\nThis string is the fully qualified path for which a relative path is\nrequired. This string may be the name of a file or a directory, but\nit must exist in the file system.\n"
        - id: pstrDirectoryRelativeTo
          type: System.String
          description: "\nThis string is the fully qualified path relative to which a path to\npstrFQPath is required. This string may be the name of a file or a\ndirectory, but it must exist in the file system. Whether you supply\na file name or that of its directory, the outcome is the same, since\nthis has no effect on the relative path to pstrFQPath.\n"
        return:
          type: System.String
          description: "\nThe returned string is a relative path string, ready for use.\n"
      overload: WizardWrx.FileNameTricks.PathMakeRelative*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathRemoveBackslash(System.String)
      commentId: M:WizardWrx.FileNameTricks.PathRemoveBackslash(System.String)
      language: CSharp
      name:
        CSharp: PathRemoveBackslash(String)
        VB: PathRemoveBackslash(String)
      nameWithType:
        CSharp: FileNameTricks.PathRemoveBackslash(String)
        VB: FileNameTricks.PathRemoveBackslash(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathRemoveBackslash(System.String)
        VB: WizardWrx.FileNameTricks.PathRemoveBackslash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathRemoveBackslash
        path: ../Core/FileNameTricks.cs
        startLine: 500
      summary: "\nEnsure that a path string has a terminal backslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathRemoveBackslash(string pstrInputPath)
          VB: Public Shared Function PathRemoveBackslash(pstrInputPath As String) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString to evaluate and change if needed.\n"
        return:
          type: System.String
          description: "\nPath string that is guaranteed NOT to have a terminal backslash.\n"
      overload: WizardWrx.FileNameTricks.PathRemoveBackslash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      commentId: M:WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      language: CSharp
      name:
        CSharp: FileDirName(String, FileNameTricks.TerminaBackslash)
        VB: FileDirName(String, FileNameTricks.TerminaBackslash)
      nameWithType:
        CSharp: FileNameTricks.FileDirName(String, FileNameTricks.TerminaBackslash)
        VB: FileNameTricks.FileDirName(String, FileNameTricks.TerminaBackslash)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.FileDirName(System.String, WizardWrx.FileNameTricks.TerminaBackslash)
        VB: WizardWrx.FileNameTricks.FileDirName(System.String, WizardWrx.FileNameTricks.TerminaBackslash)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileDirName
        path: ../Core/FileNameTricks.cs
        startLine: 532
      summary: "\nExtract the directory name from a fully qualified file name.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FileDirName(string pstrFQFN, FileNameTricks.TerminaBackslash penmTerminaBackslash)
          VB: Public Shared Function FileDirName(pstrFQFN As String, penmTerminaBackslash As FileNameTricks.TerminaBackslash) As String
        parameters:
        - id: pstrFQFN
          type: System.String
          description: "\nString containing file name to evaluate.\n"
        - id: penmTerminaBackslash
          type: WizardWrx.FileNameTricks.TerminaBackslash
          description: "\nA member of the TerminaBackslash, which specifies whether the\nreturned string should have a terminal backslash.\n"
        return:
          type: System.String
          description: "\nIf the function succeeds, the return value is the directory name\nstripped of its file name.\n"
      overload: WizardWrx.FileNameTricks.FileDirName*
      see:
      - linkId: WizardWrx.FileNameTricks.TerminaBackslash
        commentId: T:WizardWrx.FileNameTricks.TerminaBackslash
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.FileNameTricks.TerminaBackslash: 
    - id: WizardWrx.FileNameTricks.FileExtn(System.String)
      commentId: M:WizardWrx.FileNameTricks.FileExtn(System.String)
      language: CSharp
      name:
        CSharp: FileExtn(String)
        VB: FileExtn(String)
      nameWithType:
        CSharp: FileNameTricks.FileExtn(String)
        VB: FileNameTricks.FileExtn(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.FileExtn(System.String)
        VB: WizardWrx.FileNameTricks.FileExtn(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FileExtn
        path: ../Core/FileNameTricks.cs
        startLine: 562
      summary: "\nGiven a string that contains a partially or fully qualified file\nname, return the extension, without the delimiting dot.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FileExtn(string pstrFQFN)
          VB: Public Shared Function FileExtn(pstrFQFN As String) As String
        parameters:
        - id: pstrFQFN
          type: System.String
          description: "\nFile name string to evaluate.\n"
        return:
          type: System.String
          description: "\nExtension, less the delimiting dot.\n"
      overload: WizardWrx.FileNameTricks.FileExtn*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.FQFBasename(System.String)
      commentId: M:WizardWrx.FileNameTricks.FQFBasename(System.String)
      language: CSharp
      name:
        CSharp: FQFBasename(String)
        VB: FQFBasename(String)
      nameWithType:
        CSharp: FileNameTricks.FQFBasename(String)
        VB: FileNameTricks.FQFBasename(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.FQFBasename(System.String)
        VB: WizardWrx.FileNameTricks.FQFBasename(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FQFBasename
        path: ../Core/FileNameTricks.cs
        startLine: 587
      summary: "\nExtract the fully qualified base name, that is, all but the\nextension, from a partially or fully qualified file name.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FQFBasename(string pstrFQFN)
          VB: Public Shared Function FQFBasename(pstrFQFN As String) As String
        parameters:
        - id: pstrFQFN
          type: System.String
          description: "\nFully or partially qualified file name to evaluate.\n"
        return:
          type: System.String
          description: "\nAll of pstrFQFN except its extension and extension delimiter.\n"
      overload: WizardWrx.FileNameTricks.FQFBasename*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.MakeFQFN(System.String,System.String)
      commentId: M:WizardWrx.FileNameTricks.MakeFQFN(System.String,System.String)
      language: CSharp
      name:
        CSharp: MakeFQFN(String, String)
        VB: MakeFQFN(String, String)
      nameWithType:
        CSharp: FileNameTricks.MakeFQFN(String, String)
        VB: FileNameTricks.MakeFQFN(String, String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.MakeFQFN(System.String, System.String)
        VB: WizardWrx.FileNameTricks.MakeFQFN(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MakeFQFN
        path: ../Core/FileNameTricks.cs
        startLine: 623
      summary: "\nGiven a file name and a default directory, which may be a null\nreference or an empty string, return a file name that is guaranteed\nto be fully qualified.\n"
      example: []
      syntax:
        content:
          CSharp: public static string MakeFQFN(string pstrUQFN, string pstrDefaultDir)
          VB: Public Shared Function MakeFQFN(pstrUQFN As String, pstrDefaultDir As String) As String
        parameters:
        - id: pstrUQFN
          type: System.String
          description: "\nString which is assumed to be a relative file name.\n"
        - id: pstrDefaultDir
          type: System.String
          description: "\nString to use as a default path, unless argument pstrUQFN is a fully\nqualified file name.\n\nIf this value is null, or an empty string, the current working\ndirectory is used.\n"
        return:
          type: System.String
          description: "\nString that contains a string that is guaranteed to represent a\nfully qualified file name.\n"
      overload: WizardWrx.FileNameTricks.MakeFQFN*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      commentId: M:WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      language: CSharp
      name:
        CSharp: PathFixup(String, FileNameTricks.TerminaBackslash)
        VB: PathFixup(String, FileNameTricks.TerminaBackslash)
      nameWithType:
        CSharp: FileNameTricks.PathFixup(String, FileNameTricks.TerminaBackslash)
        VB: FileNameTricks.PathFixup(String, FileNameTricks.TerminaBackslash)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.PathFixup(System.String, WizardWrx.FileNameTricks.TerminaBackslash)
        VB: WizardWrx.FileNameTricks.PathFixup(System.String, WizardWrx.FileNameTricks.TerminaBackslash)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PathFixup
        path: ../Core/FileNameTricks.cs
        startLine: 675
      summary: "\nOriginally a private method, this method returns a path (directory)\nname string that is guaranteed to meet the specified requirement,\nwith respect to presence or absence of a terminal backslash.\n"
      example: []
      syntax:
        content:
          CSharp: public static string PathFixup(string pstrInputPath, FileNameTricks.TerminaBackslash penmBackslash)
          VB: Public Shared Function PathFixup(pstrInputPath As String, penmBackslash As FileNameTricks.TerminaBackslash) As String
        parameters:
        - id: pstrInputPath
          type: System.String
          description: "\nString containing path (directory) name to evaluate.\n"
        - id: penmBackslash
          type: WizardWrx.FileNameTricks.TerminaBackslash
          description: "\nA member of the TerminaBackslash, which specifies whether the\nreturned string should have a terminal backslash.\n"
        return:
          type: System.String
          description: "\nPath (directory) name string that is guaranteed to either have, or\nomit, a terminal backslash, as specified.\n"
      overload: WizardWrx.FileNameTricks.PathFixup*
      see:
      - linkId: WizardWrx.FileNameTricks.TerminaBackslash
        commentId: T:WizardWrx.FileNameTricks.TerminaBackslash
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.FileNameTricks.TerminaBackslash: 
    - id: WizardWrx.FileNameTricks.UQFBasename(System.String)
      commentId: M:WizardWrx.FileNameTricks.UQFBasename(System.String)
      language: CSharp
      name:
        CSharp: UQFBasename(String)
        VB: UQFBasename(String)
      nameWithType:
        CSharp: FileNameTricks.UQFBasename(String)
        VB: FileNameTricks.UQFBasename(String)
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.UQFBasename(System.String)
        VB: WizardWrx.FileNameTricks.UQFBasename(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: UQFBasename
        path: ../Core/FileNameTricks.cs
        startLine: 707
      summary: "\nGiven a string that represents the name of a file, extract only the\nbase name (EXCLUDING the extension).\n"
      example: []
      syntax:
        content:
          CSharp: public static string UQFBasename(string pstrFQFN)
          VB: Public Shared Function UQFBasename(pstrFQFN As String) As String
        parameters:
        - id: pstrFQFN
          type: System.String
          description: "\nString to evaluate.\n"
        return:
          type: System.String
          description: "\nBase name extracted from string. This means the unqualified file\nname, less its directory and its extension.\n"
      overload: WizardWrx.FileNameTricks.UQFBasename*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.FileNameTricks.TerminaBackslash
    commentId: T:WizardWrx.FileNameTricks.TerminaBackslash
    language: CSharp
    name:
      CSharp: FileNameTricks.TerminaBackslash
      VB: FileNameTricks.TerminaBackslash
    nameWithType:
      CSharp: FileNameTricks.TerminaBackslash
      VB: FileNameTricks.TerminaBackslash
    qualifiedName:
      CSharp: WizardWrx.FileNameTricks.TerminaBackslash
      VB: WizardWrx.FileNameTricks.TerminaBackslash
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/FileNameTricks.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TerminaBackslash
      path: ../Core/FileNameTricks.cs
      startLine: 158
    summary: "\nUse a member of this enumeration with FileDirName and PathFixup, to\nspecify whether you want a path string with or without a trailing\nbackslash.\n"
    example: []
    syntax:
      content:
        CSharp: public enum TerminaBackslash
        VB: Public Enum TerminaBackslash
    see:
    - linkId: WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      commentId: M:WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
    - linkId: WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
      commentId: M:WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
    extensionMethods:
    - WizardWrx.FileNameTricks.TerminaBackslash.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.FileNameTricks.TerminaBackslash.Include
      commentId: F:WizardWrx.FileNameTricks.TerminaBackslash.Include
      language: CSharp
      name:
        CSharp: Include
        VB: Include
      nameWithType:
        CSharp: FileNameTricks.TerminaBackslash.Include
        VB: FileNameTricks.TerminaBackslash.Include
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.TerminaBackslash.Include
        VB: WizardWrx.FileNameTricks.TerminaBackslash.Include
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Include
        path: ../Core/FileNameTricks.cs
        startLine: 165
      summary: "\nInclude the trailing backslash, for example, if you intend to\nappend another string containing a relative path name or an\nunqualified file name.\n"
      example: []
      syntax:
        content:
          CSharp: Include = 0
          VB: Include = 0
        return:
          type: WizardWrx.FileNameTricks.TerminaBackslash
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.FileNameTricks.TerminaBackslash.Omit
      commentId: F:WizardWrx.FileNameTricks.TerminaBackslash.Omit
      language: CSharp
      name:
        CSharp: Omit
        VB: Omit
      nameWithType:
        CSharp: FileNameTricks.TerminaBackslash.Omit
        VB: FileNameTricks.TerminaBackslash.Omit
      qualifiedName:
        CSharp: WizardWrx.FileNameTricks.TerminaBackslash.Omit
        VB: WizardWrx.FileNameTricks.TerminaBackslash.Omit
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/FileNameTricks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Omit
        path: ../Core/FileNameTricks.cs
        startLine: 170
      summary: "\nExclude the trailing backslash, for example, if you intend to\ndisplay the name in an unambiguous context.\n"
      example: []
      syntax:
        content:
          CSharp: Omit = 1
          VB: Omit = 1
        return:
          type: WizardWrx.FileNameTricks.TerminaBackslash
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    references:
      WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash): 
      WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash): 
  - id: WizardWrx.GenericSingletonBase`1
    commentId: T:WizardWrx.GenericSingletonBase`1
    language: CSharp
    name:
      CSharp: GenericSingletonBase<T>
      VB: GenericSingletonBase(Of T)
    nameWithType:
      CSharp: GenericSingletonBase<T>
      VB: GenericSingletonBase(Of T)
    qualifiedName:
      CSharp: WizardWrx.GenericSingletonBase<T>
      VB: WizardWrx.GenericSingletonBase(Of T)
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/GenericSingletonBase.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: GenericSingletonBase
      path: ../Core/GenericSingletonBase.cs
      startLine: 178
    summary: "\nAbstract class GenericSingletonBase is a complete implementation of the\nSingleton design pattern that takes full advantage of the Microsoft .NET\nFramework. Please see the Remarks for further details.\n"
    remarks: "\nThe optimizations in this implementation take advantage of a guarantee\nmade by the framework that it won&apos;t bother to call a static constructor\non a class until its first use. Moreover, a static constructor is never\ncalled more than once, no matter how many subsequent references to the\nclass occur.\n\nTaking advantage of these features of the framework eliminates the need\nfor synchronization, and replaces a method call with a direct reference\nto the static read only property that returns a reference to the one and\nonly instance.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          public abstract class GenericSingletonBase<T>

              where T : GenericSingletonBase<T>
        VB: Public MustInherit Class GenericSingletonBase(Of T As GenericSingletonBase(Of T))
      typeParameters:
      - id: T
        description: "\nThis class uses a recursive constraint on T, to require it to be derived\nfrom this base class.\n"
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - abstract
      - class
      VB:
      - Public
      - MustInherit
      - Class
    items:
    - id: WizardWrx.GenericSingletonBase`1.#ctor
      commentId: M:WizardWrx.GenericSingletonBase`1.#ctor
      language: CSharp
      name:
        CSharp: GenericSingletonBase()
        VB: GenericSingletonBase()
      nameWithType:
        CSharp: GenericSingletonBase<T>.GenericSingletonBase()
        VB: GenericSingletonBase(Of T).GenericSingletonBase()
      qualifiedName:
        CSharp: WizardWrx.GenericSingletonBase<T>.GenericSingletonBase()
        VB: WizardWrx.GenericSingletonBase(Of T).GenericSingletonBase()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/GenericSingletonBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/GenericSingletonBase.cs
        startLine: 191
      summary: "\nThe private constructor has no real work to do, but it must exist to\nprevent the framework from generating a public constructor, which\nwould violate a critical constraint of the Singleton design pattern.\n"
      remarks: "\nThis property is marked protected to give derived classes direct\naccess to it, which their static members require. For example, in\nExceptionLogger, the static initializer has more work to do that it\ncannot start until an instance exists.\n"
      example: []
      syntax:
        content:
          CSharp: protected GenericSingletonBase()
          VB: Protected Sub New
      overload: WizardWrx.GenericSingletonBase`1.#ctor*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
      commentId: F:WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
      language: CSharp
      name:
        CSharp: s_genTheOnlyInstance
        VB: s_genTheOnlyInstance
      nameWithType:
        CSharp: GenericSingletonBase<T>.s_genTheOnlyInstance
        VB: GenericSingletonBase(Of T).s_genTheOnlyInstance
      qualifiedName:
        CSharp: WizardWrx.GenericSingletonBase<T>.s_genTheOnlyInstance
        VB: WizardWrx.GenericSingletonBase(Of T).s_genTheOnlyInstance
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/GenericSingletonBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: s_genTheOnlyInstance
        path: ../Core/GenericSingletonBase.cs
        startLine: 235
      summary: "\nThis static member holds the reference to the one and only instance\nof the derived class that is permitted.\n"
      remarks: "\nThis property is marked protected to give derived classes direct\naccess to it, which their static members require. For example, in\nExceptionLogger, the static initializer has more work to do that it\ncannot start until an instance exists.\n"
      example: []
      syntax:
        content:
          CSharp: protected static T s_genTheOnlyInstance
          VB: Protected Shared s_genTheOnlyInstance As T
        return:
          type: '{T}'
      modifiers:
        CSharp:
        - protected
        - static
        VB:
        - Protected
        - Shared
    - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
      commentId: P:WizardWrx.GenericSingletonBase`1.TheOnlyInstance
      language: CSharp
      name:
        CSharp: TheOnlyInstance
        VB: TheOnlyInstance
      nameWithType:
        CSharp: GenericSingletonBase<T>.TheOnlyInstance
        VB: GenericSingletonBase(Of T).TheOnlyInstance
      qualifiedName:
        CSharp: WizardWrx.GenericSingletonBase<T>.TheOnlyInstance
        VB: WizardWrx.GenericSingletonBase(Of T).TheOnlyInstance
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/GenericSingletonBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TheOnlyInstance
        path: ../Core/GenericSingletonBase.cs
        startLine: 248
      summary: "\nThis implementation simplifies access to the single instance by way\nof this static read-only property that returns the reference to the\ninstance stored in its one and only private static member.\n"
      remarks: "\nThe sweet thing about this implementation is that your code doesn&apos;t\nneed a copy of the reference, since a tail call on the static\nproperty is sufficient.\n"
      example: []
      syntax:
        content:
          CSharp: public static T TheOnlyInstance { get; }
          VB: Public Shared ReadOnly Property TheOnlyInstance As T
        parameters: []
        return:
          type: '{T}'
      overload: WizardWrx.GenericSingletonBase`1.TheOnlyInstance*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: WizardWrx.GenericSingletonBase`1.GetTheSingleInstance
      commentId: M:WizardWrx.GenericSingletonBase`1.GetTheSingleInstance
      language: CSharp
      name:
        CSharp: GetTheSingleInstance()
        VB: GetTheSingleInstance()
      nameWithType:
        CSharp: GenericSingletonBase<T>.GetTheSingleInstance()
        VB: GenericSingletonBase(Of T).GetTheSingleInstance()
      qualifiedName:
        CSharp: WizardWrx.GenericSingletonBase<T>.GetTheSingleInstance()
        VB: WizardWrx.GenericSingletonBase(Of T).GetTheSingleInstance()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/GenericSingletonBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetTheSingleInstance
        path: ../Core/GenericSingletonBase.cs
        startLine: 265
      summary: "\nImplement the traditional GetTheSingleInstance method for obtaining\na reference to a Singleton object.\n"
      example: []
      syntax:
        content:
          CSharp: public static T GetTheSingleInstance()
          VB: Public Shared Function GetTheSingleInstance As T
        return:
          type: '{T}'
          description: "\nThis method should always succeed by returning a reference to the\none and only instance of the derived class.\n"
      overload: WizardWrx.GenericSingletonBase`1.GetTheSingleInstance*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.ListHelpers
    commentId: T:WizardWrx.ListHelpers
    language: CSharp
    name:
      CSharp: ListHelpers
      VB: ListHelpers
    nameWithType:
      CSharp: ListHelpers
      VB: ListHelpers
    qualifiedName:
      CSharp: WizardWrx.ListHelpers
      VB: WizardWrx.ListHelpers
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ListHelpers.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ListHelpers
      path: ../Core/ListHelpers.cs
      startLine: 97
    summary: "\nThis class exposes methods for merging sorted lists of items, and to\nsimplify working with the values returned through the IComparable \ninterface.\n"
    example: []
    syntax:
      content:
        CSharp: public static class ListHelpers
        VB: Public Module ListHelpers
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.ListHelpers.CompareTwoOfAKind``1(``0,``0)
      commentId: M:WizardWrx.ListHelpers.CompareTwoOfAKind``1(``0,``0)
      language: CSharp
      name:
        CSharp: CompareTwoOfAKind<T>(T, T)
        VB: CompareTwoOfAKind(Of T)(T, T)
      nameWithType:
        CSharp: ListHelpers.CompareTwoOfAKind<T>(T, T)
        VB: ListHelpers.CompareTwoOfAKind(Of T)(T, T)
      qualifiedName:
        CSharp: WizardWrx.ListHelpers.CompareTwoOfAKind<T>(T, T)
        VB: WizardWrx.ListHelpers.CompareTwoOfAKind(Of T)(T, T)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ListHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CompareTwoOfAKind
        path: ../Core/ListHelpers.cs
        startLine: 207
      summary: "\nCompare two objects of a kind. See Remarks.\n"
      remarks: "\nThis method encapsulates the CompareTo method of a class T,\nreturning a member of the CompareResult enumeration in place of the\narbitrary zero or positive or negative integer specified in the\nIComparable interface. This syntactic sugar enables its return value\nto be processed by a switch block, rather than a nested IF block.\n\nWhether or not I wrote it into the this, calling CompareTo on a null\npReference object would elicit a NullReference exception. Having the\napplication throw the exception permits it to supply a more\ninformative message than the one that the CLR would have generated.\nFor a two-argument function, the generic message is ambiguous.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            public static ListHelpers.CompareResult CompareTwoOfAKind<T>(T pReference, T pComparand)

                where T : IComparable
          VB: Public Shared Function CompareTwoOfAKind(Of T As IComparable)(pReference As T, pComparand As T) As ListHelpers.CompareResult
        parameters:
        - id: pReference
          type: '{T}'
          description: "\nThe object against which to make the comparison.\n"
        - id: pComparand
          type: '{T}'
          description: "\nA second object of the same type against which to compare.\n"
        typeParameters:
        - id: T
          description: "\nBoth comparands must implement the IComparable interface.\n"
        return:
          type: WizardWrx.ListHelpers.CompareResult
          description: "\nThe return value is a member of the CompareResult enumeration, which\nreduces evaluation of results returned by the CompareTo method to a\nthree-case switch statement.\n"
      overload: WizardWrx.ListHelpers.CompareTwoOfAKind*
      exceptions:
      - type: System.NullReferenceException
        commentId: T:System.NullReferenceException
        description: "\nA NullReferenceException exception is thrown when pReference is null.\nThe CompareTo method of the object&apos;s IComparable interface is\nexpected to return a LessThan result when pComparand is null. See\nRemarks.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.NullReferenceException: 
    - id: WizardWrx.ListHelpers.MergeNewItemsIntoArray``1(``0[],``0[])
      commentId: M:WizardWrx.ListHelpers.MergeNewItemsIntoArray``1(``0[],``0[])
      language: CSharp
      name:
        CSharp: MergeNewItemsIntoArray<T>(T[], T[])
        VB: MergeNewItemsIntoArray(Of T)(T(), T())
      nameWithType:
        CSharp: ListHelpers.MergeNewItemsIntoArray<T>(T[], T[])
        VB: ListHelpers.MergeNewItemsIntoArray(Of T)(T(), T())
      qualifiedName:
        CSharp: WizardWrx.ListHelpers.MergeNewItemsIntoArray<T>(T[], T[])
        VB: WizardWrx.ListHelpers.MergeNewItemsIntoArray(Of T)(T(), T())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ListHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MergeNewItemsIntoArray
        path: ../Core/ListHelpers.cs
        startLine: 296
      summary: "\nMerge two sorted lists, returning a new sorted list containg the new\nor updated items from a second list. Please see Remarks.\n"
      remarks: "\nThe goal of this routine is to merge two lists, the first of which\nis treated as a master list, into which new and updated items from\nfrom the second list are merged.\n\nMerging is based on comparing items from both lists based on the\nvalues returned by their respective CompareTo methods. Values that\nreturn zero (equality) are merged by replacing the value from the\nfirst list, represented by the first argument (paMasterList) with\nthat from the second list, represented by the second argument\n(paNewItems).\n\nThis algorithm imposes four requirements on its inputs.\n\n1) Both input arrays must be composed of objects of the same type.\n\n2) That type must implement the IComparable interface.\n\n3) That type must have a default constructor.\n\n4) Both input arrays must be sorted.\n\nIn return, it makes the following four guarantees.\n\n1) Every item in array paNewItems will become part of the new list.\n\n2) Every item in array paMasterList that has no matching value in\narray paNewItems will become part of the new list.\n\n3) Every item in array paNewItems that matches an item in array\npaMasterList replaces that matching item.\n\n4) Every item in array paNewItems that doesn&apos;t match any item in\npaMasterList is added to the list.\n\nOn input, both lists must be sorted, which is the first reason that\nthe objects in the arrays must implement IComparable. The second\nreason is that this routine must compare the two lists in order to\nmerge them correctly. The comparison happens in CompareTwoOfAKind, a\ncompanion routine that also takes generics meeting the first of the\ntwo specified constraints.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            public static T[] MergeNewItemsIntoArray<T>(T[] paMasterList, T[] paNewItems)

                where T : IComparable, new()
          VB: Public Shared Function MergeNewItemsIntoArray(Of T As {IComparable, New})(paMasterList As T(), paNewItems As T()) As T()
        parameters:
        - id: paMasterList
          type: '{T}[]'
          description: "\nThis array is the master list. Items without matching items in list\npaNewItems are preserved. Please see Remarks.\n"
        - id: paNewItems
          type: '{T}[]'
          description: "\nAn item that matches an item in list paMasterList replaces it. An\nitem that doesn&apos;t match any existing item in list paMasterList is\nmerged into it. Please see Remarks.\n"
        typeParameters:
        - id: T
          description: "\nAll three lists (both inputs, paMasterList and paNewItems, and the\nreturned list) must contain objects of the same type, and that type\nmust implement the IComparable interface and have a parameterless\ndefault constructor.\n"
        return:
          type: '{T}[]'
          description: "\nThe returned list contains everything in list paNewItems, and\neverything in list paMasterList that has no matching item in list\npaMasterList. Please see Remarks. Since both input lists are sorted,\nthe new list is also sorted.\n"
      overload: WizardWrx.ListHelpers.MergeNewItemsIntoArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.ListHelpers.CompareResult
    commentId: T:WizardWrx.ListHelpers.CompareResult
    language: CSharp
    name:
      CSharp: ListHelpers.CompareResult
      VB: ListHelpers.CompareResult
    nameWithType:
      CSharp: ListHelpers.CompareResult
      VB: ListHelpers.CompareResult
    qualifiedName:
      CSharp: WizardWrx.ListHelpers.CompareResult
      VB: WizardWrx.ListHelpers.CompareResult
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ListHelpers.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: CompareResult
      path: ../Core/ListHelpers.cs
      startLine: 104
    summary: "\nThe CompareTwoOfAKind method returns a member of this enumeration,\nproviding for the CompareTo method of the IComparable interface that\nit encapsulates with a tad of syntactic sugar.\n"
    example: []
    syntax:
      content:
        CSharp: public enum CompareResult
        VB: Public Enum CompareResult
    extensionMethods:
    - WizardWrx.ListHelpers.CompareResult.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.ListHelpers.CompareResult.LessThan
      commentId: F:WizardWrx.ListHelpers.CompareResult.LessThan
      language: CSharp
      name:
        CSharp: LessThan
        VB: LessThan
      nameWithType:
        CSharp: ListHelpers.CompareResult.LessThan
        VB: ListHelpers.CompareResult.LessThan
      qualifiedName:
        CSharp: WizardWrx.ListHelpers.CompareResult.LessThan
        VB: WizardWrx.ListHelpers.CompareResult.LessThan
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ListHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LessThan
        path: ../Core/ListHelpers.cs
        startLine: 110
      summary: "\nSecond argument, pComparand, is less than the first argument,\npReference.\n"
      example: []
      syntax:
        content:
          CSharp: LessThan = 0
          VB: LessThan = 0
        return:
          type: WizardWrx.ListHelpers.CompareResult
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ListHelpers.CompareResult.EqualTo
      commentId: F:WizardWrx.ListHelpers.CompareResult.EqualTo
      language: CSharp
      name:
        CSharp: EqualTo
        VB: EqualTo
      nameWithType:
        CSharp: ListHelpers.CompareResult.EqualTo
        VB: ListHelpers.CompareResult.EqualTo
      qualifiedName:
        CSharp: WizardWrx.ListHelpers.CompareResult.EqualTo
        VB: WizardWrx.ListHelpers.CompareResult.EqualTo
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ListHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EqualTo
        path: ../Core/ListHelpers.cs
        startLine: 115
      summary: "\nBoth arguments are equal.\n"
      example: []
      syntax:
        content:
          CSharp: EqualTo = 1
          VB: EqualTo = 1
        return:
          type: WizardWrx.ListHelpers.CompareResult
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ListHelpers.CompareResult.GreaterThan
      commentId: F:WizardWrx.ListHelpers.CompareResult.GreaterThan
      language: CSharp
      name:
        CSharp: GreaterThan
        VB: GreaterThan
      nameWithType:
        CSharp: ListHelpers.CompareResult.GreaterThan
        VB: ListHelpers.CompareResult.GreaterThan
      qualifiedName:
        CSharp: WizardWrx.ListHelpers.CompareResult.GreaterThan
        VB: WizardWrx.ListHelpers.CompareResult.GreaterThan
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ListHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GreaterThan
        path: ../Core/ListHelpers.cs
        startLine: 121
      summary: "\nSecond argument, pComparand, is greater than the first argument,\npReference.\n"
      example: []
      syntax:
        content:
          CSharp: GreaterThan = 2
          VB: GreaterThan = 2
        return:
          type: WizardWrx.ListHelpers.CompareResult
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Logic
    commentId: T:WizardWrx.Logic
    language: CSharp
    name:
      CSharp: Logic
      VB: Logic
    nameWithType:
      CSharp: Logic
      VB: Logic
    qualifiedName:
      CSharp: WizardWrx.Logic
      VB: WizardWrx.Logic
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/Logic.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: Logic
      path: ../Core/Logic.cs
      startLine: 83
    summary: "\nThis sealed class exposes methods that encapsulate many common, tricky\nloop state tests.\n\nSince static classes are implicitly sealed, this class cannot be inherited.\n"
    example: []
    syntax:
      content:
        CSharp: public static class Logic
        VB: Public Module Logic
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsFirstForIteration(Int32, Int32)
        VB: IsFirstForIteration(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsFirstForIteration(Int32, Int32)
        VB: Logic.IsFirstForIteration(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsFirstForIteration(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsFirstForIteration(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsFirstForIteration
        path: ../Core/Logic.cs
        startLine: 110
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its first\niteration.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsFirstForIteration(int pintLoopIndex, int pintInitialValue)
          VB: Public Shared Function IsFirstForIteration(pintLoopIndex As Integer, pintInitialValue As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintInitialValue
          type: System.Int32
          description: "\nSpecify the integer initial value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index of a FOR loop is at its\ninitial value, indicating the first iteration of the loop.\n"
      overload: WizardWrx.Logic.IsFirstForIteration*
      seealso:
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsLastForIterationEQ(Int32, Int32)
        VB: IsLastForIterationEQ(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsLastForIterationEQ(Int32, Int32)
        VB: Logic.IsLastForIterationEQ(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsLastForIterationEQ(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsLastForIterationEQ(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsLastForIterationEQ
        path: ../Core/Logic.cs
        startLine: 145
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its last\niteration, given that the limit criterion is pintLoopIndex is\ngreater than pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsLastForIterationEQ(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function IsLastForIterationEQ(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the next increment of the loop index\nwould set one less than pintLimit, stopping the loop without another\niteration.\n"
      overload: WizardWrx.Logic.IsLastForIterationEQ*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsLastForIterationGE(Int32, Int32)
        VB: IsLastForIterationGE(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsLastForIterationGE(Int32, Int32)
        VB: Logic.IsLastForIterationGE(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsLastForIterationGE(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsLastForIterationGE(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsLastForIterationGE
        path: ../Core/Logic.cs
        startLine: 181
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its last\niteration, given that the limit criterion is pintLoopIndex is\ngreater than or equal to pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsLastForIterationGE(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function IsLastForIterationGE(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the next increment of the loop index\nwould set equal to pintLimit, stopping the loop without another\niteration.\n"
      overload: WizardWrx.Logic.IsLastForIterationGE*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsLastForIterationGT(Int32, Int32)
        VB: IsLastForIterationGT(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsLastForIterationGT(Int32, Int32)
        VB: Logic.IsLastForIterationGT(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsLastForIterationGT(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsLastForIterationGT(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsLastForIterationGT
        path: ../Core/Logic.cs
        startLine: 216
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its last\niteration, given that the limit criterion is pintLoopIndex is\ngreater than pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsLastForIterationGT(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function IsLastForIterationGT(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the next increment of the loop index\nwould set one less than pintLimit, stopping the loop without another\niteration.\n"
      overload: WizardWrx.Logic.IsLastForIterationGT*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsLastForIterationLE(Int32, Int32)
        VB: IsLastForIterationLE(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsLastForIterationLE(Int32, Int32)
        VB: Logic.IsLastForIterationLE(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsLastForIterationLE(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsLastForIterationLE(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsLastForIterationLE
        path: ../Core/Logic.cs
        startLine: 251
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its last\niteration, given that the limit criterion is pintLoopIndex is less\nthan or equal to pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsLastForIterationLE(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function IsLastForIterationLE(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the next increment of the loop index\nwould set it equal to pintLimit, stopping the loop without another\niteration.\n"
      overload: WizardWrx.Logic.IsLastForIterationLE*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsLastForIterationLT(Int32, Int32)
        VB: IsLastForIterationLT(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsLastForIterationLT(Int32, Int32)
        VB: Logic.IsLastForIterationLT(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsLastForIterationLT(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsLastForIterationLT(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsLastForIterationLT
        path: ../Core/Logic.cs
        startLine: 287
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on its last\niteration, given that the limit criterion is pintLoopIndex is less\nthan pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsLastForIterationLT(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function IsLastForIterationLT(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the next increment of the loop index\nwould set it equal to pintLimit, stopping the loop without another\niteration.\n"
      overload: WizardWrx.Logic.IsLastForIterationLT*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: IsNextForIteration(Int32, Int32)
        VB: IsNextForIteration(Int32, Int32)
      nameWithType:
        CSharp: Logic.IsNextForIteration(Int32, Int32)
        VB: Logic.IsNextForIteration(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.IsNextForIteration(System.Int32, System.Int32)
        VB: WizardWrx.Logic.IsNextForIteration(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: IsNextForIteration
        path: ../Core/Logic.cs
        startLine: 320
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex is on a\nsubsequent iteration.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool IsNextForIteration(int pintLoopIndex, int pintInitialValue)
          VB: Public Shared Function IsNextForIteration(pintLoopIndex As Integer, pintInitialValue As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintInitialValue
          type: System.Int32
          description: "\nSpecify the integer initial value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index of a FOR loop has passed its\ninitial value, indicating that it is on a subsequent iteration of\nthe loop.\n"
      overload: WizardWrx.Logic.IsNextForIteration*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: MoreForIterationsToComeEQ(Int32, Int32)
        VB: MoreForIterationsToComeEQ(Int32, Int32)
      nameWithType:
        CSharp: Logic.MoreForIterationsToComeEQ(Int32, Int32)
        VB: Logic.MoreForIterationsToComeEQ(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32, System.Int32)
        VB: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MoreForIterationsToComeEQ
        path: ../Core/Logic.cs
        startLine: 354
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex has one or more\niteration to go, given that the limit criterion is pintLoopIndex is\nequal to pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool MoreForIterationsToComeEQ(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function MoreForIterationsToComeEQ(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index and limit indicate that one\nor more iterations remain.\n"
      overload: WizardWrx.Logic.MoreForIterationsToComeEQ*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: MoreForIterationsToComeGE(Int32, Int32)
        VB: MoreForIterationsToComeGE(Int32, Int32)
      nameWithType:
        CSharp: Logic.MoreForIterationsToComeGE(Int32, Int32)
        VB: Logic.MoreForIterationsToComeGE(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32, System.Int32)
        VB: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MoreForIterationsToComeGE
        path: ../Core/Logic.cs
        startLine: 388
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex has one or more\niteration to go, given that the limit criterion is pintLoopIndex is\ngreater than or equal to pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool MoreForIterationsToComeGE(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function MoreForIterationsToComeGE(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index and limit indicate that one\nor more iterations remain.\n"
      overload: WizardWrx.Logic.MoreForIterationsToComeGE*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: MoreForIterationsToComeGT(Int32, Int32)
        VB: MoreForIterationsToComeGT(Int32, Int32)
      nameWithType:
        CSharp: Logic.MoreForIterationsToComeGT(Int32, Int32)
        VB: Logic.MoreForIterationsToComeGT(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32, System.Int32)
        VB: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MoreForIterationsToComeGT
        path: ../Core/Logic.cs
        startLine: 421
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex has one or more\niteration to go, given that the limit criterion is pintLoopIndex is\ngreater than pintLimit.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool MoreForIterationsToComeGT(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function MoreForIterationsToComeGT(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index and limit indicate that one\nor more iterations remain.\n"
      overload: WizardWrx.Logic.MoreForIterationsToComeGT*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: MoreForIterationsToComeLE(Int32, Int32)
        VB: MoreForIterationsToComeLE(Int32, Int32)
      nameWithType:
        CSharp: Logic.MoreForIterationsToComeLE(Int32, Int32)
        VB: Logic.MoreForIterationsToComeLE(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32, System.Int32)
        VB: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MoreForIterationsToComeLE
        path: ../Core/Logic.cs
        startLine: 458
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex has one or more\niteration to go, given that the limit criterion is pintLoopIndex is less\nthan or equal to pintLimit.\n"
      remarks: "\nSometimes, it is more sensible to test whether there are iterations\nremaining.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool MoreForIterationsToComeLE(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function MoreForIterationsToComeLE(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index and limit indicate that one\nor more iterations remain.\n"
      overload: WizardWrx.Logic.MoreForIterationsToComeLE*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: MoreForIterationsToComeLT(Int32, Int32)
        VB: MoreForIterationsToComeLT(Int32, Int32)
      nameWithType:
        CSharp: Logic.MoreForIterationsToComeLT(Int32, Int32)
        VB: Logic.MoreForIterationsToComeLT(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32, System.Int32)
        VB: WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MoreForIterationsToComeLT
        path: ../Core/Logic.cs
        startLine: 495
      summary: "\nReturn TRUE if the FOR loop driven by pintLoopIndex has one or more\niteration to go, given that the limit criterion is pintLoopIndex is less\nthan pintLimit.\n"
      remarks: "\nSometimes, it is more sensible to test whether there are iterations\nremaining.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool MoreForIterationsToComeLT(int pintLoopIndex, int pintLimit)
          VB: Public Shared Function MoreForIterationsToComeLT(pintLoopIndex As Integer, pintLimit As Integer) As Boolean
        parameters:
        - id: pintLoopIndex
          type: System.Int32
          description: "\nSpecify the integer loop index.\n"
        - id: pintLimit
          type: System.Int32
          description: "\nSpecify the integer limit value.\n"
        return:
          type: System.Boolean
          description: "\nThis function returns TRUE if the index and limit indicate that one\nor more iterations remain.\n"
      overload: WizardWrx.Logic.MoreForIterationsToComeLT*
      seealso:
      - linkId: WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
      - linkId: WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
        commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32): 
        WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32): 
        WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32): 
        WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32): 
    - id: WizardWrx.Logic.Unless(System.Boolean)
      commentId: M:WizardWrx.Logic.Unless(System.Boolean)
      language: CSharp
      name:
        CSharp: Unless(Boolean)
        VB: Unless(Boolean)
      nameWithType:
        CSharp: Logic.Unless(Boolean)
        VB: Logic.Unless(Boolean)
      qualifiedName:
        CSharp: WizardWrx.Logic.Unless(System.Boolean)
        VB: WizardWrx.Logic.Unless(System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/Logic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Unless
        path: ../Core/Logic.cs
        startLine: 523
      summary: "\nReturn the inverse of the truth value of an expression.\n"
      remarks: "\nI shamelessly borrowed this idiom from Perl, with full credit to\nLarry Wall, and implemented it as a macro for the C and C++ source\ncode preprocessors about a decade ago. I don&apos;t know why it&apos;s taken\nme this long to realize that it is equally easy to implement in C#,\nand the implementation is sufficiently small that the code optimizer\nwill almost certainly inline it, so that its performance impact is\nequivalent to the C/C++ macro.\n\nThe C# implementation is not quite as neat as the C/C++ macro.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool Unless(bool pfUnlessWhat)
          VB: Public Shared Function Unless(pfUnlessWhat As Boolean) As Boolean
        parameters:
        - id: pfUnlessWhat
          type: System.Boolean
          description: "\nSpecify the expression to invert.\n"
        return:
          type: System.Boolean
          description: "\nReturn TRUE if pfUnlessWhat is FALSE, and vice vers.\n"
      overload: WizardWrx.Logic.Unless*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.NumberFormatters
    commentId: T:WizardWrx.NumberFormatters
    language: CSharp
    name:
      CSharp: NumberFormatters
      VB: NumberFormatters
    nameWithType:
      CSharp: NumberFormatters
      VB: NumberFormatters
    qualifiedName:
      CSharp: WizardWrx.NumberFormatters
      VB: WizardWrx.NumberFormatters
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/NumberFormatters.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: NumberFormatters
      path: ../Core/NumberFormatters.cs
      startLine: 86
    summary: "\nThis static class exposes methods to further simplify formatting of\nintegers, floating point (single precision real numbers) and double\nprecision real numbers. For integers, these methods cover both decimal\nand the most frequently used hexadecimal representations, spanning from\ntwo through sixteen hexadecimal glyphs.\n"
    remarks: "\nSince everything returns a string, the values can be appended to arrays\nof format items to use as inputs to the most open-ended overload of the\nstring.Format method.\n"
    example: []
    syntax:
      content:
        CSharp: public static class NumberFormatters
        VB: Public Module NumberFormatters
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.NumberFormatters.DecimalNumber(System.Double,System.Int32)
      commentId: M:WizardWrx.NumberFormatters.DecimalNumber(System.Double,System.Int32)
      language: CSharp
      name:
        CSharp: DecimalNumber(Double, Int32)
        VB: DecimalNumber(Double, Int32)
      nameWithType:
        CSharp: NumberFormatters.DecimalNumber(Double, Int32)
        VB: NumberFormatters.DecimalNumber(Double, Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.DecimalNumber(System.Double, System.Int32)
        VB: WizardWrx.NumberFormatters.DecimalNumber(System.Double, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DecimalNumber
        path: ../Core/NumberFormatters.cs
        startLine: 103
      summary: "\nFormat any double precision number per the Regional Settings,\noverriding the digits past the decimal point to render a specified\nnumber of significant digits to the right of the decimal point.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DecimalNumber(double pdblDecimalNumber, int pintSignificantDigits)
          VB: Public Shared Function DecimalNumber(pdblDecimalNumber As Double, pintSignificantDigits As Integer) As String
        parameters:
        - id: pdblDecimalNumber
          type: System.Double
          description: "\nFloating point value to be formatted\n"
        - id: pintSignificantDigits
          type: System.Int32
          description: "\nNumber of significant digits to display\n"
        return:
          type: System.String
          description: "\nFloating point value, ready to display\n"
      overload: WizardWrx.NumberFormatters.DecimalNumber*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.DecimalNumber(System.Single,System.Int32)
      commentId: M:WizardWrx.NumberFormatters.DecimalNumber(System.Single,System.Int32)
      language: CSharp
      name:
        CSharp: DecimalNumber(Single, Int32)
        VB: DecimalNumber(Single, Int32)
      nameWithType:
        CSharp: NumberFormatters.DecimalNumber(Single, Int32)
        VB: NumberFormatters.DecimalNumber(Single, Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.DecimalNumber(System.Single, System.Int32)
        VB: WizardWrx.NumberFormatters.DecimalNumber(System.Single, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DecimalNumber
        path: ../Core/NumberFormatters.cs
        startLine: 122
      summary: "\nFormat any floating point number per the Regional Settings, \noverriding the digits past the decimal point to render a specified\nnumber of significant digits to the right of the decimal point.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DecimalNumber(float pfltDecimalNumber, int pintSignificantDigits)
          VB: Public Shared Function DecimalNumber(pfltDecimalNumber As Single, pintSignificantDigits As Integer) As String
        parameters:
        - id: pfltDecimalNumber
          type: System.Single
          description: "\nFloating point value to be formatted\n"
        - id: pintSignificantDigits
          type: System.Int32
          description: "\nNumber of significant digits to display\n"
        return:
          type: System.String
          description: "\nFloating point value, ready to display\n"
      overload: WizardWrx.NumberFormatters.DecimalNumber*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.DollarsAndCents(System.Double)
      commentId: M:WizardWrx.NumberFormatters.DollarsAndCents(System.Double)
      language: CSharp
      name:
        CSharp: DollarsAndCents(Double)
        VB: DollarsAndCents(Double)
      nameWithType:
        CSharp: NumberFormatters.DollarsAndCents(Double)
        VB: NumberFormatters.DollarsAndCents(Double)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.DollarsAndCents(System.Double)
        VB: WizardWrx.NumberFormatters.DollarsAndCents(System.Double)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DollarsAndCents
        path: ../Core/NumberFormatters.cs
        startLine: 141
      summary: "\nFormat any double precision number per the Regional Settings, \noverriding the digits past the decimal point to render dollars and\ncents.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DollarsAndCents(double pdblDollarsAndCents)
          VB: Public Shared Function DollarsAndCents(pdblDollarsAndCents As Double) As String
        parameters:
        - id: pdblDollarsAndCents
          type: System.Double
          description: "\nFloating point value to be formatted\n"
        return:
          type: System.String
          description: "\nFloating point value, ready to display\n"
      overload: WizardWrx.NumberFormatters.DollarsAndCents*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.DollarsAndCents(System.Single)
      commentId: M:WizardWrx.NumberFormatters.DollarsAndCents(System.Single)
      language: CSharp
      name:
        CSharp: DollarsAndCents(Single)
        VB: DollarsAndCents(Single)
      nameWithType:
        CSharp: NumberFormatters.DollarsAndCents(Single)
        VB: NumberFormatters.DollarsAndCents(Single)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.DollarsAndCents(System.Single)
        VB: WizardWrx.NumberFormatters.DollarsAndCents(System.Single)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DollarsAndCents
        path: ../Core/NumberFormatters.cs
        startLine: 157
      summary: "\nFormat any floating point number per the Regional Settings, \noverriding the digits past the decimal point to render dollars and\ncents.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DollarsAndCents(float pfltDollarsAndCents)
          VB: Public Shared Function DollarsAndCents(pfltDollarsAndCents As Single) As String
        parameters:
        - id: pfltDollarsAndCents
          type: System.Single
          description: "\nFloating point value to be formatted\n"
        return:
          type: System.String
          description: "\nFloating point value, ready to display\n"
      overload: WizardWrx.NumberFormatters.DollarsAndCents*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Hexadecimal2(System.Int32)
      commentId: M:WizardWrx.NumberFormatters.Hexadecimal2(System.Int32)
      language: CSharp
      name:
        CSharp: Hexadecimal2(Int32)
        VB: Hexadecimal2(Int32)
      nameWithType:
        CSharp: NumberFormatters.Hexadecimal2(Int32)
        VB: NumberFormatters.Hexadecimal2(Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Hexadecimal2(System.Int32)
        VB: WizardWrx.NumberFormatters.Hexadecimal2(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Hexadecimal2
        path: ../Core/NumberFormatters.cs
        startLine: 175
      summary: "\nFormat any integer to display as a minimum of two hexadecimal\n&quot;digits.&quot;\n"
      example: []
      syntax:
        content:
          CSharp: public static string Hexadecimal2(int pintAnyInteger)
          VB: Public Shared Function Hexadecimal2(pintAnyInteger As Integer) As String
        parameters:
        - id: pintAnyInteger
          type: System.Int32
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Hexadecimal2*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Hexadecimal4(System.Int32)
      commentId: M:WizardWrx.NumberFormatters.Hexadecimal4(System.Int32)
      language: CSharp
      name:
        CSharp: Hexadecimal4(Int32)
        VB: Hexadecimal4(Int32)
      nameWithType:
        CSharp: NumberFormatters.Hexadecimal4(Int32)
        VB: NumberFormatters.Hexadecimal4(Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Hexadecimal4(System.Int32)
        VB: WizardWrx.NumberFormatters.Hexadecimal4(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Hexadecimal4
        path: ../Core/NumberFormatters.cs
        startLine: 192
      summary: "\nFormat any integer to display as a minimum of four hexadecimal\n&quot;digits.&quot;\n"
      example: []
      syntax:
        content:
          CSharp: public static string Hexadecimal4(int pintAnyInteger)
          VB: Public Shared Function Hexadecimal4(pintAnyInteger As Integer) As String
        parameters:
        - id: pintAnyInteger
          type: System.Int32
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Hexadecimal4*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Hexadecimal8(System.Int32)
      commentId: M:WizardWrx.NumberFormatters.Hexadecimal8(System.Int32)
      language: CSharp
      name:
        CSharp: Hexadecimal8(Int32)
        VB: Hexadecimal8(Int32)
      nameWithType:
        CSharp: NumberFormatters.Hexadecimal8(Int32)
        VB: NumberFormatters.Hexadecimal8(Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Hexadecimal8(System.Int32)
        VB: WizardWrx.NumberFormatters.Hexadecimal8(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Hexadecimal8
        path: ../Core/NumberFormatters.cs
        startLine: 209
      summary: "\nFormat any integer to display as a minimum of eight hexadecimal\n&quot;digits.&quot;\n"
      example: []
      syntax:
        content:
          CSharp: public static string Hexadecimal8(int pintAnyInteger)
          VB: Public Shared Function Hexadecimal8(pintAnyInteger As Integer) As String
        parameters:
        - id: pintAnyInteger
          type: System.Int32
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Hexadecimal8*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Hexadecimal16(System.Int64)
      commentId: M:WizardWrx.NumberFormatters.Hexadecimal16(System.Int64)
      language: CSharp
      name:
        CSharp: Hexadecimal16(Int64)
        VB: Hexadecimal16(Int64)
      nameWithType:
        CSharp: NumberFormatters.Hexadecimal16(Int64)
        VB: NumberFormatters.Hexadecimal16(Int64)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Hexadecimal16(System.Int64)
        VB: WizardWrx.NumberFormatters.Hexadecimal16(System.Int64)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Hexadecimal16
        path: ../Core/NumberFormatters.cs
        startLine: 226
      summary: "\nFormat any long integer to display as a minimum of sixteen hexadecimal\n&quot;digits.&quot;\n"
      example: []
      syntax:
        content:
          CSharp: public static string Hexadecimal16(long plngAnyInteger)
          VB: Public Shared Function Hexadecimal16(plngAnyInteger As Long) As String
        parameters:
        - id: plngAnyInteger
          type: System.Int64
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Hexadecimal16*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Integer(System.Int32)
      commentId: M:WizardWrx.NumberFormatters.Integer(System.Int32)
      language: CSharp
      name:
        CSharp: Integer(Int32)
        VB: Integer(Int32)
      nameWithType:
        CSharp: NumberFormatters.Integer(Int32)
        VB: NumberFormatters.Integer(Int32)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Integer(System.Int32)
        VB: WizardWrx.NumberFormatters.Integer(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Integer
        path: ../Core/NumberFormatters.cs
        startLine: 246
      summary: "\nFormat any integer per the Regional Settings, overriding the digits\npast the decimal point to render an integer.\n"
      example: []
      syntax:
        content:
          CSharp: public static string Integer(int pintAnyInteger)
          VB: Public Shared Function Integer(pintAnyInteger As Integer) As String
        parameters:
        - id: pintAnyInteger
          type: System.Int32
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Integer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.NumberFormatters.Integer(System.Int64)
      commentId: M:WizardWrx.NumberFormatters.Integer(System.Int64)
      language: CSharp
      name:
        CSharp: Integer(Int64)
        VB: Integer(Int64)
      nameWithType:
        CSharp: NumberFormatters.Integer(Int64)
        VB: NumberFormatters.Integer(Int64)
      qualifiedName:
        CSharp: WizardWrx.NumberFormatters.Integer(System.Int64)
        VB: WizardWrx.NumberFormatters.Integer(System.Int64)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/NumberFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Integer
        path: ../Core/NumberFormatters.cs
        startLine: 261
      summary: "\nFormat any long integer per the Regional Settings, overriding the\ndigits past the decimal point to render an long integer.\n"
      example: []
      syntax:
        content:
          CSharp: public static string Integer(long plngAnyInteger)
          VB: Public Shared Function Integer(plngAnyInteger As Long) As String
        parameters:
        - id: plngAnyInteger
          type: System.Int64
          description: "\nInteger to be formatted\n"
        return:
          type: System.String
          description: "\nFormatted integer, ready to display\n"
      overload: WizardWrx.NumberFormatters.Integer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.RecoveredException
    commentId: T:WizardWrx.RecoveredException
    language: CSharp
    name:
      CSharp: RecoveredException
      VB: RecoveredException
    nameWithType:
      CSharp: RecoveredException
      VB: RecoveredException
    qualifiedName:
      CSharp: WizardWrx.RecoveredException
      VB: WizardWrx.RecoveredException
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/RecoveredException.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: RecoveredException
      path: ../Core/RecoveredException.cs
      startLine: 76
    summary: "\nOverride the Exception class, so that the Source, StackTrace, and\nTargetSite properties can be directly initialized.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class RecoveredException : Exception, ISerializable, _Exception'
        VB: >-
          Public Class RecoveredException

              Inherits Exception

              Implements ISerializable, _Exception
    inheritance:
    - System.Object
    - System.Exception
    implements:
    - System.Runtime.Serialization.ISerializable
    - System.Runtime.InteropServices._Exception
    inheritedMembers:
    - System.Exception.GetBaseException
    - System.Exception.ToString
    - System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    - System.Exception.GetType
    - System.Exception.Message
    - System.Exception.Data
    - System.Exception.InnerException
    - System.Exception.HelpLink
    - System.Exception.HResult
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.RecoveredException.#ctor(System.String,System.String,System.String,System.String)
      commentId: M:WizardWrx.RecoveredException.#ctor(System.String,System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: RecoveredException(String, String, String, String)
        VB: RecoveredException(String, String, String, String)
      nameWithType:
        CSharp: RecoveredException.RecoveredException(String, String, String, String)
        VB: RecoveredException.RecoveredException(String, String, String, String)
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.RecoveredException(System.String, System.String, System.String, System.String)
        VB: WizardWrx.RecoveredException.RecoveredException(System.String, System.String, System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/RecoveredException.cs
        startLine: 131
      summary: "\nCall this method when you have only a message to record.\n"
      example: []
      syntax:
        content:
          CSharp: public RecoveredException(string message, string Source, string StackTrace, string TargetSite)
          VB: Public Sub New(message As String, Source As String, StackTrace As String, TargetSite As String)
        parameters:
        - id: message
          type: System.String
          description: "\nThe usual message property, available to all Exception consumers\n"
        - id: Source
          type: System.String
          description: ''
        - id: StackTrace
          type: System.String
          description: "\nGets a string representation of the immediate frames on the call stack\n"
        - id: TargetSite
          type: System.String
          description: "\nGets the method that throws the current exception\n"
      overload: WizardWrx.RecoveredException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.RecoveredException.#ctor(System.String,System.Exception,System.String,System.String,System.String)
      commentId: M:WizardWrx.RecoveredException.#ctor(System.String,System.Exception,System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: RecoveredException(String, Exception, String, String, String)
        VB: RecoveredException(String, Exception, String, String, String)
      nameWithType:
        CSharp: RecoveredException.RecoveredException(String, Exception, String, String, String)
        VB: RecoveredException.RecoveredException(String, Exception, String, String, String)
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.RecoveredException(System.String, System.Exception, System.String, System.String, System.String)
        VB: WizardWrx.RecoveredException.RecoveredException(System.String, System.Exception, System.String, System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/RecoveredException.cs
        startLine: 162
      summary: "\nCall this method when you have an InnerException Exception to preserve.\n"
      example: []
      syntax:
        content:
          CSharp: public RecoveredException(string message, Exception innerException, string Source, string StackTrace, string TargetSite)
          VB: Public Sub New(message As String, innerException As Exception, Source As String, StackTrace As String, TargetSite As String)
        parameters:
        - id: message
          type: System.String
          description: "\nThe usual message property, available to all Exception consumers\n"
        - id: innerException
          type: System.Exception
          description: "\nThe usual InnerException property, available to all Exception consumers\n"
        - id: Source
          type: System.String
          description: ''
        - id: StackTrace
          type: System.String
          description: "\nGets a string representation of the immediate frames on the call stack\n"
        - id: TargetSite
          type: System.String
          description: "\nGets the method that throws the current exception\n"
      overload: WizardWrx.RecoveredException.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.RecoveredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      commentId: M:WizardWrx.RecoveredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
      language: CSharp
      name:
        CSharp: RecoveredException(SerializationInfo, StreamingContext)
        VB: RecoveredException(SerializationInfo, StreamingContext)
      nameWithType:
        CSharp: RecoveredException.RecoveredException(SerializationInfo, StreamingContext)
        VB: RecoveredException.RecoveredException(SerializationInfo, StreamingContext)
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.RecoveredException(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
        VB: WizardWrx.RecoveredException.RecoveredException(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/RecoveredException.cs
        startLine: 189
      summary: "\nEnable serialization by implementing the protected constructor that\ncan recreate an exception from serialization data.\n"
      example: []
      syntax:
        content:
          CSharp: protected RecoveredException(SerializationInfo info, StreamingContext context)
          VB: Protected Sub New(info As SerializationInfo, context As StreamingContext)
        parameters:
        - id: info
          type: System.Runtime.Serialization.SerializationInfo
          description: "\nSpecify the SerializationInfo object from which to reconstruct the\nRecoveredException.\n"
        - id: context
          type: System.Runtime.Serialization.StreamingContext
          description: "\nSpecify the StreamingContext object from which to reconstruct the\nRecoveredException.\n"
      overload: WizardWrx.RecoveredException.#ctor*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.RecoveredException.Source
      commentId: P:WizardWrx.RecoveredException.Source
      language: CSharp
      name:
        CSharp: Source
        VB: Source
      nameWithType:
        CSharp: RecoveredException.Source
        VB: RecoveredException.Source
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.Source
        VB: WizardWrx.RecoveredException.Source
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Source
        path: ../Core/RecoveredException.cs
        startLine: 258
      summary: "\nThis is a stand-in for the Source property that is usually set\nby the runtime environment when an exception is thrown.\n"
      example: []
      syntax:
        content:
          CSharp: public override string Source { get; }
          VB: Public Overrides ReadOnly Property Source As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.RecoveredException.Source*
      overridden: System.Exception.Source
      modifiers:
        CSharp:
        - public
        - override
        - get
        VB:
        - Public
        - Overrides
        - ReadOnly
    - id: WizardWrx.RecoveredException.StackTrace
      commentId: P:WizardWrx.RecoveredException.StackTrace
      language: CSharp
      name:
        CSharp: StackTrace
        VB: StackTrace
      nameWithType:
        CSharp: RecoveredException.StackTrace
        VB: RecoveredException.StackTrace
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.StackTrace
        VB: WizardWrx.RecoveredException.StackTrace
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: StackTrace
        path: ../Core/RecoveredException.cs
        startLine: 265
      summary: "\nThis is a stand-in for the StackTrace property that is usually set\nby the runtime environment when an exception is thrown.\n"
      example: []
      syntax:
        content:
          CSharp: public string StackTrace { get; set; }
          VB: Public Property StackTrace As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.RecoveredException.StackTrace*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.RecoveredException.TargetSite
      commentId: P:WizardWrx.RecoveredException.TargetSite
      language: CSharp
      name:
        CSharp: TargetSite
        VB: TargetSite
      nameWithType:
        CSharp: RecoveredException.TargetSite
        VB: RecoveredException.TargetSite
      qualifiedName:
        CSharp: WizardWrx.RecoveredException.TargetSite
        VB: WizardWrx.RecoveredException.TargetSite
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/RecoveredException.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TargetSite
        path: ../Core/RecoveredException.cs
        startLine: 275
      summary: "\nThis is a stand-in for the TargetSite property that is usually set\nby the runtime environment when an exception is thrown.\n"
      example: []
      syntax:
        content:
          CSharp: public string TargetSite { get; set; }
          VB: Public Property TargetSite As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.RecoveredException.TargetSite*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
  - id: WizardWrx.ReportDetail
    commentId: T:WizardWrx.ReportDetail
    language: CSharp
    name:
      CSharp: ReportDetail
      VB: ReportDetail
    nameWithType:
      CSharp: ReportDetail
      VB: ReportDetail
    qualifiedName:
      CSharp: WizardWrx.ReportDetail
      VB: WizardWrx.ReportDetail
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportDetail.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ReportDetail
      path: ../Core/ReportDetail.cs
      startLine: 148
    summary: "\nInstances of this class are generic report details, with labels and\nformats for printing them.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class ReportDetail : IComparable'
        VB: >-
          Public Class ReportDetail

              Implements IComparable
    inheritance:
    - System.Object
    implements:
    - System.IComparable
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.ReportDetail.DEFAULT_FORMAT
      commentId: F:WizardWrx.ReportDetail.DEFAULT_FORMAT
      language: CSharp
      name:
        CSharp: DEFAULT_FORMAT
        VB: DEFAULT_FORMAT
      nameWithType:
        CSharp: ReportDetail.DEFAULT_FORMAT
        VB: ReportDetail.DEFAULT_FORMAT
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DEFAULT_FORMAT
        VB: WizardWrx.ReportDetail.DEFAULT_FORMAT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DEFAULT_FORMAT
        path: ../Core/ReportDetail.cs
        startLine: 290
      summary: "\nUse this format for reports, unless the caller overrides it.\n"
      example: []
      syntax:
        content:
          CSharp: public const string DEFAULT_FORMAT = "{0} = {1}"
          VB: Public Const DEFAULT_FORMAT As String = "{0} = {1}"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.THROW_ON_INVALID_STATE
      commentId: F:WizardWrx.ReportDetail.THROW_ON_INVALID_STATE
      language: CSharp
      name:
        CSharp: THROW_ON_INVALID_STATE
        VB: THROW_ON_INVALID_STATE
      nameWithType:
        CSharp: ReportDetail.THROW_ON_INVALID_STATE
        VB: ReportDetail.THROW_ON_INVALID_STATE
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.THROW_ON_INVALID_STATE
        VB: WizardWrx.ReportDetail.THROW_ON_INVALID_STATE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: THROW_ON_INVALID_STATE
        path: ../Core/ReportDetail.cs
        startLine: 297
      summary: "\nWhen the FormatDetail method is called before the object is fully\ninitialized, throw an System.InvalidOperationException exception.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool THROW_ON_INVALID_STATE = true
          VB: Public Const THROW_ON_INVALID_STATE As Boolean = True
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.RETURN_ON_INVALID_STATE
      commentId: F:WizardWrx.ReportDetail.RETURN_ON_INVALID_STATE
      language: CSharp
      name:
        CSharp: RETURN_ON_INVALID_STATE
        VB: RETURN_ON_INVALID_STATE
      nameWithType:
        CSharp: ReportDetail.RETURN_ON_INVALID_STATE
        VB: ReportDetail.RETURN_ON_INVALID_STATE
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.RETURN_ON_INVALID_STATE
        VB: WizardWrx.ReportDetail.RETURN_ON_INVALID_STATE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RETURN_ON_INVALID_STATE
        path: ../Core/ReportDetail.cs
        startLine: 309
      summary: "\nWhen the FormatDetail method is called before the object is fully\ninitialized, return an error message. Since the returned value is\nexpected to go into a file of some kind (which may be a print file),\nthis is a much cheaper way of handling the exception. However, as is\nalmost always true, there is a cost, because throwing an exception\ntypically causes the application to return a nonzero exit code, but\nwriting it into a file yields an exit code of zero.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool RETURN_ON_INVALID_STATE = false
          VB: Public Const RETURN_ON_INVALID_STATE As Boolean = False
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.ThrowOnInvalidState
      commentId: P:WizardWrx.ReportDetail.ThrowOnInvalidState
      language: CSharp
      name:
        CSharp: ThrowOnInvalidState
        VB: ThrowOnInvalidState
      nameWithType:
        CSharp: ReportDetail.ThrowOnInvalidState
        VB: ReportDetail.ThrowOnInvalidState
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ThrowOnInvalidState
        VB: WizardWrx.ReportDetail.ThrowOnInvalidState
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ThrowOnInvalidState
        path: ../Core/ReportDetail.cs
        startLine: 325
      summary: "\nThe state of this flag determines what happens when FormatDetail is\ncalled when the object is partially initialized.\n\nThe default action, False (RETURN_ON_INVALID_STATE) is the behavior\noriginally programmed into it.\n\nWhen set to True, (THROW_ON_INVALID_STATE), the message that would\nhave been returned becomes the Message property of an \nSystem.InvalidOperationException exception.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool ThrowOnInvalidState { get; set; }
          VB: Public Shared Property ThrowOnInvalidState As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.ReportDetail.ThrowOnInvalidState*
      modifiers:
        CSharp:
        - public
        - static
        - get
        - set
        VB:
        - Public
        - Shared
    - id: WizardWrx.ReportDetail.LabelChanged
      commentId: E:WizardWrx.ReportDetail.LabelChanged
      language: CSharp
      name:
        CSharp: LabelChanged
        VB: LabelChanged
      nameWithType:
        CSharp: ReportDetail.LabelChanged
        VB: ReportDetail.LabelChanged
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.LabelChanged
        VB: WizardWrx.ReportDetail.LabelChanged
      type: Event
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LabelChanged
        path: ../Core/ReportDetail.cs
        startLine: 389
      summary: "\nDelegates register here.\n"
      example: []
      syntax:
        content:
          CSharp: public event EventHandler LabelChanged
          VB: Public Event LabelChanged As EventHandler
        return:
          type: System.EventHandler
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.OnLabelChanged(WizardWrx.ReportDetail.LabelChangedEventArgs)
      commentId: M:WizardWrx.ReportDetail.OnLabelChanged(WizardWrx.ReportDetail.LabelChangedEventArgs)
      language: CSharp
      name:
        CSharp: OnLabelChanged(ReportDetail.LabelChangedEventArgs)
        VB: OnLabelChanged(ReportDetail.LabelChangedEventArgs)
      nameWithType:
        CSharp: ReportDetail.OnLabelChanged(ReportDetail.LabelChangedEventArgs)
        VB: ReportDetail.OnLabelChanged(ReportDetail.LabelChangedEventArgs)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.OnLabelChanged(WizardWrx.ReportDetail.LabelChangedEventArgs)
        VB: WizardWrx.ReportDetail.OnLabelChanged(WizardWrx.ReportDetail.LabelChangedEventArgs)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OnLabelChanged
        path: ../Core/ReportDetail.cs
        startLine: 400
      summary: "\nRaise this event to signal listeners that the length of the label\nchanged.\n"
      example: []
      syntax:
        content:
          CSharp: protected virtual void OnLabelChanged(ReportDetail.LabelChangedEventArgs e)
          VB: Protected Overridable Sub OnLabelChanged(e As ReportDetail.LabelChangedEventArgs)
        parameters:
        - id: e
          type: WizardWrx.ReportDetail.LabelChangedEventArgs
          description: "\nThe LabelChangedEventArgs method is populated with the new and old\nlabel length, so that only the difference is added to the total.\n"
      overload: WizardWrx.ReportDetail.OnLabelChanged*
      modifiers:
        CSharp:
        - protected
        - virtual
        VB:
        - Protected
        - Overridable
    - id: WizardWrx.ReportDetail.#ctor
      commentId: M:WizardWrx.ReportDetail.#ctor
      language: CSharp
      name:
        CSharp: ReportDetail()
        VB: ReportDetail()
      nameWithType:
        CSharp: ReportDetail.ReportDetail()
        VB: ReportDetail.ReportDetail()
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail()
        VB: WizardWrx.ReportDetail.ReportDetail()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 412
      summary: "\nThe default constructor creates an empty ReportDetail.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail()
          VB: Public Sub New
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String)
        VB: ReportDetail(String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String)
        VB: ReportDetail.ReportDetail(String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 425
      summary: "\nCreate a ReportDetail, and set its Label property.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label)
          VB: Public Sub New(label As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      language: CSharp
      name:
        CSharp: ReportDetail(String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail(String, ReportDetail.ItemDisplayOrder)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 444
      summary: "\nCreate a ReportDetail, and set its Label and DisplayOrder\nproperties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, ReportDetail.ItemDisplayOrder itemdisplayorder)
          VB: Public Sub New(label As String, itemdisplayorder As ReportDetail.ItemDisplayOrder)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail(String, ReportDetail.ItemDisplayOrder, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 469
      summary: "\nCreate a ReportDetail, and set its Label, DisplayOrder, and \nDisplayFormat, and SupplementaryDetails properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat)
          VB: Public Sub New(label As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      language: CSharp
      name:
        CSharp: ReportDetail(String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail(String, ReportDetail.ItemDisplayOrder, String, Object())
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail.ReportDetail(String, ReportDetail.ItemDisplayOrder, String, Object())
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object[])
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 499
      summary: "\nCreate a ReportDetail, and set its Label, DisplayOrder, \nDisplayFormat properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat, object[] supplementarydetails)
          VB: Public Sub New(label As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String, supplementarydetails As Object())
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
        - id: supplementarydetails
          type: System.Object[]
          description: "\nOverride the default SupplementaryDetails property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object)
        VB: ReportDetail(String, Object)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object)
        VB: ReportDetail.ReportDetail(String, Object)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 524
      summary: "\nCreate a ReportDetail, and set its Label and Value properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object pobjValue)
          VB: Public Sub New(label As String, pobjValue As Object)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: pobjValue
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 548
      summary: "\nCreate a ReportDetail, and set its Label and Value properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object value, ReportDetail.ItemDisplayOrder itemdisplayorder)
          VB: Public Sub New(label As String, value As Object, itemdisplayorder As ReportDetail.ItemDisplayOrder)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: value
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 578
      summary: "\nCreate a ReportDetail, and set its Label, Value, DisplayOrder, and\nDisplayFormat properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object value, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat)
          VB: Public Sub New(label As String, value As Object, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: value
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String, Object())
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail.ReportDetail(String, Object, ReportDetail.ItemDisplayOrder, String, Object())
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object[])
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 613
      summary: "\nCreate a ReportDetail, and set its Label, Value, DisplayOrder,\nDisplayFormat, and SupplementaryDetails properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object value, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat, object[] supplementarydetails)
          VB: Public Sub New(label As String, value As Object, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String, supplementarydetails As Object())
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: value
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
        - id: supplementarydetails
          type: System.Object[]
          description: "\nOverride the default SupplementaryDetails property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, String)
        VB: ReportDetail(String, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, String)
        VB: ReportDetail.ReportDetail(String, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 638
      summary: "\nCreate a ReportDetail, and set its Label and DisplayValue properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, string displayvalue)
          VB: Public Sub New(label As String, displayvalue As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      language: CSharp
      name:
        CSharp: ReportDetail(String, String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail(String, String, ReportDetail.ItemDisplayOrder)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 663
      summary: "\nCreate a ReportDetail, and set its Label and DisplayValue properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder)
          VB: Public Sub New(label As String, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 694
      summary: "\nCreate a ReportDetail, and set its Label, DisplayValue,\nDisplayOrder, and DisplayFormat properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat)
          VB: Public Sub New(label As String, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      language: CSharp
      name:
        CSharp: ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String, Object())
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail.ReportDetail(String, String, ReportDetail.ItemDisplayOrder, String, Object())
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object[])
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 730
      summary: "\nCreate a ReportDetail, and set its Label, DisplayValue,\nDisplayOrder, DisplayFormat, and SupplementaryDetails properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat, object[] supplementarydetails)
          VB: Public Sub New(label As String, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String, supplementarydetails As Object())
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
        - id: supplementarydetails
          type: System.Object[]
          description: "\nOverride the default SupplementaryDetails property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, String)
        VB: ReportDetail(String, Object, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, String)
        VB: ReportDetail.ReportDetail(String, Object, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 759
      summary: "\nCreate a ReportDetail, and set its Label. native value, and\nDisplayValue properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object pobjValue, string displayvalue)
          VB: Public Sub New(label As String, pobjValue As Object, displayvalue As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: pobjValue
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder)
        VB: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 790
      summary: "\nCreate a ReportDetail, and set its Label. native value, \nDisplayValue, and DisplayOrder properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object pobjValue, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder)
          VB: Public Sub New(label As String, pobjValue As Object, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: pobjValue
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String)
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String)
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String)
        VB: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 826
      summary: "\nCreate a ReportDetail, and set its Label. native value, \nDisplayValue, DisplayOrder, and DisplayFormat properties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object pobjValue, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat)
          VB: Public Sub New(label As String, pobjValue As Object, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String)
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: pobjValue
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      commentId: M:WizardWrx.ReportDetail.#ctor(System.String,System.Object,System.String,WizardWrx.ReportDetail.ItemDisplayOrder,System.String,System.Object[])
      language: CSharp
      name:
        CSharp: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String, Object())
      nameWithType:
        CSharp: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String, Object[])
        VB: ReportDetail.ReportDetail(String, Object, String, ReportDetail.ItemDisplayOrder, String, Object())
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object[])
        VB: WizardWrx.ReportDetail.ReportDetail(System.String, System.Object, System.String, WizardWrx.ReportDetail.ItemDisplayOrder, System.String, System.Object())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 868
      summary: "\nCreate a ReportDetail, and set its Label. native value, \nDisplayValue, DisplayOrder, DisplayFormat, and SupplementaryDetails\nproperties.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail(string label, object pobjValue, string displayvalue, ReportDetail.ItemDisplayOrder itemdisplayorder, string displayformat, object[] supplementarydetails)
          VB: Public Sub New(label As String, pobjValue As Object, displayvalue As String, itemdisplayorder As ReportDetail.ItemDisplayOrder, displayformat As String, supplementarydetails As Object())
        parameters:
        - id: label
          type: System.String
          description: "\nInitial value for label, which can be neither null, nor empty.\n"
        - id: pobjValue
          type: System.Object
          description: "\nInitial data value, as an Object, which MAY be a null reference.\n"
        - id: displayvalue
          type: System.String
          description: "\nInitial string representation of data value, which MAY be a null\nreference or an empty string.\n"
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nDisplayOrder must be greater than zero.\n"
        - id: displayformat
          type: System.String
          description: "\nOverride the default DisplayFormat property.\n"
        - id: supplementarydetails
          type: System.Object[]
          description: "\nOverride the default SupplementaryDetails property.\n"
      overload: WizardWrx.ReportDetail.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.DetailState
      commentId: P:WizardWrx.ReportDetail.DetailState
      language: CSharp
      name:
        CSharp: DetailState
        VB: DetailState
      nameWithType:
        CSharp: ReportDetail.DetailState
        VB: ReportDetail.DetailState
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DetailState
        VB: WizardWrx.ReportDetail.DetailState
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DetailState
        path: ../Core/ReportDetail.cs
        startLine: 891
      summary: "\nReport on the state of the instance, for evaluating its readiness\nfor use on a report.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail.State DetailState { get; }
          VB: Public ReadOnly Property DetailState As ReportDetail.State
        parameters: []
        return:
          type: WizardWrx.ReportDetail.State
      overload: WizardWrx.ReportDetail.DetailState*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetail.DisplayFormat
      commentId: P:WizardWrx.ReportDetail.DisplayFormat
      language: CSharp
      name:
        CSharp: DisplayFormat
        VB: DisplayFormat
      nameWithType:
        CSharp: ReportDetail.DisplayFormat
        VB: ReportDetail.DisplayFormat
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DisplayFormat
        VB: WizardWrx.ReportDetail.DisplayFormat
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DisplayFormat
        path: ../Core/ReportDetail.cs
        startLine: 917
      summary: "\nGet or set the default format string to use with the label and value\nto display an item on a report. See remarks for critical\ninformation.\n"
      remarks: "\nThe first three format items, {0}, {1}, and {2} are reserved for the\nlabel, value, and item number. Additional format items, if any, are\npopulated from the objects in the SupplementaryDetails array.\n\nThe FormatDetail method creates a new object array with enough room\nto hold the SupplementaryDetails array, plus three, fills it by\ninserting the label, value, and item number into the first three\nslots, and appending the SupplementaryDetails array, if it exists,\nand passes the whole array to string.Format.\n\nUnless its value differs from the current static (default) value,\nthis property stays NULL. When callers query this property, the\nstatic property is returned if the instance property is null. Hence,\nthe property behaves like a instance property, without wasting space\nto store duplicates of the default value. Hence, output routines\nneed not check both properties.\n"
      example: []
      syntax:
        content:
          CSharp: public string DisplayFormat { get; set; }
          VB: Public Property DisplayFormat As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.ReportDetail.DisplayFormat*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetail.SupplementaryDetails
      commentId: P:WizardWrx.ReportDetail.SupplementaryDetails
      language: CSharp
      name:
        CSharp: SupplementaryDetails
        VB: SupplementaryDetails
      nameWithType:
        CSharp: ReportDetail.SupplementaryDetails
        VB: ReportDetail.SupplementaryDetails
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.SupplementaryDetails
        VB: WizardWrx.ReportDetail.SupplementaryDetails
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SupplementaryDetails
        path: ../Core/ReportDetail.cs
        startLine: 942
      summary: "\nThis property gives read/write access to the SupplementaryDetails\nproperty, an array of Objects for use with the DisplayFormat\nproperty. See remarks for critical information.\n"
      example: []
      syntax:
        content:
          CSharp: public object[] SupplementaryDetails { get; set; }
          VB: Public Property SupplementaryDetails As Object()
        parameters: []
        return:
          type: System.Object[]
      overload: WizardWrx.ReportDetail.SupplementaryDetails*
      seealso:
      - linkId: WizardWrx.ReportDetail.DisplayFormat
        commentId: P:WizardWrx.ReportDetail.DisplayFormat
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
      references:
        WizardWrx.ReportDetail.DisplayFormat: 
    - id: WizardWrx.ReportDetail.DisplayOrder
      commentId: P:WizardWrx.ReportDetail.DisplayOrder
      language: CSharp
      name:
        CSharp: DisplayOrder
        VB: DisplayOrder
      nameWithType:
        CSharp: ReportDetail.DisplayOrder
        VB: ReportDetail.DisplayOrder
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DisplayOrder
        VB: WizardWrx.ReportDetail.DisplayOrder
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DisplayOrder
        path: ../Core/ReportDetail.cs
        startLine: 974
      summary: "\nGet or set the unsigned integer that determines the order in which\nthis item is returned from a sorted collection.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetail.ItemDisplayOrder DisplayOrder { get; set; }
          VB: Public Property DisplayOrder As ReportDetail.ItemDisplayOrder
        parameters: []
        return:
          type: WizardWrx.ReportDetail.ItemDisplayOrder
      overload: WizardWrx.ReportDetail.DisplayOrder*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetail.DisplayValue
      commentId: P:WizardWrx.ReportDetail.DisplayValue
      language: CSharp
      name:
        CSharp: DisplayValue
        VB: DisplayValue
      nameWithType:
        CSharp: ReportDetail.DisplayValue
        VB: ReportDetail.DisplayValue
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DisplayValue
        VB: WizardWrx.ReportDetail.DisplayValue
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DisplayValue
        path: ../Core/ReportDetail.cs
        startLine: 994
      summary: "\nGet or set the string representation of data value, which MAY be a \nnull reference or an empty string.\n"
      example: []
      syntax:
        content:
          CSharp: public string DisplayValue { get; set; }
          VB: Public Property DisplayValue As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.ReportDetail.DisplayValue*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetail.Label
      commentId: P:WizardWrx.ReportDetail.Label
      language: CSharp
      name:
        CSharp: Label
        VB: Label
      nameWithType:
        CSharp: ReportDetail.Label
        VB: ReportDetail.Label
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.Label
        VB: WizardWrx.ReportDetail.Label
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Label
        path: ../Core/ReportDetail.cs
        startLine: 1009
      summary: "\nNew value for label, which can be neither null, nor empty.\n"
      example: []
      syntax:
        content:
          CSharp: public string Label { get; set; }
          VB: Public Property Label As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.ReportDetail.Label*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetail.Value
      commentId: P:WizardWrx.ReportDetail.Value
      language: CSharp
      name:
        CSharp: Value
        VB: Value
      nameWithType:
        CSharp: ReportDetail.Value
        VB: ReportDetail.Value
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.Value
        VB: WizardWrx.ReportDetail.Value
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Value
        path: ../Core/ReportDetail.cs
        startLine: 1054
      summary: "\nGets or sets the data value, as an Object, which MAY be a null\nreference.\n\nPlease see Remarks for important details.\n"
      remarks: "\nTo make the class a tad more robust, if the rhe property is null,\nthe DisplayValue is returned, unless it is also null. This gets\naround an ambiguity that causes the constructor to put a String into\nthe DisplayValue property, unless it is downcast to Object.\n"
      example: []
      syntax:
        content:
          CSharp: public object Value { get; set; }
          VB: Public Property Value As Object
        parameters: []
        return:
          type: System.Object
      overload: WizardWrx.ReportDetail.Value*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetail.FormatDetail
      commentId: M:WizardWrx.ReportDetail.FormatDetail
      language: CSharp
      name:
        CSharp: FormatDetail()
        VB: FormatDetail()
      nameWithType:
        CSharp: ReportDetail.FormatDetail()
        VB: ReportDetail.FormatDetail()
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.FormatDetail()
        VB: WizardWrx.ReportDetail.FormatDetail()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDetail
        path: ../Core/ReportDetail.cs
        startLine: 1084
      summary: "\nReturn a formatted detail record, ready to print.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatDetail()
          VB: Public Function FormatDetail As String
        return:
          type: System.String
          description: "\nThe return value is a formatted string, if a label and value are\npresent. Otherwise, an error message is returned for printing.\n"
      overload: WizardWrx.ReportDetail.FormatDetail*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.FormatDetail(System.UInt32)
      commentId: M:WizardWrx.ReportDetail.FormatDetail(System.UInt32)
      language: CSharp
      name:
        CSharp: FormatDetail(UInt32)
        VB: FormatDetail(UInt32)
      nameWithType:
        CSharp: ReportDetail.FormatDetail(UInt32)
        VB: ReportDetail.FormatDetail(UInt32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.FormatDetail(System.UInt32)
        VB: WizardWrx.ReportDetail.FormatDetail(System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDetail
        path: ../Core/ReportDetail.cs
        startLine: 1110
      summary: "\nReturn a formatted detail record, ready to print.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatDetail(uint puintWidthOfWidestLabel)
          VB: Public Function FormatDetail(puintWidthOfWidestLabel As UInteger) As String
        parameters:
        - id: puintWidthOfWidestLabel
          type: System.UInt32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that can be fed directly to a WriteLine\nmethod.\n"
      overload: WizardWrx.ReportDetail.FormatDetail*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.FormatDetail(System.UInt32,System.UInt32)
      commentId: M:WizardWrx.ReportDetail.FormatDetail(System.UInt32,System.UInt32)
      language: CSharp
      name:
        CSharp: FormatDetail(UInt32, UInt32)
        VB: FormatDetail(UInt32, UInt32)
      nameWithType:
        CSharp: ReportDetail.FormatDetail(UInt32, UInt32)
        VB: ReportDetail.FormatDetail(UInt32, UInt32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.FormatDetail(System.UInt32, System.UInt32)
        VB: WizardWrx.ReportDetail.FormatDetail(System.UInt32, System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDetail
        path: ../Core/ReportDetail.cs
        startLine: 1140
      summary: "\nReturn a formatted detail record, ready to print.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatDetail(uint puintWidthOfWidestLabel, uint puintTotalitems)
          VB: Public Function FormatDetail(puintWidthOfWidestLabel As UInteger, puintTotalitems As UInteger) As String
        parameters:
        - id: puintWidthOfWidestLabel
          type: System.UInt32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        - id: puintTotalitems
          type: System.UInt32
          description: "\nSpecify the total number of items in the list, which becomes part of\nthe third format item, {2}, in the detail item format string.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that can be fed directly to a WriteLine\nmethod.\n"
      overload: WizardWrx.ReportDetail.FormatDetail*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.FormatDetail(System.Int32)
      commentId: M:WizardWrx.ReportDetail.FormatDetail(System.Int32)
      language: CSharp
      name:
        CSharp: FormatDetail(Int32)
        VB: FormatDetail(Int32)
      nameWithType:
        CSharp: ReportDetail.FormatDetail(Int32)
        VB: ReportDetail.FormatDetail(Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.FormatDetail(System.Int32)
        VB: WizardWrx.ReportDetail.FormatDetail(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDetail
        path: ../Core/ReportDetail.cs
        startLine: 1168
      summary: "\nReturn a formatted detail record, ready to print.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatDetail(int pintWidthOfWidestLabel)
          VB: Public Function FormatDetail(pintWidthOfWidestLabel As Integer) As String
        parameters:
        - id: pintWidthOfWidestLabel
          type: System.Int32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that can be fed directly to a WriteLine\nmethod.\n"
      overload: WizardWrx.ReportDetail.FormatDetail*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.FormatDetail(System.Int32,System.UInt32)
      commentId: M:WizardWrx.ReportDetail.FormatDetail(System.Int32,System.UInt32)
      language: CSharp
      name:
        CSharp: FormatDetail(Int32, UInt32)
        VB: FormatDetail(Int32, UInt32)
      nameWithType:
        CSharp: ReportDetail.FormatDetail(Int32, UInt32)
        VB: ReportDetail.FormatDetail(Int32, UInt32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.FormatDetail(System.Int32, System.UInt32)
        VB: WizardWrx.ReportDetail.FormatDetail(System.Int32, System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDetail
        path: ../Core/ReportDetail.cs
        startLine: 1198
      summary: "\nReturn a formatted detail record, ready to print.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatDetail(int pintWidthOfWidestLabel, uint puintTotalitems)
          VB: Public Function FormatDetail(pintWidthOfWidestLabel As Integer, puintTotalitems As UInteger) As String
        parameters:
        - id: pintWidthOfWidestLabel
          type: System.Int32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        - id: puintTotalitems
          type: System.UInt32
          description: "\nSpecify the total number of items in the list, which becomes part of\nthe third format item, {2}, in the detail item format string.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that can be fed directly to a WriteLine\nmethod.\n"
      overload: WizardWrx.ReportDetail.FormatDetail*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.GetPaddedLabel(System.Int32)
      commentId: M:WizardWrx.ReportDetail.GetPaddedLabel(System.Int32)
      language: CSharp
      name:
        CSharp: GetPaddedLabel(Int32)
        VB: GetPaddedLabel(Int32)
      nameWithType:
        CSharp: ReportDetail.GetPaddedLabel(Int32)
        VB: ReportDetail.GetPaddedLabel(Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.GetPaddedLabel(System.Int32)
        VB: WizardWrx.ReportDetail.GetPaddedLabel(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetPaddedLabel
        path: ../Core/ReportDetail.cs
        startLine: 1226
      summary: "\nReturn a padded label string.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetPaddedLabel(int pintWidthOfWidestLabel)
          VB: Public Function GetPaddedLabel(pintWidthOfWidestLabel As Integer) As String
        parameters:
        - id: pintWidthOfWidestLabel
          type: System.Int32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        return:
          type: System.String
          description: "\nIf this instance has a label, pad it as indicated, otherwise, behave\nas if FormatDetail got the call.\n"
      overload: WizardWrx.ReportDetail.GetPaddedLabel*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.GetPaddedLabel(System.UInt32)
      commentId: M:WizardWrx.ReportDetail.GetPaddedLabel(System.UInt32)
      language: CSharp
      name:
        CSharp: GetPaddedLabel(UInt32)
        VB: GetPaddedLabel(UInt32)
      nameWithType:
        CSharp: ReportDetail.GetPaddedLabel(UInt32)
        VB: ReportDetail.GetPaddedLabel(UInt32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.GetPaddedLabel(System.UInt32)
        VB: WizardWrx.ReportDetail.GetPaddedLabel(System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetPaddedLabel
        path: ../Core/ReportDetail.cs
        startLine: 1247
      summary: "\nReturn a padded label string.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetPaddedLabel(uint puintWidthOfWidestLabel)
          VB: Public Function GetPaddedLabel(puintWidthOfWidestLabel As UInteger) As String
        parameters:
        - id: puintWidthOfWidestLabel
          type: System.UInt32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestLabel property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        return:
          type: System.String
          description: "\nIf this instance has a label, pad it as indicated, otherwise, behave\nas if FormatDetail got the call.\n"
      overload: WizardWrx.ReportDetail.GetPaddedLabel*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.GetPaddedValue(System.Int32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)
      commentId: M:WizardWrx.ReportDetail.GetPaddedValue(System.Int32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)
      language: CSharp
      name:
        CSharp: GetPaddedValue(Int32, FormatItem.Alignment, String)
        VB: GetPaddedValue(Int32, FormatItem.Alignment, String)
      nameWithType:
        CSharp: ReportDetail.GetPaddedValue(Int32, FormatItem.Alignment, String)
        VB: ReportDetail.GetPaddedValue(Int32, FormatItem.Alignment, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.GetPaddedValue(System.Int32, WizardWrx.FormatStringEngine.FormatItem.Alignment, System.String)
        VB: WizardWrx.ReportDetail.GetPaddedValue(System.Int32, WizardWrx.FormatStringEngine.FormatItem.Alignment, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetPaddedValue
        path: ../Core/ReportDetail.cs
        startLine: 1277
      summary: "\nReturn an aligned field item string.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetPaddedValue(int pintWidthOfWidestValue, FormatItem.Alignment penmAlignment, string pstrFormatString)
          VB: Public Function GetPaddedValue(pintWidthOfWidestValue As Integer, penmAlignment As FormatItem.Alignment, pstrFormatString As String) As String
        parameters:
        - id: pintWidthOfWidestValue
          type: System.Int32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestValue property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        - id: penmAlignment
          type: WizardWrx.FormatStringEngine.FormatItem.Alignment
          description: "\nSpecify Left or Right. Format items, per se, don&apos;t support center\nalignment.\n"
        - id: pstrFormatString
          type: System.String
          description: "\nSpecify a Standard Numeric, Date, or Text format string or a custom\nstring composed around a standard string.\n"
        return:
          type: System.String
          description: "\nThe returned string is ready to insert into a complete format string\nfor use with string.Format, Console.WriteLine, and their numerous\ncousins.\n"
      overload: WizardWrx.ReportDetail.GetPaddedValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.GetPaddedValue(System.UInt32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)
      commentId: M:WizardWrx.ReportDetail.GetPaddedValue(System.UInt32,WizardWrx.FormatStringEngine.FormatItem.Alignment,System.String)
      language: CSharp
      name:
        CSharp: GetPaddedValue(UInt32, FormatItem.Alignment, String)
        VB: GetPaddedValue(UInt32, FormatItem.Alignment, String)
      nameWithType:
        CSharp: ReportDetail.GetPaddedValue(UInt32, FormatItem.Alignment, String)
        VB: ReportDetail.GetPaddedValue(UInt32, FormatItem.Alignment, String)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.GetPaddedValue(System.UInt32, WizardWrx.FormatStringEngine.FormatItem.Alignment, System.String)
        VB: WizardWrx.ReportDetail.GetPaddedValue(System.UInt32, WizardWrx.FormatStringEngine.FormatItem.Alignment, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetPaddedValue
        path: ../Core/ReportDetail.cs
        startLine: 1312
      summary: "\nReturn an aligned field item string.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetPaddedValue(uint puintWidthOfWidestValue, FormatItem.Alignment penmAlignment, string pstrFormatString)
          VB: Public Function GetPaddedValue(puintWidthOfWidestValue As UInteger, penmAlignment As FormatItem.Alignment, pstrFormatString As String) As String
        parameters:
        - id: puintWidthOfWidestValue
          type: System.UInt32
          description: "\nSpecify the length, in characters, of the longest string \nrepresentation of all items in a collection. The intent is that the\ndetails for a report go into a ReportDetails collection, which has a\nWidthOfWidestValue property that was originally acquired indirectly,\nthrough a reference to the collection that originally occupied this\nslot in the argument list.\n"
        - id: penmAlignment
          type: WizardWrx.FormatStringEngine.FormatItem.Alignment
          description: "\nSpecify Left or Right. Format items don&apos;t support center alignment.\n"
        - id: pstrFormatString
          type: System.String
          description: "\nSpecify a Standard Numeric, Date, or Text format string or a custom\nstring composed around a standard string.\n"
        return:
          type: System.String
          description: "\nThe returned string is ready to insert into a complete format string\nfor use with string.Format, Console.WriteLine, and their numerous\ncousins.\n"
      overload: WizardWrx.ReportDetail.GetPaddedValue*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.TestState(WizardWrx.ReportDetail.State)
      commentId: M:WizardWrx.ReportDetail.TestState(WizardWrx.ReportDetail.State)
      language: CSharp
      name:
        CSharp: TestState(ReportDetail.State)
        VB: TestState(ReportDetail.State)
      nameWithType:
        CSharp: ReportDetail.TestState(ReportDetail.State)
        VB: ReportDetail.TestState(ReportDetail.State)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.TestState(WizardWrx.ReportDetail.State)
        VB: WizardWrx.ReportDetail.TestState(WizardWrx.ReportDetail.State)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TestState
        path: ../Core/ReportDetail.cs
        startLine: 1334
      summary: "\nDetermine whether the condition represented by a member of the State\nenumeration is true.\n"
      example: []
      syntax:
        content:
          CSharp: public bool TestState(ReportDetail.State penmState)
          VB: Public Function TestState(penmState As ReportDetail.State) As Boolean
        parameters:
        - id: penmState
          type: WizardWrx.ReportDetail.State
          description: "\nThe member of the State enumeration to evaluate.\n"
        return:
          type: System.Boolean
          description: "\nTrue if State is true, else False.\n"
      overload: WizardWrx.ReportDetail.TestState*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.DetailFormat
      commentId: P:WizardWrx.ReportDetail.DetailFormat
      language: CSharp
      name:
        CSharp: DetailFormat
        VB: DetailFormat
      nameWithType:
        CSharp: ReportDetail.DetailFormat
        VB: ReportDetail.DetailFormat
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DetailFormat
        VB: WizardWrx.ReportDetail.DetailFormat
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DetailFormat
        path: ../Core/ReportDetail.cs
        startLine: 1352
      summary: "\nThis property gives read/write access to the DetailFormat property,\na string that is shared by all instances. See remarks for critical\ninformation.\n"
      remarks: "\nThe first two format items, {0} and {1}, are reserved for the label\nand value properties. Additional format items, if any, may be filled\nfrom the DetailFormatItems array.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DetailFormat { get; set; }
          VB: Public Shared Property DetailFormat As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.ReportDetail.DetailFormat*
      modifiers:
        CSharp:
        - public
        - static
        - get
        - set
        VB:
        - Public
        - Shared
    - id: WizardWrx.ReportDetail.DetailFormatItems
      commentId: P:WizardWrx.ReportDetail.DetailFormatItems
      language: CSharp
      name:
        CSharp: DetailFormatItems
        VB: DetailFormatItems
      nameWithType:
        CSharp: ReportDetail.DetailFormatItems
        VB: ReportDetail.DetailFormatItems
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.DetailFormatItems
        VB: WizardWrx.ReportDetail.DetailFormatItems
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DetailFormatItems
        path: ../Core/ReportDetail.cs
        startLine: 1379
      summary: "\nThis property gives read/write access to the DetailFormatItems\nproperty, an array of Objects that is shared by all instances. See \nremarks for critical information.\n"
      remarks: "\nThe first two format items, {0} and {1}, are reserved for the label\nand value properties. Additional format items, if any, may be filled\nfrom this array.\n\nThe instance message formatter takes items from this array as needed\nto fill the remaining format items.\n"
      example: []
      syntax:
        content:
          CSharp: public static object[] DetailFormatItems { get; set; }
          VB: Public Shared Property DetailFormatItems As Object()
        parameters: []
        return:
          type: System.Object[]
      overload: WizardWrx.ReportDetail.DetailFormatItems*
      modifiers:
        CSharp:
        - public
        - static
        - get
        - set
        VB:
        - Public
        - Shared
    - isEii: true
      id: WizardWrx.ReportDetail.System#IComparable#CompareTo(System.Object)
      commentId: M:WizardWrx.ReportDetail.System#IComparable#CompareTo(System.Object)
      language: CSharp
      name:
        CSharp: IComparable.CompareTo(Object)
        VB: System.IComparable.CompareTo(Object)
      nameWithType:
        CSharp: ReportDetail.IComparable.CompareTo(Object)
        VB: ReportDetail.System.IComparable.CompareTo(Object)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.System.IComparable.CompareTo(System.Object)
        VB: WizardWrx.ReportDetail.System.IComparable.CompareTo(System.Object)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: System.IComparable.CompareTo
        path: ../Core/ReportDetail.cs
        startLine: 1632
      syntax:
        content:
          CSharp: int IComparable.CompareTo(object pobjComparand)
          VB: Function System.IComparable.CompareTo(pobjComparand As Object) As Integer Implements IComparable.CompareTo
        parameters:
        - id: pobjComparand
          type: System.Object
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetail.System#IComparable#CompareTo*
      implements:
      - System.IComparable.CompareTo(System.Object)
      modifiers:
        CSharp: []
        VB: []
  - id: WizardWrx.ReportDetail.ItemDisplayOrder
    commentId: T:WizardWrx.ReportDetail.ItemDisplayOrder
    language: CSharp
    name:
      CSharp: ReportDetail.ItemDisplayOrder
      VB: ReportDetail.ItemDisplayOrder
    nameWithType:
      CSharp: ReportDetail.ItemDisplayOrder
      VB: ReportDetail.ItemDisplayOrder
    qualifiedName:
      CSharp: WizardWrx.ReportDetail.ItemDisplayOrder
      VB: WizardWrx.ReportDetail.ItemDisplayOrder
    type: Struct
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportDetail.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ItemDisplayOrder
      path: ../Core/ReportDetail.cs
      startLine: 157
    summary: "\nThis one-member structure prevents the Common Language Runtime from\nmisdirecting the signed integer Value argument of a constructor,\nwhich might have a valid value of zero, into a constructor that\nexpects a DisplayOrder value, which is prohibited from being zero.\n"
    example: []
    syntax:
      content:
        CSharp: public struct ItemDisplayOrder
        VB: Public Structure ItemDisplayOrder
    inheritedMembers:
    - System.ValueType.Equals(System.Object)
    - System.ValueType.GetHashCode
    - System.ValueType.ToString
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: WizardWrx.ReportDetail.ItemDisplayOrder.#ctor(System.Int32)
      commentId: M:WizardWrx.ReportDetail.ItemDisplayOrder.#ctor(System.Int32)
      language: CSharp
      name:
        CSharp: ItemDisplayOrder(Int32)
        VB: ItemDisplayOrder(Int32)
      nameWithType:
        CSharp: ReportDetail.ItemDisplayOrder.ItemDisplayOrder(Int32)
        VB: ReportDetail.ItemDisplayOrder.ItemDisplayOrder(Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ItemDisplayOrder.ItemDisplayOrder(System.Int32)
        VB: WizardWrx.ReportDetail.ItemDisplayOrder.ItemDisplayOrder(System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 172
      summary: "\nHide the display order value, a signed integer, from the CLR.\n"
      example: []
      syntax:
        content:
          CSharp: public ItemDisplayOrder(int itemdisplayorder)
          VB: Public Sub New(itemdisplayorder As Integer)
        parameters:
        - id: itemdisplayorder
          type: System.Int32
          description: "\nSpecify the unsigned integer display order value to hide inside\nthis structure.\n"
      overload: WizardWrx.ReportDetail.ItemDisplayOrder.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit(WizardWrx.ReportDetail.ItemDisplayOrder)~System.Int32
      commentId: M:WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit(WizardWrx.ReportDetail.ItemDisplayOrder)~System.Int32
      language: CSharp
      name:
        CSharp: Implicit(ReportDetail.ItemDisplayOrder to Int32)
        VB: Widening(ReportDetail.ItemDisplayOrder to Int32)
      nameWithType:
        CSharp: ReportDetail.ItemDisplayOrder.Implicit(ReportDetail.ItemDisplayOrder to Int32)
        VB: ReportDetail.ItemDisplayOrder.Widening(ReportDetail.ItemDisplayOrder to Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ItemDisplayOrder.Implicit(WizardWrx.ReportDetail.ItemDisplayOrder to System.Int32)
        VB: WizardWrx.ReportDetail.ItemDisplayOrder.Widening(WizardWrx.ReportDetail.ItemDisplayOrder to System.Int32)
      type: Operator
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: op_Implicit
        path: ../Core/ReportDetail.cs
        startLine: 190
      summary: "\nImplicitly convert an ItemDisplayOrder to its true type, which\nis signed integer.\n"
      example: []
      syntax:
        content:
          CSharp: public static implicit operator int (ReportDetail.ItemDisplayOrder itemdisplayorder)
          VB: Public Shared Widening Operator CType(itemdisplayorder As ReportDetail.ItemDisplayOrder) As Integer
        parameters:
        - id: itemdisplayorder
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nSpecify the ItemDisplayOrder to be implicitly cast to unsigned\ninteger.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the signed integer that is wrapped inside\nthis structure.\n"
      overload: WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit(System.Int32)~WizardWrx.ReportDetail.ItemDisplayOrder
      commentId: M:WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit(System.Int32)~WizardWrx.ReportDetail.ItemDisplayOrder
      language: CSharp
      name:
        CSharp: Explicit(Int32 to ReportDetail.ItemDisplayOrder)
        VB: Narrowing(Int32 to ReportDetail.ItemDisplayOrder)
      nameWithType:
        CSharp: ReportDetail.ItemDisplayOrder.Explicit(Int32 to ReportDetail.ItemDisplayOrder)
        VB: ReportDetail.ItemDisplayOrder.Narrowing(Int32 to ReportDetail.ItemDisplayOrder)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.ItemDisplayOrder.Explicit(System.Int32 to WizardWrx.ReportDetail.ItemDisplayOrder)
        VB: WizardWrx.ReportDetail.ItemDisplayOrder.Narrowing(System.Int32 to WizardWrx.ReportDetail.ItemDisplayOrder)
      type: Operator
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: op_Explicit
        path: ../Core/ReportDetail.cs
        startLine: 213
      summary: "\nExplicitly convert an unsigned integer to the ItemDisplayOrder\ntype that is intended to protect it from receiving signed\nintegers that are intended to be treated as report values.\n"
      remarks: "\nThis operator must be explicit to coerce use of an explicit cast\nto steer the CLR to bind to the desired ReportDetail constructor.\n"
      example: []
      syntax:
        content:
          CSharp: public static explicit operator ReportDetail.ItemDisplayOrder(int pintItemdisplayorder)
          VB: Public Shared Narrowing Operator CType(pintItemdisplayorder As Integer) As ReportDetail.ItemDisplayOrder
        parameters:
        - id: pintItemdisplayorder
          type: System.Int32
          description: "\nThe return value is the input value, wrapped in a new\nItemDisplayOrder structure.\n"
        return:
          type: WizardWrx.ReportDetail.ItemDisplayOrder
          description: "\nThe return value is an ItemDisplayOrder structure wrapped around\nthe specified integer.\n"
      overload: WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.ReportDetail.State
    commentId: T:WizardWrx.ReportDetail.State
    language: CSharp
    name:
      CSharp: ReportDetail.State
      VB: ReportDetail.State
    nameWithType:
      CSharp: ReportDetail.State
      VB: ReportDetail.State
    qualifiedName:
      CSharp: WizardWrx.ReportDetail.State
      VB: WizardWrx.ReportDetail.State
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportDetail.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: State
      path: ../Core/ReportDetail.cs
      startLine: 241
    summary: "\nThis enumeration keeps track of the state of the instance.\n"
    example: []
    syntax:
      content:
        CSharp: >-
          [Flags]

          public enum State : byte
        VB: >-
          <Flags>

          Public Enum State As Byte
    extensionMethods:
    - WizardWrx.ReportDetail.State.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    attributes:
    - type: System.FlagsAttribute
      ctor: System.FlagsAttribute.#ctor
      arguments: []
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.ReportDetail.State.Empty
      commentId: F:WizardWrx.ReportDetail.State.Empty
      language: CSharp
      name:
        CSharp: Empty
        VB: Empty
      nameWithType:
        CSharp: ReportDetail.State.Empty
        VB: ReportDetail.State.Empty
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.Empty
        VB: WizardWrx.ReportDetail.State.Empty
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Empty
        path: ../Core/ReportDetail.cs
        startLine: 247
      summary: "\nThe instance is empty.\n"
      example: []
      syntax:
        content:
          CSharp: Empty = 0
          VB: Empty = 0
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveLabel
      commentId: F:WizardWrx.ReportDetail.State.HaveLabel
      language: CSharp
      name:
        CSharp: HaveLabel
        VB: HaveLabel
      nameWithType:
        CSharp: ReportDetail.State.HaveLabel
        VB: ReportDetail.State.HaveLabel
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveLabel
        VB: WizardWrx.ReportDetail.State.HaveLabel
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveLabel
        path: ../Core/ReportDetail.cs
        startLine: 252
      summary: "\nThe Label property has been set.\n"
      example: []
      syntax:
        content:
          CSharp: HaveLabel = 1
          VB: HaveLabel = 1
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveValueObject
      commentId: F:WizardWrx.ReportDetail.State.HaveValueObject
      language: CSharp
      name:
        CSharp: HaveValueObject
        VB: HaveValueObject
      nameWithType:
        CSharp: ReportDetail.State.HaveValueObject
        VB: ReportDetail.State.HaveValueObject
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveValueObject
        VB: WizardWrx.ReportDetail.State.HaveValueObject
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveValueObject
        path: ../Core/ReportDetail.cs
        startLine: 257
      summary: "\nThe Value property has been set.\n"
      example: []
      syntax:
        content:
          CSharp: HaveValueObject = 2
          VB: HaveValueObject = 2
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveValueString
      commentId: F:WizardWrx.ReportDetail.State.HaveValueString
      language: CSharp
      name:
        CSharp: HaveValueString
        VB: HaveValueString
      nameWithType:
        CSharp: ReportDetail.State.HaveValueString
        VB: ReportDetail.State.HaveValueString
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveValueString
        VB: WizardWrx.ReportDetail.State.HaveValueString
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveValueString
        path: ../Core/ReportDetail.cs
        startLine: 262
      summary: "\nThe DisplayValue property has been set.\n"
      example: []
      syntax:
        content:
          CSharp: HaveValueString = 4
          VB: HaveValueString = 4
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveListOrder
      commentId: F:WizardWrx.ReportDetail.State.HaveListOrder
      language: CSharp
      name:
        CSharp: HaveListOrder
        VB: HaveListOrder
      nameWithType:
        CSharp: ReportDetail.State.HaveListOrder
        VB: ReportDetail.State.HaveListOrder
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveListOrder
        VB: WizardWrx.ReportDetail.State.HaveListOrder
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveListOrder
        path: ../Core/ReportDetail.cs
        startLine: 267
      summary: "\nThe ListOrder property has been set.\n"
      example: []
      syntax:
        content:
          CSharp: HaveListOrder = 8
          VB: HaveListOrder = 8
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveFormatItems
      commentId: F:WizardWrx.ReportDetail.State.HaveFormatItems
      language: CSharp
      name:
        CSharp: HaveFormatItems
        VB: HaveFormatItems
      nameWithType:
        CSharp: ReportDetail.State.HaveFormatItems
        VB: ReportDetail.State.HaveFormatItems
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveFormatItems
        VB: WizardWrx.ReportDetail.State.HaveFormatItems
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveFormatItems
        path: ../Core/ReportDetail.cs
        startLine: 273
      summary: "\nEither the SupplementaryDetails property is set, or it can \ninherit an array from the static DetailFormatItems property.\n"
      example: []
      syntax:
        content:
          CSharp: HaveFormatItems = 16
          VB: HaveFormatItems = 16
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveValue
      commentId: F:WizardWrx.ReportDetail.State.HaveValue
      language: CSharp
      name:
        CSharp: HaveValue
        VB: HaveValue
      nameWithType:
        CSharp: ReportDetail.State.HaveValue
        VB: ReportDetail.State.HaveValue
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveValue
        VB: WizardWrx.ReportDetail.State.HaveValue
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveValue
        path: ../Core/ReportDetail.cs
        startLine: 278
      summary: "\nOne or both of the DsiplayValue and Value properties has been set.\n"
      example: []
      syntax:
        content:
          CSharp: HaveValue = 6
          VB: HaveValue = 6
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetail.State.HaveLabelAndValue
      commentId: F:WizardWrx.ReportDetail.State.HaveLabelAndValue
      language: CSharp
      name:
        CSharp: HaveLabelAndValue
        VB: HaveLabelAndValue
      nameWithType:
        CSharp: ReportDetail.State.HaveLabelAndValue
        VB: ReportDetail.State.HaveLabelAndValue
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.State.HaveLabelAndValue
        VB: WizardWrx.ReportDetail.State.HaveLabelAndValue
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HaveLabelAndValue
        path: ../Core/ReportDetail.cs
        startLine: 283
      summary: "\nThe Label property has been set, as has either or both of the Value properties.\n"
      example: []
      syntax:
        content:
          CSharp: HaveLabelAndValue = 7
          VB: HaveLabelAndValue = 7
        return:
          type: WizardWrx.ReportDetail.State
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.ReportDetail.LabelChangedEventArgs
    commentId: T:WizardWrx.ReportDetail.LabelChangedEventArgs
    language: CSharp
    name:
      CSharp: ReportDetail.LabelChangedEventArgs
      VB: ReportDetail.LabelChangedEventArgs
    nameWithType:
      CSharp: ReportDetail.LabelChangedEventArgs
      VB: ReportDetail.LabelChangedEventArgs
    qualifiedName:
      CSharp: WizardWrx.ReportDetail.LabelChangedEventArgs
      VB: WizardWrx.ReportDetail.LabelChangedEventArgs
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportDetail.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: LabelChangedEventArgs
      path: ../Core/ReportDetail.cs
      startLine: 350
    summary: "\nThe LabelChanged event needs to pass two integers to the event sink.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class LabelChangedEventArgs : EventArgs'
        VB: >-
          Public Class LabelChangedEventArgs

              Inherits EventArgs
    inheritance:
    - System.Object
    - System.EventArgs
    inheritedMembers:
    - System.EventArgs.Empty
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor(System.Int32,System.Int32)
      commentId: M:WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: LabelChangedEventArgs(Int32, Int32)
        VB: LabelChangedEventArgs(Int32, Int32)
      nameWithType:
        CSharp: ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs(Int32, Int32)
        VB: ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs(System.Int32, System.Int32)
        VB: WizardWrx.ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs(System.Int32, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetail.cs
        startLine: 366
      summary: "\nLabelChangedEventArgs has one public constructor, which creates\nand fully initializes the instance. \n"
      example: []
      syntax:
        content:
          CSharp: public LabelChangedEventArgs(int pintNewLength, int pintOldLength)
          VB: Public Sub New(pintNewLength As Integer, pintOldLength As Integer)
        parameters:
        - id: pintNewLength
          type: System.Int32
          description: "\nThe new length can&apos;t simply be added.\n"
        - id: pintOldLength
          type: System.Int32
          description: "\nThe old length can bear any relation to the new length.\n"
      overload: WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
      commentId: P:WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
      language: CSharp
      name:
        CSharp: NewLength
        VB: NewLength
      nameWithType:
        CSharp: ReportDetail.LabelChangedEventArgs.NewLength
        VB: ReportDetail.LabelChangedEventArgs.NewLength
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
        VB: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: NewLength
        path: ../Core/ReportDetail.cs
        startLine: 377
      summary: "\nThe new length is added to the accumulated total.\n"
      example: []
      syntax:
        content:
          CSharp: public int NewLength { get; }
          VB: Public ReadOnly Property NewLength As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
      commentId: P:WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
      language: CSharp
      name:
        CSharp: OldLength
        VB: OldLength
      nameWithType:
        CSharp: ReportDetail.LabelChangedEventArgs.OldLength
        VB: ReportDetail.LabelChangedEventArgs.OldLength
      qualifiedName:
        CSharp: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
        VB: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetail.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OldLength
        path: ../Core/ReportDetail.cs
        startLine: 382
      summary: "\nThe old length is subtracted from the total.\n"
      example: []
      syntax:
        content:
          CSharp: public int OldLength { get; }
          VB: Public ReadOnly Property OldLength As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
  - id: WizardWrx.ReportDetails
    commentId: T:WizardWrx.ReportDetails
    language: CSharp
    name:
      CSharp: ReportDetails
      VB: ReportDetails
    nameWithType:
      CSharp: ReportDetails
      VB: ReportDetails
    qualifiedName:
      CSharp: WizardWrx.ReportDetails
      VB: WizardWrx.ReportDetails
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportDetails.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ReportDetails
      path: ../Core/ReportDetails.cs
      startLine: 139
    summary: "\nThis class holds the details for a report. Static object locks are used\nthroughout to ensure synchronized access.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class ReportDetails : List<ReportDetail>, IList<ReportDetail>, ICollection<ReportDetail>, IEnumerable<ReportDetail>, IList, ICollection, IEnumerable'
        VB: >-
          Public Class ReportDetails

              Inherits List(Of ReportDetail)

              Implements IList(Of ReportDetail), ICollection(Of ReportDetail), IEnumerable(Of ReportDetail), IList, ICollection, IEnumerable
    inheritance:
    - System.Object
    - System.Collections.Generic.List{WizardWrx.ReportDetail}
    implements:
    - System.Collections.Generic.IList{WizardWrx.ReportDetail}
    - System.Collections.Generic.ICollection{WizardWrx.ReportDetail}
    - System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail}
    - System.Collections.IList
    - System.Collections.ICollection
    - System.Collections.IEnumerable
    inheritedMembers:
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#get_Item(System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#set_Item(System.Int32,System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Add(System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.AddRange(System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.AsReadOnly
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(System.Int32,System.Int32,WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Clear
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Contains(WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Contains(System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.ConvertAll``1(System.Converter{WizardWrx.ReportDetail,{TOutput}})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[])
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(System.Int32,WizardWrx.ReportDetail[],System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[],System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Exists(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Find(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindAll(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLast(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.ForEach(System.Action{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.GetEnumerator
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#IEnumerable{T}#GetEnumerator
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IEnumerable#GetEnumerator
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.GetRange(System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IndexOf(System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Insert(System.Int32,WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Insert(System.Int32,System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Remove(WizardWrx.ReportDetail)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Remove(System.Object)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAll(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAt(System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveRange(System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse(System.Int32,System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Comparison{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.ToArray
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.TrimExcess
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.TrueForAll(System.Predicate{WizardWrx.ReportDetail})
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Capacity
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Count
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsFixedSize
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#ICollection{T}#IsReadOnly
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsReadOnly
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#IsSynchronized
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#SyncRoot
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.Item(System.Int32)
    - System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Item(System.Int32)
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
      commentId: F:WizardWrx.ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
      language: CSharp
      name:
        CSharp: DEFAULT_DISPLAY_ORDER_INCREMENT
        VB: DEFAULT_DISPLAY_ORDER_INCREMENT
      nameWithType:
        CSharp: ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
        VB: ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
        VB: WizardWrx.ReportDetails.DEFAULT_DISPLAY_ORDER_INCREMENT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DEFAULT_DISPLAY_ORDER_INCREMENT
        path: ../Core/ReportDetails.cs
        startLine: 148
      summary: "\nThe default increment value is 100. With automatic incrementation,\nthis is almost certainly overkill. On the other hand, the\napplications that I anticipate for this class should have plenty of\nheadroom in the provided unsigned integer.\n"
      example: []
      syntax:
        content:
          CSharp: public const int DEFAULT_DISPLAY_ORDER_INCREMENT = 100
          VB: Public Const DEFAULT_DISPLAY_ORDER_INCREMENT As Integer = 100
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportDetails.Add(WizardWrx.ReportDetail)
      commentId: M:WizardWrx.ReportDetails.Add(WizardWrx.ReportDetail)
      language: CSharp
      name:
        CSharp: Add(ReportDetail)
        VB: Add(ReportDetail)
      nameWithType:
        CSharp: ReportDetails.Add(ReportDetail)
        VB: ReportDetails.Add(ReportDetail)
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.Add(WizardWrx.ReportDetail)
        VB: WizardWrx.ReportDetails.Add(WizardWrx.ReportDetail)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Add
        path: ../Core/ReportDetails.cs
        startLine: 163
      summary: "\nOverride the New method in the base class, because it&apos;s lots cheaper\nthan using an event.\n"
      example: []
      syntax:
        content:
          CSharp: public void Add(ReportDetail prDtl)
          VB: Public Sub Add(prDtl As ReportDetail)
        parameters:
        - id: prDtl
          type: WizardWrx.ReportDetail
          description: "\nThe ReportDetail item to add to the collection.\n"
      overload: WizardWrx.ReportDetails.Add*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.#ctor
      commentId: M:WizardWrx.ReportDetails.#ctor
      language: CSharp
      name:
        CSharp: ReportDetails()
        VB: ReportDetails()
      nameWithType:
        CSharp: ReportDetails.ReportDetails()
        VB: ReportDetails.ReportDetails()
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ReportDetails()
        VB: WizardWrx.ReportDetails.ReportDetails()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetails.cs
        startLine: 191
      summary: "\nConstruct an empty list.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetails()
          VB: Public Sub New
      overload: WizardWrx.ReportDetails.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.#ctor(System.Collections.Generic.ICollection{WizardWrx.ReportDetail})
      commentId: M:WizardWrx.ReportDetails.#ctor(System.Collections.Generic.ICollection{WizardWrx.ReportDetail})
      language: CSharp
      name:
        CSharp: ReportDetails(ICollection<ReportDetail>)
        VB: ReportDetails(ICollection(Of ReportDetail))
      nameWithType:
        CSharp: ReportDetails.ReportDetails(ICollection<ReportDetail>)
        VB: ReportDetails.ReportDetails(ICollection(Of ReportDetail))
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ReportDetails(System.Collections.Generic.ICollection<WizardWrx.ReportDetail>)
        VB: WizardWrx.ReportDetails.ReportDetails(System.Collections.Generic.ICollection(Of WizardWrx.ReportDetail))
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetails.cs
        startLine: 205
      summary: "\nConstruct a list with an initial capacity sufficient to hold the\nwhole ICollection, but check them in one by one.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetails(ICollection<ReportDetail> pICollection)
          VB: Public Sub New(pICollection As ICollection(Of ReportDetail))
        parameters:
        - id: pICollection
          type: System.Collections.Generic.ICollection{WizardWrx.ReportDetail}
          description: "\nThe collection from which to construct the list. Any member that is\na ReportDetail is added. Others are discarded, so that the finished\ncollection is homogeneous.\n"
      overload: WizardWrx.ReportDetails.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.#ctor(System.Int32)
      commentId: M:WizardWrx.ReportDetails.#ctor(System.Int32)
      language: CSharp
      name:
        CSharp: ReportDetails(Int32)
        VB: ReportDetails(Int32)
      nameWithType:
        CSharp: ReportDetails.ReportDetails(Int32)
        VB: ReportDetails.ReportDetails(Int32)
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ReportDetails(System.Int32)
        VB: WizardWrx.ReportDetails.ReportDetails(System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/ReportDetails.cs
        startLine: 228
      summary: "\nConstruct an empty list, with a specified initial capacity.\n"
      example: []
      syntax:
        content:
          CSharp: public ReportDetails(int pintCapacity)
          VB: Public Sub New(pintCapacity As Integer)
        parameters:
        - id: pintCapacity
          type: System.Int32
          description: "\nSet the initial capacity of the list to this value.\n"
      overload: WizardWrx.ReportDetails.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.GroupDetails
      commentId: P:WizardWrx.ReportDetails.GroupDetails
      language: CSharp
      name:
        CSharp: GroupDetails
        VB: GroupDetails
      nameWithType:
        CSharp: ReportDetails.GroupDetails
        VB: ReportDetails.GroupDetails
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.GroupDetails
        VB: WizardWrx.ReportDetails.GroupDetails
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GroupDetails
        path: ../Core/ReportDetails.cs
        startLine: 244
      summary: "\nGets or sets the value (contents) of the GroupDetails array of\ngeneric object variables intended for inclusion in reports.\n"
      remarks: "\nUse this array to store objects intended to appear in multiple lines\nof a report, such as a description of their source, creation date,\nor similar attributes that apply to the collection as a whole.\n"
      example: []
      syntax:
        content:
          CSharp: public object[] GroupDetails { get; set; }
          VB: Public Property GroupDetails As Object()
        parameters: []
        return:
          type: System.Object[]
      overload: WizardWrx.ReportDetails.GroupDetails*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetails.Increment
      commentId: P:WizardWrx.ReportDetails.Increment
      language: CSharp
      name:
        CSharp: Increment
        VB: Increment
      nameWithType:
        CSharp: ReportDetails.Increment
        VB: ReportDetails.Increment
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.Increment
        VB: WizardWrx.ReportDetails.Increment
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Increment
        path: ../Core/ReportDetails.cs
        startLine: 256
      summary: "\nUnless the object being added has one of its own, the local Add\nmethod multiplies the count, plus 1, by this increment to set its\nDisplayOrder property.\n"
      example: []
      syntax:
        content:
          CSharp: public int Increment { get; set; }
          VB: Public Property Increment As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetails.Increment*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.ReportDetails.WidthOfWidestLabel
      commentId: P:WizardWrx.ReportDetails.WidthOfWidestLabel
      language: CSharp
      name:
        CSharp: WidthOfWidestLabel
        VB: WidthOfWidestLabel
      nameWithType:
        CSharp: ReportDetails.WidthOfWidestLabel
        VB: ReportDetails.WidthOfWidestLabel
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.WidthOfWidestLabel
        VB: WizardWrx.ReportDetails.WidthOfWidestLabel
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WidthOfWidestLabel
        path: ../Core/ReportDetails.cs
        startLine: 278
      summary: "\nGets the width, in characters, of the widest label.\n\nIf the class is empty, the return value is zero.\n"
      example: []
      syntax:
        content:
          CSharp: public int WidthOfWidestLabel { get; }
          VB: Public ReadOnly Property WidthOfWidestLabel As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetails.WidthOfWidestLabel*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
      commentId: P:WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
      language: CSharp
      name:
        CSharp: WidthOfWidestLabelUnsigned
        VB: WidthOfWidestLabelUnsigned
      nameWithType:
        CSharp: ReportDetails.WidthOfWidestLabelUnsigned
        VB: ReportDetails.WidthOfWidestLabelUnsigned
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
        VB: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WidthOfWidestLabelUnsigned
        path: ../Core/ReportDetails.cs
        startLine: 288
      summary: "\nGets the width, in characters, of the widest label, as an unsigned \ninteger.\n\nIf the class is empty, the return value is zero.\n"
      example: []
      syntax:
        content:
          CSharp: public uint WidthOfWidestLabelUnsigned { get; }
          VB: Public ReadOnly Property WidthOfWidestLabelUnsigned As UInteger
        parameters: []
        return:
          type: System.UInt32
      overload: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetails.WidthOfWidestValue
      commentId: P:WizardWrx.ReportDetails.WidthOfWidestValue
      language: CSharp
      name:
        CSharp: WidthOfWidestValue
        VB: WidthOfWidestValue
      nameWithType:
        CSharp: ReportDetails.WidthOfWidestValue
        VB: ReportDetails.WidthOfWidestValue
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.WidthOfWidestValue
        VB: WizardWrx.ReportDetails.WidthOfWidestValue
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WidthOfWidestValue
        path: ../Core/ReportDetails.cs
        startLine: 297
      summary: "\nGets the width, in characters, of the widest value in the\ncollection.\n"
      example: []
      syntax:
        content:
          CSharp: public int WidthOfWidestValue { get; }
          VB: Public ReadOnly Property WidthOfWidestValue As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.ReportDetails.WidthOfWidestValue*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
      commentId: P:WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
      language: CSharp
      name:
        CSharp: WidthOfWidestValueUnsigned
        VB: WidthOfWidestValueUnsigned
      nameWithType:
        CSharp: ReportDetails.WidthOfWidestValueUnsigned
        VB: ReportDetails.WidthOfWidestValueUnsigned
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
        VB: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WidthOfWidestValueUnsigned
        path: ../Core/ReportDetails.cs
        startLine: 305
      summary: "\nGets the width, in characters, of the widest value in the\ncollection, as an unsigned integer.\n"
      example: []
      syntax:
        content:
          CSharp: public uint WidthOfWidestValueUnsigned { get; }
          VB: Public ReadOnly Property WidthOfWidestValueUnsigned As UInteger
        parameters: []
        return:
          type: System.UInt32
      overload: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.ReportDetails.ListAllItems
      commentId: M:WizardWrx.ReportDetails.ListAllItems
      language: CSharp
      name:
        CSharp: ListAllItems()
        VB: ListAllItems()
      nameWithType:
        CSharp: ReportDetails.ListAllItems()
        VB: ReportDetails.ListAllItems()
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ListAllItems()
        VB: WizardWrx.ReportDetails.ListAllItems()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ListAllItems
        path: ../Core/ReportDetails.cs
        startLine: 314
      summary: "\nList each item in a new line on the system console.\n"
      example: []
      syntax:
        content:
          CSharp: public void ListAllItems()
          VB: Public Sub ListAllItems
      overload: WizardWrx.ReportDetails.ListAllItems*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.ListAllItems(System.IO.TextWriter)
      commentId: M:WizardWrx.ReportDetails.ListAllItems(System.IO.TextWriter)
      language: CSharp
      name:
        CSharp: ListAllItems(TextWriter)
        VB: ListAllItems(TextWriter)
      nameWithType:
        CSharp: ReportDetails.ListAllItems(TextWriter)
        VB: ReportDetails.ListAllItems(TextWriter)
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ListAllItems(System.IO.TextWriter)
        VB: WizardWrx.ReportDetails.ListAllItems(System.IO.TextWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ListAllItems
        path: ../Core/ReportDetails.cs
        startLine: 326
      summary: "\nList each item in a new line on the specified TextWriter.\n"
      example: []
      syntax:
        content:
          CSharp: public void ListAllItems(TextWriter pswOut)
          VB: Public Sub ListAllItems(pswOut As TextWriter)
        parameters:
        - id: pswOut
          type: System.IO.TextWriter
          description: "\nSpecify the open TextWriter on which to write the report.\n"
      overload: WizardWrx.ReportDetails.ListAllItems*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.ReportDetails.ListAllItemsInArray
      commentId: M:WizardWrx.ReportDetails.ListAllItemsInArray
      language: CSharp
      name:
        CSharp: ListAllItemsInArray()
        VB: ListAllItemsInArray()
      nameWithType:
        CSharp: ReportDetails.ListAllItemsInArray()
        VB: ReportDetails.ListAllItemsInArray()
      qualifiedName:
        CSharp: WizardWrx.ReportDetails.ListAllItemsInArray()
        VB: WizardWrx.ReportDetails.ListAllItemsInArray()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportDetails.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ListAllItemsInArray
        path: ../Core/ReportDetails.cs
        startLine: 348
      summary: "\nFill an array of strings with report items.\n"
      example: []
      syntax:
        content:
          CSharp: public string[] ListAllItemsInArray()
          VB: Public Function ListAllItemsInArray As String()
        return:
          type: System.String[]
          description: "\nThe return value is an array of strings, one per item in the\ncollection. Each string is a report item, ready to send to a text\nfile or for further modification, since the lines aren&apos;t terminated.\n"
      overload: WizardWrx.ReportDetails.ListAllItemsInArray*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: WizardWrx.ReportHelpers
    commentId: T:WizardWrx.ReportHelpers
    language: CSharp
    name:
      CSharp: ReportHelpers
      VB: ReportHelpers
    nameWithType:
      CSharp: ReportHelpers
      VB: ReportHelpers
    qualifiedName:
      CSharp: WizardWrx.ReportHelpers
      VB: WizardWrx.ReportHelpers
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportHelpers.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ReportHelpers
      path: ../Core/ReportHelpers.cs
      startLine: 116
    summary: "\nThis static class exposes methods to help prepare strings for use on\nreports.\n"
    example: []
    syntax:
      content:
        CSharp: public static class ReportHelpers
        VB: Public Module ReportHelpers
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.ReportHelpers.DOUBLE_SPACE
      commentId: F:WizardWrx.ReportHelpers.DOUBLE_SPACE
      language: CSharp
      name:
        CSharp: DOUBLE_SPACE
        VB: DOUBLE_SPACE
      nameWithType:
        CSharp: ReportHelpers.DOUBLE_SPACE
        VB: ReportHelpers.DOUBLE_SPACE
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.DOUBLE_SPACE
        VB: WizardWrx.ReportHelpers.DOUBLE_SPACE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DOUBLE_SPACE
        path: ../Core/ReportHelpers.cs
        startLine: 139
      summary: "\nOverlooked constant - two consecutive spaces.\n"
      example: []
      syntax:
        content:
          CSharp: public const string DOUBLE_SPACE = "  "
          VB: Public Const DOUBLE_SPACE As String = "  "
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportHelpers.EMBEDDED_TAB
      commentId: F:WizardWrx.ReportHelpers.EMBEDDED_TAB
      language: CSharp
      name:
        CSharp: EMBEDDED_TAB
        VB: EMBEDDED_TAB
      nameWithType:
        CSharp: ReportHelpers.EMBEDDED_TAB
        VB: ReportHelpers.EMBEDDED_TAB
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.EMBEDDED_TAB
        VB: WizardWrx.ReportHelpers.EMBEDDED_TAB
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EMBEDDED_TAB
        path: ../Core/ReportHelpers.cs
        startLine: 144
      summary: "\nTab characters, as they must be entered into resource (.RESX) strings.\n"
      example: []
      syntax:
        content:
          CSharp: public const string EMBEDDED_TAB = "\\t"
          VB: Public Const EMBEDDED_TAB As String = "\t"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportHelpers.OUTPUT_TAB
      commentId: F:WizardWrx.ReportHelpers.OUTPUT_TAB
      language: CSharp
      name:
        CSharp: OUTPUT_TAB
        VB: OUTPUT_TAB
      nameWithType:
        CSharp: ReportHelpers.OUTPUT_TAB
        VB: ReportHelpers.OUTPUT_TAB
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.OUTPUT_TAB
        VB: WizardWrx.ReportHelpers.OUTPUT_TAB
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OUTPUT_TAB
        path: ../Core/ReportHelpers.cs
        startLine: 150
      summary: "\nTab characters, as they must appear in the string before it can be\nused.\n"
      example: []
      syntax:
        content:
          CSharp: public const string OUTPUT_TAB = "\t"
          VB: Public Const OUTPUT_TAB As String = vbTab
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String)
      commentId: M:WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String)
      language: CSharp
      name:
        CSharp: DetailTemplateFromLabels(String)
        VB: DetailTemplateFromLabels(String)
      nameWithType:
        CSharp: ReportHelpers.DetailTemplateFromLabels(String)
        VB: ReportHelpers.DetailTemplateFromLabels(String)
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String)
        VB: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DetailTemplateFromLabels
        path: ../Core/ReportHelpers.cs
        startLine: 172
      summary: "\nGiven a formatted string for a label row, generate a format string\nfor the corresponding detail row.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DetailTemplateFromLabels(string pstrReportLabels)
          VB: Public Shared Function DetailTemplateFromLabels(pstrReportLabels As String) As String
        parameters:
        - id: pstrReportLabels
          type: System.String
          description: "\nLabel string for which to generate a detail string.\n"
        return:
          type: System.String
          description: "\nString, for use with string.Format method.\n"
      overload: WizardWrx.ReportHelpers.DetailTemplateFromLabels*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String,System.Char)
      commentId: M:WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String,System.Char)
      language: CSharp
      name:
        CSharp: DetailTemplateFromLabels(String, Char)
        VB: DetailTemplateFromLabels(String, Char)
      nameWithType:
        CSharp: ReportHelpers.DetailTemplateFromLabels(String, Char)
        VB: ReportHelpers.DetailTemplateFromLabels(String, Char)
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String, System.Char)
        VB: WizardWrx.ReportHelpers.DetailTemplateFromLabels(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DetailTemplateFromLabels
        path: ../Core/ReportHelpers.cs
        startLine: 193
      summary: "\nGiven a formatted string for a label row, generate a format string\nfor the corresponding detail row.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DetailTemplateFromLabels(string pstrReportLabels, char pchrFieldSeparator)
          VB: Public Shared Function DetailTemplateFromLabels(pstrReportLabels As String, pchrFieldSeparator As Char) As String
        parameters:
        - id: pstrReportLabels
          type: System.String
          description: "\nLabel string for which to generate a detail string.\n"
        - id: pchrFieldSeparator
          type: System.Char
          description: "\nCharacter to use in lieu of TAB as field separator.\n"
        return:
          type: System.String
          description: "\nString, for use with string.Format method.\n"
      overload: WizardWrx.ReportHelpers.DetailTemplateFromLabels*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.ReportHelpers.MaxStringLength``1(System.Collections.Generic.List{``0})
      commentId: M:WizardWrx.ReportHelpers.MaxStringLength``1(System.Collections.Generic.List{``0})
      language: CSharp
      name:
        CSharp: MaxStringLength<T>(List<T>)
        VB: MaxStringLength(Of T)(List(Of T))
      nameWithType:
        CSharp: ReportHelpers.MaxStringLength<T>(List<T>)
        VB: ReportHelpers.MaxStringLength(Of T)(List(Of T))
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.MaxStringLength<T>(System.Collections.Generic.List<T>)
        VB: WizardWrx.ReportHelpers.MaxStringLength(Of T)(System.Collections.Generic.List(Of T))
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MaxStringLength
        path: ../Core/ReportHelpers.cs
        startLine: 252
      summary: "\nGiven an array of objects of any type, return the length of the\nlongest string made from them. See Remarks.\n"
      remarks: "\nThe goal of this routine is to determine the maximum number of\ncharacters required to represent any of a collection of objects such\nas labels or members of an enumerated type. This method has at least\nthree use cases.\n\n1) Pad the strings to a uniform length, so that all of a set of\nlabeled values aligns vertically.\n\n2) Construct a key from several substrings, such that the substrings\nare of uniform length, and the keys can be grouped by any of the\nleading substrings, and ordered by the values of the last substring.\n\n3) Construct a composite format string that reserves enough room for\nthe widest item in the list, so that whatever follows it on a report\nline aligns vertically.\n"
      example:
      - "\nThe following example returns the length of the longest string \ncontained in array astrLinesFromFile, an array of strings.\n\nint intLogestLine = WizardWrx.ReportHelpers.MaxStringLength ( new List&lt;string> ( astrLinesFromFile ) );\n\nNote use of the List constructor, which transforms the array into a\ndisposable generic List.\n"
      syntax:
        content:
          CSharp: public static int MaxStringLength<T>(List<T> plstObjs)
          VB: Public Shared Function MaxStringLength(Of T)(plstObjs As List(Of T)) As Integer
        parameters:
        - id: plstObjs
          type: System.Collections.Generic.List{{T}}
          description: "\nThis argument expects an array of objects, which may be of different\nkinds.\n\nSince the generic List class has a constructor that takes an array,\nwhich it copies into the new list that it returns, you can use this\nmethod to process arrays by specifying a new List of the appropriate\ntype for this argument.\nFor additional information, please see the Remarks section.\n"
        typeParameters:
        - id: T
          description: "\nThis is a generic method; its argument may be of any type. This \nmethod needs only its ToString method.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the length of the longest string made from the\nobjects in the input array. Since it is intended for use with the\nPadRight method on a string, it is cast to int. See Remarks.\n"
      overload: WizardWrx.ReportHelpers.MaxStringLength*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.ReportHelpers.Alignment
    commentId: T:WizardWrx.ReportHelpers.Alignment
    language: CSharp
    name:
      CSharp: ReportHelpers.Alignment
      VB: ReportHelpers.Alignment
    nameWithType:
      CSharp: ReportHelpers.Alignment
      VB: ReportHelpers.Alignment
    qualifiedName:
      CSharp: WizardWrx.ReportHelpers.Alignment
      VB: WizardWrx.ReportHelpers.Alignment
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/ReportHelpers.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: Alignment
      path: ../Core/ReportHelpers.cs
      startLine: 123
    summary: "\nSet the penmAlignment argument of the AdjustToMaximumWidth method to\na member of this enumeration.\n"
    example: []
    syntax:
      content:
        CSharp: public enum Alignment
        VB: Public Enum Alignment
    extensionMethods:
    - WizardWrx.ReportHelpers.Alignment.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.ReportHelpers.Alignment.Left
      commentId: F:WizardWrx.ReportHelpers.Alignment.Left
      language: CSharp
      name:
        CSharp: Left
        VB: Left
      nameWithType:
        CSharp: ReportHelpers.Alignment.Left
        VB: ReportHelpers.Alignment.Left
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.Alignment.Left
        VB: WizardWrx.ReportHelpers.Alignment.Left
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Left
        path: ../Core/ReportHelpers.cs
        startLine: 128
      summary: "\nAlign text to left.\n"
      example: []
      syntax:
        content:
          CSharp: Left = 0
          VB: Left = 0
        return:
          type: WizardWrx.ReportHelpers.Alignment
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.ReportHelpers.Alignment.Right
      commentId: F:WizardWrx.ReportHelpers.Alignment.Right
      language: CSharp
      name:
        CSharp: Right
        VB: Right
      nameWithType:
        CSharp: ReportHelpers.Alignment.Right
        VB: ReportHelpers.Alignment.Right
      qualifiedName:
        CSharp: WizardWrx.ReportHelpers.Alignment.Right
        VB: WizardWrx.ReportHelpers.Alignment.Right
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/ReportHelpers.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Right
        path: ../Core/ReportHelpers.cs
        startLine: 133
      summary: "\nAlign text to right.\n"
      example: []
      syntax:
        content:
          CSharp: Right = 1
          VB: Right = 1
        return:
          type: WizardWrx.ReportHelpers.Alignment
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.StringExtensions
    commentId: T:WizardWrx.StringExtensions
    language: CSharp
    name:
      CSharp: StringExtensions
      VB: StringExtensions
    nameWithType:
      CSharp: StringExtensions
      VB: StringExtensions
    qualifiedName:
      CSharp: WizardWrx.StringExtensions
      VB: WizardWrx.StringExtensions
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/StringExtensions.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: StringExtensions
      path: ../Core/StringExtensions.cs
      startLine: 173
    summary: "\nThis is a class of extension methods for performing common tasks not\nprovided by the System.String class. All but the four Pad methods are\nderived from long established routines in companion class StringTricks.\n\nJust as importing the System.Linq namespace makes its generic extension\nmethods visible, importing the root WizardWrx namespace, accompanied by\na reference to WizardWrx.Core, makes these methods visible on every\ninstance of System.string.\n\nRather than create ane entirely new class to support one small method, I\nextended this class to cover RenderEvenWhenNull, even though it is a\ngeneric method.\n"
    example: []
    syntax:
      content:
        CSharp: public static class StringExtensions
        VB: Public Module StringExtensions
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.StringExtensions.DEFAULT_TOKEN_DELM
      commentId: F:WizardWrx.StringExtensions.DEFAULT_TOKEN_DELM
      language: CSharp
      name:
        CSharp: DEFAULT_TOKEN_DELM
        VB: DEFAULT_TOKEN_DELM
      nameWithType:
        CSharp: StringExtensions.DEFAULT_TOKEN_DELM
        VB: StringExtensions.DEFAULT_TOKEN_DELM
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.DEFAULT_TOKEN_DELM
        VB: WizardWrx.StringExtensions.DEFAULT_TOKEN_DELM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DEFAULT_TOKEN_DELM
        path: ../Core/StringExtensions.cs
        startLine: 180
      summary: "\nDefault token terminator string used by the version of public static\nmethod, MakeToken, which takes one argument.\n"
      example: []
      syntax:
        content:
          CSharp: public const string DEFAULT_TOKEN_DELM = "$$"
          VB: Public Const DEFAULT_TOKEN_DELM As String = "$$"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ApplyFixups(System.String,WizardWrx.Core.StringFixups.StringFixup[])
      commentId: M:WizardWrx.StringExtensions.ApplyFixups(System.String,WizardWrx.Core.StringFixups.StringFixup[])
      language: CSharp
      name:
        CSharp: ApplyFixups(String, StringFixups.StringFixup[])
        VB: ApplyFixups(String, StringFixups.StringFixup())
      nameWithType:
        CSharp: StringExtensions.ApplyFixups(String, StringFixups.StringFixup[])
        VB: StringExtensions.ApplyFixups(String, StringFixups.StringFixup())
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ApplyFixups(System.String, WizardWrx.Core.StringFixups.StringFixup[])
        VB: WizardWrx.StringExtensions.ApplyFixups(System.String, WizardWrx.Core.StringFixups.StringFixup())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ApplyFixups
        path: ../Core/StringExtensions.cs
        startLine: 199
      summary: "\nCall this extension method to perform a one-off string\ntransformation.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ApplyFixups(this string pstrIn, StringFixups.StringFixup[] pafixupPairs)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ApplyFixups(pstrIn As String, pafixupPairs As StringFixups.StringFixup()) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nInput string to transform by applying <code data-dev-comment-type=\"paramref\" class=\"paramref\">pafixupPairs</code>\n"
        - id: pafixupPairs
          type: WizardWrx.Core.StringFixups.StringFixup[]
          description: "\nArray of StringFixup objects to apply to <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrIn</code>\n"
        return:
          type: System.String
          description: "\nThe <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrIn</code>, transformed by applying each\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pafixupPairs</code> StringFixup to it in turn\n"
      overload: WizardWrx.StringExtensions.ApplyFixups*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.AppendFullStopIfMissing(System.String)
      commentId: M:WizardWrx.StringExtensions.AppendFullStopIfMissing(System.String)
      language: CSharp
      name:
        CSharp: AppendFullStopIfMissing(String)
        VB: AppendFullStopIfMissing(String)
      nameWithType:
        CSharp: StringExtensions.AppendFullStopIfMissing(String)
        VB: StringExtensions.AppendFullStopIfMissing(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.AppendFullStopIfMissing(System.String)
        VB: WizardWrx.StringExtensions.AppendFullStopIfMissing(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AppendFullStopIfMissing
        path: ../Core/StringExtensions.cs
        startLine: 240
      summary: "\nUnless the last character of the input string is a period (full\nstop), append one to the returned string.\n"
      example: []
      syntax:
        content:
          CSharp: public static string AppendFullStopIfMissing(this string pstrInput)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function AppendFullStopIfMissing(pstrInput As String) As String
        parameters:
        - id: pstrInput
          type: System.String
          description: "\nSpecify the input string to evaluate and edit as needed.\n"
        return:
          type: System.String
          description: "\nThe input string is returned with a period appended to it. If it already\nhas one, the input string is returned unchanged.\n"
      overload: WizardWrx.StringExtensions.AppendFullStopIfMissing*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ArrayOfOne(System.Char)
      commentId: M:WizardWrx.StringExtensions.ArrayOfOne(System.Char)
      language: CSharp
      name:
        CSharp: ArrayOfOne(Char)
        VB: ArrayOfOne(Char)
      nameWithType:
        CSharp: StringExtensions.ArrayOfOne(Char)
        VB: StringExtensions.ArrayOfOne(Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ArrayOfOne(System.Char)
        VB: WizardWrx.StringExtensions.ArrayOfOne(System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArrayOfOne
        path: ../Core/StringExtensions.cs
        startLine: 265
      summary: "\nReturn a one-element array containing the input character, for use\nas input to the Split method of the System.string class.\n"
      example: []
      syntax:
        content:
          CSharp: public static char[] ArrayOfOne(this char pchrTheCharacter)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ArrayOfOne(pchrTheCharacter As Char) As Char()
        parameters:
        - id: pchrTheCharacter
          type: System.Char
          description: "\nSpecify the character to be copied into an array of one.\n"
        return:
          type: System.Char[]
          description: "\nThe return value is an array of one element, ready to feed to the\nstring.split method, or anything else that needs an array of one\ncharacter.\n"
      overload: WizardWrx.StringExtensions.ArrayOfOne*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ArrayOfOne(System.String)
      commentId: M:WizardWrx.StringExtensions.ArrayOfOne(System.String)
      language: CSharp
      name:
        CSharp: ArrayOfOne(String)
        VB: ArrayOfOne(String)
      nameWithType:
        CSharp: StringExtensions.ArrayOfOne(String)
        VB: StringExtensions.ArrayOfOne(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ArrayOfOne(System.String)
        VB: WizardWrx.StringExtensions.ArrayOfOne(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArrayOfOne
        path: ../Core/StringExtensions.cs
        startLine: 282
      summary: "\nReturn a one-element array containing the input string, for use\nas input to the Split method of the System.string class.\n"
      example: []
      syntax:
        content:
          CSharp: public static string[] ArrayOfOne(this string pstrTheString)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ArrayOfOne(pstrTheString As String) As String()
        parameters:
        - id: pstrTheString
          type: System.String
          description: "\nSpecify the string to be copied into an array of one.\n"
        return:
          type: System.String[]
          description: "\nThe return value is an array of one element, ready to feed to the\nstring.split method, or anything else that needs an array of one\nstring.\n"
      overload: WizardWrx.StringExtensions.ArrayOfOne*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.CapitalizeWords(System.String)
      commentId: M:WizardWrx.StringExtensions.CapitalizeWords(System.String)
      language: CSharp
      name:
        CSharp: CapitalizeWords(String)
        VB: CapitalizeWords(String)
      nameWithType:
        CSharp: StringExtensions.CapitalizeWords(String)
        VB: StringExtensions.CapitalizeWords(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.CapitalizeWords(System.String)
        VB: WizardWrx.StringExtensions.CapitalizeWords(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CapitalizeWords
        path: ../Core/StringExtensions.cs
        startLine: 301
      summary: "\nReturn the input string with each word capitalized.\n"
      example: []
      syntax:
        content:
          CSharp: public static string CapitalizeWords(this string pstr)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function CapitalizeWords(pstr As String) As String
        parameters:
        - id: pstr
          type: System.String
          description: "\nThe string to process is implicitly passed in by this extension method.\n"
        return:
          type: System.String
          description: "\nThe input string is returned with each of its words capitalized. If the\nstring is already capitalized, this has no effect. Subsequent letters are\ncoerced to lower case.\n"
      overload: WizardWrx.StringExtensions.CapitalizeWords*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.Chop(System.String,System.Boolean)
      commentId: M:WizardWrx.StringExtensions.Chop(System.String,System.Boolean)
      language: CSharp
      name:
        CSharp: Chop(String, Boolean)
        VB: Chop(String, Boolean)
      nameWithType:
        CSharp: StringExtensions.Chop(String, Boolean)
        VB: StringExtensions.Chop(String, Boolean)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.Chop(System.String, System.Boolean)
        VB: WizardWrx.StringExtensions.Chop(System.String, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Chop
        path: ../Core/StringExtensions.cs
        startLine: 371
      summary: "\nReturn a new string with the terminal newline, if present, removed.\n"
      example: []
      syntax:
        content:
          CSharp: public static string Chop(this string pstrIn, bool pfIncludeNBSP = false)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function Chop(pstrIn As String, pfIncludeNBSP As Boolean = False) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nSpecify the string to be chopped.\n"
        - id: pfIncludeNBSP
          type: System.Boolean
          description: "\n<p>\nSpecify TRUE to add the nonbreaking space to the chopping block,\nthereby saving a call to ChopNBSP to handle the third case.\n</p>\n<p>\nSince this argument is made optional and defaulted to False, this\nroutine is fully baclwards compatible.\n</p>\n"
        return:
          type: System.String
          description: "\nThe chopped string is returned, minus its newline if it contained\none. This method treats all newlines equally, meaning that any of\nthe following items is treated as a newline.\n\n1) Environment.Newline\n2) SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN, a bare carriage return (0x0D)\n3) SpecialStrings.STRING_SPLIT_LINEFEED, a bare line feed (0x0A)\n"
      overload: WizardWrx.StringExtensions.Chop*
      see:
      - linkId: WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN
        commentId: F:WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN
      - linkId: WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED
        commentId: F:WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED
      - linkId: System.Environment.NewLine
        commentId: P:System.Environment.NewLine
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN: 
        WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED: 
        System.Environment.NewLine: 
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ChopNBSP(System.String)
      commentId: M:WizardWrx.StringExtensions.ChopNBSP(System.String)
      language: CSharp
      name:
        CSharp: ChopNBSP(String)
        VB: ChopNBSP(String)
      nameWithType:
        CSharp: StringExtensions.ChopNBSP(String)
        VB: StringExtensions.ChopNBSP(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ChopNBSP(System.String)
        VB: WizardWrx.StringExtensions.ChopNBSP(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ChopNBSP
        path: ../Core/StringExtensions.cs
        startLine: 434
      summary: "\nWhen the last character of string <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrStringToTrim</code>\nis a nonbreaking space, remove it. Otherwise, return a copy of the\ninput string.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ChopNBSP(this string pstrStringToTrim)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ChopNBSP(pstrStringToTrim As String) As String
        parameters:
        - id: pstrStringToTrim
          type: System.String
          description: "\n<p>\nThis string is anticipated to end with an unwanted nonbreaking\nspace. Note that implemtnation as an extension method makes this\nargument both implicit and hidden from the IDE.\n</p>\n<p>\nThe empty string is a degenerate case, which returns another empty\nstring.\n</p>\n<p>\nA null reference returns another null reference. Give me nothing and\nI return nothing.\n</p>\n"
        return:
          type: System.String
          description: "\nThe return value is the input string, minus its last character when\nthe last character is a nonbreaking space. Otherwise, the return\nvalue is a copy of the original string.\n"
      overload: WizardWrx.StringExtensions.ChopNBSP*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.CountCharacterOccurrences(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.CountCharacterOccurrences(System.String,System.Char)
      language: CSharp
      name:
        CSharp: CountCharacterOccurrences(String, Char)
        VB: CountCharacterOccurrences(String, Char)
      nameWithType:
        CSharp: StringExtensions.CountCharacterOccurrences(String, Char)
        VB: StringExtensions.CountCharacterOccurrences(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.CountCharacterOccurrences(System.String, System.Char)
        VB: WizardWrx.StringExtensions.CountCharacterOccurrences(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CountCharacterOccurrences
        path: ../Core/StringExtensions.cs
        startLine: 502
      summary: "\nStrangely, the String class is missing an important static method to\ncount occurrences of a specified character within a string. This is\nthat missing method.\n"
      remarks: "\nThis method implements the only overload of the string.IndexOf\nmethod that takes a character as its second argument for which I\nhave yet to make use. There is currently no implementation of the\noverload that stops looking after scanning count characters, nor do\nI have immediate plans to implement one, though it wouldn&apos;t be hard.\n\nThis method uses the same algorithm as CountSubstrings, except that\nits second argument is a single character, which CANNOT be the NULL\ncharacter.\n"
      example: []
      syntax:
        content:
          CSharp: public static int CountCharacterOccurrences(this string pstrSource, char pchrToCount)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function CountCharacterOccurrences(pstrSource As String, pchrToCount As Char) As Integer
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nSpecify the string in which to count occurrences of substring \npstrToCount.\n\nIf pstrSource is null or empty, the method returns zero.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pchrToCount
          type: System.Char
          description: "\nSpecify the substring to count in string pstrSource. An empty string\ncauses the method to return MagicNumbers.STRING_INDEXOF_NOT_FOUND,\nor -1.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the number of times, if any, that string\npstrToCount occurs in string pstrSource, or\nMagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either\nnull reference or empty the empty string.\n"
      overload: WizardWrx.StringExtensions.CountCharacterOccurrences*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.CountSubstrings(System.String,System.String)
      commentId: M:WizardWrx.StringExtensions.CountSubstrings(System.String,System.String)
      language: CSharp
      name:
        CSharp: CountSubstrings(String, String)
        VB: CountSubstrings(String, String)
      nameWithType:
        CSharp: StringExtensions.CountSubstrings(String, String)
        VB: StringExtensions.CountSubstrings(String, String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.CountSubstrings(System.String, System.String)
        VB: WizardWrx.StringExtensions.CountSubstrings(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CountSubstrings
        path: ../Core/StringExtensions.cs
        startLine: 580
      summary: "\nStrangely, the String class is missing an important static method to\ncount substrings within a string. This is that missing method.\n"
      remarks: "\nThis method implements the only overloads of the string.IndexOf\nmethod that takes a string as its second argument for which I\nhave yet to make use. There is currently no implementation of the\noverloads that stops looking after scanning count characters, nor do\nI have immediate plans to implement one, though it wouldn&apos;t be hard.\n\nThis method is implemented by calling the second overload, which has\nan additional argument through which to specify a string comparison\nalgorithm, since the algorithms required to implement both are\notherwise identical.\n"
      example: []
      syntax:
        content:
          CSharp: public static int CountSubstrings(this string pstrSource, string pstrToCount)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function CountSubstrings(pstrSource As String, pstrToCount As String) As Integer
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nSpecify the string in which to count occurrences of substring \npstrToCount.\n\nIf pstrSource is null or empty, the method returns zero.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pstrToCount
          type: System.String
          description: "\nSpecify the substring to count in string pstrSource. An empty string\ncauses the method to return MagicNumbers.STRING_INDEXOF_NOT_FOUND,\nor -1.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the number of times, if any, that string\npstrToCount occurs in string pstrSource, or\nMagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either\nnull reference or empty the empty string.\n"
      overload: WizardWrx.StringExtensions.CountSubstrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.CountSubstrings(System.String,System.String,System.StringComparison)
      commentId: M:WizardWrx.StringExtensions.CountSubstrings(System.String,System.String,System.StringComparison)
      language: CSharp
      name:
        CSharp: CountSubstrings(String, String, StringComparison)
        VB: CountSubstrings(String, String, StringComparison)
      nameWithType:
        CSharp: StringExtensions.CountSubstrings(String, String, StringComparison)
        VB: StringExtensions.CountSubstrings(String, String, StringComparison)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.CountSubstrings(System.String, System.String, System.StringComparison)
        VB: WizardWrx.StringExtensions.CountSubstrings(System.String, System.String, System.StringComparison)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CountSubstrings
        path: ../Core/StringExtensions.cs
        startLine: 627
      summary: "\nStrangely, the String class is missing an important static method to\ncount substrings within a string. This is that missing method.\n"
      remarks: "\nThis method implements the only overloads of the string.IndexOf\nmethod that takes a string as its second argument for which I\nhave yet to make use. There is currently no implementation of the\noverloads that stops looking after scanning count characters, nor do\nI have immediate plans to implement one, though it wouldn&apos;t be hard.\n"
      example: []
      syntax:
        content:
          CSharp: public static int CountSubstrings(this string pstrSource, string pstrToCount, StringComparison penmComparisonType)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function CountSubstrings(pstrSource As String, pstrToCount As String, penmComparisonType As StringComparison) As Integer
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nSpecify the string in which to count occurrences of substring\npstrToCount.\n\nIf pstrSource is null or empty, the method returns zero.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pstrToCount
          type: System.String
          description: "\nSpecify the substring to count in string pstrSource.\n\nThe empty string causes the method to return \nMagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.\n"
        - id: penmComparisonType
          type: System.StringComparison
          description: "\nSpecify a member of the System.StringComparison enumeration, which\ndefines the rules for performing the comparison.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the number of times, if any, that string\npstrToCount occurs in string pstrSource, zero if pstrSource is a\nnull reference or the empty string, or \nMagicNumbers.STRING_INDEXOF_NOT_FOUND (-1) if pstrToCount is either\na null reference or the empty string.\n"
      overload: WizardWrx.StringExtensions.CountSubstrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String)
      commentId: M:WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String)
      language: CSharp
      name:
        CSharp: EnumerateSubstringPositions(String, String)
        VB: EnumerateSubstringPositions(String, String)
      nameWithType:
        CSharp: StringExtensions.EnumerateSubstringPositions(String, String)
        VB: StringExtensions.EnumerateSubstringPositions(String, String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String, System.String)
        VB: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnumerateSubstringPositions
        path: ../Core/StringExtensions.cs
        startLine: 752
      summary: "\nReturn an array of integers, each a position of substring\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code> in string <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static int[] EnumerateSubstringPositions(this string pstrSource, string pstrToCount)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EnumerateSubstringPositions(pstrSource As String, pstrToCount As String) As Integer()
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nSpecify the string in which to count occurrences of substring\npstrToCount.\n\nIf pstrSource is null or empty, the method returns zero.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pstrToCount
          type: System.String
          description: "\nSpecify the substring to count in string pstrSource.\n\nThe empty string causes the method to return \nMagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.\n"
        return:
          type: System.Int32[]
          description: "\nWhen the method succeeds, its return value is an array of integers,\neach of which is the position of an occurrence of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code>\nin <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code>, following the search algorithm\ndictated by StringComparison.CurrentCulture. When either of the two\nstring parameters is a null reference or the empty string, the\nreturn value is NULL, for which callers must test. Since either\nstring could be empty or a null reference, in normal operations, it\nseemed appropriate to treat such a case as routine, rather than\nthrowing an exception. Conversely, when both strings are valid, but\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code> never occurs in <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>,\nthe return value is an empty array.\n"
      overload: WizardWrx.StringExtensions.EnumerateSubstringPositions*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String,System.StringComparison)
      commentId: M:WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String,System.String,System.StringComparison)
      language: CSharp
      name:
        CSharp: EnumerateSubstringPositions(String, String, StringComparison)
        VB: EnumerateSubstringPositions(String, String, StringComparison)
      nameWithType:
        CSharp: StringExtensions.EnumerateSubstringPositions(String, String, StringComparison)
        VB: StringExtensions.EnumerateSubstringPositions(String, String, StringComparison)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String, System.String, System.StringComparison)
        VB: WizardWrx.StringExtensions.EnumerateSubstringPositions(System.String, System.String, System.StringComparison)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnumerateSubstringPositions
        path: ../Core/StringExtensions.cs
        startLine: 798
      summary: "\nReturn an array of integers, each a position of substring\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code> in string <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static int[] EnumerateSubstringPositions(this string pstrSource, string pstrToCount, StringComparison penmComparisonType)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EnumerateSubstringPositions(pstrSource As String, pstrToCount As String, penmComparisonType As StringComparison) As Integer()
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nSpecify the string in which to count occurrences of substring\npstrToCount.\n\nIf pstrSource is null or empty, the method returns zero.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pstrToCount
          type: System.String
          description: "\nSpecify the substring to count in string pstrSource.\n\nThe empty string causes the method to return \nMagicNumbers.STRING_INDEXOF_NOT_FOUND, or -1.\n"
        - id: penmComparisonType
          type: System.StringComparison
          description: "\nSpecify a member of the System.StringComparison enumeration, which\ndefines the rules for performing the comparison.\n"
        return:
          type: System.Int32[]
          description: "\nWhen the method succeeds, its return value is an array of integers,\neach of which is the position of an occurrence of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code>\nin <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code>, following the search algorithm\ndictated by <code data-dev-comment-type=\"paramref\" class=\"paramref\">penmComparisonType</code>. When either of\nthe two string parameters is a null reference or the empty string,\nthe return value is NULL, for which callers must test. Since either\nstring could be empty or a null reference, in normal operations, it\nseemed appropriate to treat such a case as routine, rather than\nthrowing an exception. Conversely, when both strings are valid, but\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrToCount</code> never occurs in <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>,\nthe return value is an empty array.\n"
      overload: WizardWrx.StringExtensions.EnumerateSubstringPositions*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
      commentId: M:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
      language: CSharp
      name:
        CSharp: CountUnresolvedEnvironmentStrings(String)
        VB: CountUnresolvedEnvironmentStrings(String)
      nameWithType:
        CSharp: StringExtensions.CountUnresolvedEnvironmentStrings(String)
        VB: StringExtensions.CountUnresolvedEnvironmentStrings(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
        VB: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CountUnresolvedEnvironmentStrings
        path: ../Core/StringExtensions.cs
        startLine: 867
      summary: "\nScan a string for environment string delimiter characters left\nbehind by an environment string expansion.\n"
      remarks: "\nThere are two reasons that such delimiters might be left behind.\n\n1) The input string contains environment strings that have no like\nnamed strings in the environment block that belongs to the process.\n\n2) The input string contains a malformed string that is missing one\nof its delimiting tokens.\n\nThis routine wraps CountSubstrings, supplying the required token,\nwhich is defined as public character constant in SpecialCharacters,\na sibling class. Since you could as well call that routine directly,\nthis routine is syntactic sugar.\n"
      example: []
      syntax:
        content:
          CSharp: public static int CountUnresolvedEnvironmentStrings(this string pstrInput)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function CountUnresolvedEnvironmentStrings(pstrInput As String) As Integer
        parameters:
        - id: pstrInput
          type: System.String
          description: "\nSpecify a string that has had its environment strings expanded.\n"
        return:
          type: System.Int32
          description: "\nThe return value is the count of remaining environment string\ndelimiters. Please see the remarks for additional information.\n"
      overload: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings*
      seealso:
      - linkId: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)
        commentId: M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32): 
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EncloseInChar(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.EncloseInChar(System.String,System.Char)
      language: CSharp
      name:
        CSharp: EncloseInChar(String, Char)
        VB: EncloseInChar(String, Char)
      nameWithType:
        CSharp: StringExtensions.EncloseInChar(String, Char)
        VB: StringExtensions.EncloseInChar(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EncloseInChar(System.String, System.Char)
        VB: WizardWrx.StringExtensions.EncloseInChar(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EncloseInChar
        path: ../Core/StringExtensions.cs
        startLine: 893
      summary: "\nAppend a specified character to both ends of a string, unless it is\nalready present.\n"
      example: []
      syntax:
        content:
          CSharp: public static string EncloseInChar(this string pstrIn, char pchrEnd)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EncloseInChar(pstrIn As String, pchrEnd As Char) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nSpecify the string to evaluate, which may, or may not, end with the\ncharacter specified in pchrEnd.\n\nSince this is an extension method, pstrIn is supplied by the BCL\nwhen it binds this method to an instance of System.string.\n"
        - id: pchrEnd
          type: System.Char
          description: "\nSpecify the character to append, if absent.\n"
        return:
          type: System.String
          description: "\nThe return value is a new string that is guaranteed to have exactly\none of the character specified in pchrEnd at each end.\n"
      overload: WizardWrx.StringExtensions.EncloseInChar*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EnsureFirstCharIs(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.EnsureFirstCharIs(System.String,System.Char)
      language: CSharp
      name:
        CSharp: EnsureFirstCharIs(String, Char)
        VB: EnsureFirstCharIs(String, Char)
      nameWithType:
        CSharp: StringExtensions.EnsureFirstCharIs(String, Char)
        VB: StringExtensions.EnsureFirstCharIs(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EnsureFirstCharIs(System.String, System.Char)
        VB: WizardWrx.StringExtensions.EnsureFirstCharIs(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnsureFirstCharIs
        path: ../Core/StringExtensions.cs
        startLine: 930
      summary: "\nReturn a string that is guaranteed to start with a specified character.\n"
      example: []
      syntax:
        content:
          CSharp: public static string EnsureFirstCharIs(this string pstrInput, char pchrMustBeFirst)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EnsureFirstCharIs(pstrInput As String, pchrMustBeFirst As Char) As String
        parameters:
        - id: pstrInput
          type: System.String
          description: ''
        - id: pchrMustBeFirst
          type: System.Char
          description: "\nEnsure that the first character in the string is this one.\n"
        return:
          type: System.String
          description: "\nThe returned string is guaranteed to start with the specified character.\n"
      overload: WizardWrx.StringExtensions.EnsureFirstCharIs*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EnsureLastCharIs(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.EnsureLastCharIs(System.String,System.Char)
      language: CSharp
      name:
        CSharp: EnsureLastCharIs(String, Char)
        VB: EnsureLastCharIs(String, Char)
      nameWithType:
        CSharp: StringExtensions.EnsureLastCharIs(String, Char)
        VB: StringExtensions.EnsureLastCharIs(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EnsureLastCharIs(System.String, System.Char)
        VB: WizardWrx.StringExtensions.EnsureLastCharIs(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnsureLastCharIs
        path: ../Core/StringExtensions.cs
        startLine: 965
      summary: "\nReturn a string that is guaranteed to end with a specified character.\n"
      example: []
      syntax:
        content:
          CSharp: public static string EnsureLastCharIs(this string pstrInput, char pchrMustBeLast)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EnsureLastCharIs(pstrInput As String, pchrMustBeLast As Char) As String
        parameters:
        - id: pstrInput
          type: System.String
          description: ''
        - id: pchrMustBeLast
          type: System.Char
          description: "\nEnsure that the last character in the string is this one.\n"
        return:
          type: System.String
          description: "\nThe returned string is guaranteed to end with the specified character.\n"
      overload: WizardWrx.StringExtensions.EnsureLastCharIs*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.EnumFromString``1(System.String)
      commentId: M:WizardWrx.StringExtensions.EnumFromString``1(System.String)
      language: CSharp
      name:
        CSharp: EnumFromString<T>(String)
        VB: EnumFromString(Of T)(String)
      nameWithType:
        CSharp: StringExtensions.EnumFromString<T>(String)
        VB: StringExtensions.EnumFromString(Of T)(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.EnumFromString<T>(System.String)
        VB: WizardWrx.StringExtensions.EnumFromString(Of T)(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnumFromString
        path: ../Core/StringExtensions.cs
        startLine: 1018
      summary: "\nConvert a string to the equivalent instance of a specified\nenumeration type.\n"
      remarks: "\nThis method requires version 7.3 or later of the C# compiler, for\nwhich the project configuration contains a setting.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            public static T EnumFromString<T>(this string pstrEnumAsString)

                where T : Enum
          VB: >-
            <ExtensionAttribute>

            Public Shared Function EnumFromString(Of T As  Enum)(pstrEnumAsString As String) As T
        parameters:
        - id: pstrEnumAsString
          type: System.String
          description: "\nSpecify the string to convert.\n"
        typeParameters:
        - id: T
          description: "\nThe specified type must be a valid Enum type. The method infers the\ntype from the value specified in angle brackets following the method\nname in the invocation.\n"
        return:
          type: '{T}'
          description: "\nIf the function succeeds, the return value is a member of the\nspecified enumeration.\n"
      overload: WizardWrx.StringExtensions.EnumFromString*
      exceptions:
      - type: System.InvalidOperationException
        commentId: T:System.InvalidOperationException
        description: "\nAn InvalidOperationException exception arises when the input string\ncannot be converted. The message specifies the expected type and the\nfailing input value, along with the Message property on the original\nFormatException excetpion, which is preserved as the InnerException\nproperty on the thrown InvalidOperationException.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.InvalidOperationException: 
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.Int32,System.Int32)
      commentId: M:WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: ExtractBetweenIndexOfs(String, Int32, Int32)
        VB: ExtractBetweenIndexOfs(String, Int32, Int32)
      nameWithType:
        CSharp: StringExtensions.ExtractBetweenIndexOfs(String, Int32, Int32)
        VB: StringExtensions.ExtractBetweenIndexOfs(String, Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String, System.Int32, System.Int32)
        VB: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String, System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBetweenIndexOfs
        path: ../Core/StringExtensions.cs
        startLine: 1088
      summary: "\nExtract the substring bounded by the characters at either end of it.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExtractBetweenIndexOfs(this string pstrWholeString, int pintPosBegin, int pintPosEnd)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ExtractBetweenIndexOfs(pstrWholeString As String, pintPosBegin As Integer, pintPosEnd As Integer) As String
        parameters:
        - id: pstrWholeString
          type: System.String
          description: "\nSpecify the string from which to extract the substring.\n\nSince this is an extension method, the CLR supplies this argument\nwhen it binds the method to an instance of the System.string class.\n"
        - id: pintPosBegin
          type: System.Int32
          description: "\nSpecify the position, as it would be reported by IndexOf, of the \ncharacter that bounds the left end of the desired substring.\n"
        - id: pintPosEnd
          type: System.Int32
          description: "\nSpecify the position, as it would be reported by IndexOf, of the \ncharacter that bounds the right end of the desired substring.\n"
        return:
          type: System.String
          description: "\nThe returned substring begins with the character immediately to the\nright of the left hand bounding character, and ending with the last\ncharacter before the right hand bounding character.\n"
      overload: WizardWrx.StringExtensions.ExtractBetweenIndexOfs*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.String,System.Int32,System.Int32)
      commentId: M:WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String,System.String,System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: ExtractBetweenIndexOfs(String, String, Int32, Int32)
        VB: ExtractBetweenIndexOfs(String, String, Int32, Int32)
      nameWithType:
        CSharp: StringExtensions.ExtractBetweenIndexOfs(String, String, Int32, Int32)
        VB: StringExtensions.ExtractBetweenIndexOfs(String, String, Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String, System.String, System.Int32, System.Int32)
        VB: WizardWrx.StringExtensions.ExtractBetweenIndexOfs(System.String, System.String, System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBetweenIndexOfs
        path: ../Core/StringExtensions.cs
        startLine: 1141
      summary: "\nExtract the substring bounded by the characters at either end of it.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExtractBetweenIndexOfs(this string pstrWholeString, string pstrLeftMarker, int pintPosBegin, int pintPosEnd)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ExtractBetweenIndexOfs(pstrWholeString As String, pstrLeftMarker As String, pintPosBegin As Integer, pintPosEnd As Integer) As String
        parameters:
        - id: pstrWholeString
          type: System.String
          description: "\nSpecify the string from which to extract the substring.\n\nSince this is an extension method, the CLR supplies this argument\nwhen it binds the method to an instance of the System.string class.\n"
        - id: pstrLeftMarker
          type: System.String
          description: "\nThis overload handles the case where the left boundary is bounded by\na string. The method needs a copy of the string in order to find the\ntrue beginning of the substring to extract, and to compute its\nlength.\n"
        - id: pintPosBegin
          type: System.Int32
          description: "\nThis integer is the position, given by IndexOf, of the character\nthat bounds the left end of the desired substring.\n"
        - id: pintPosEnd
          type: System.Int32
          description: "\nThis integer is the position, given by IndexOf, of the character\nthat bounds the right end of the desired substring.\n"
        return:
          type: System.String
          description: "\nThe returned substring begins with the character immediately to the\nright of the left hand bounding character, and ending with the last\ncharacter before the right hand bounding character.\n\nInputs and computed values are thoroughly sanity checked to prevent\nrun-time exceptions. If anything is out of order, an empty string is\nreturned.\n"
      overload: WizardWrx.StringExtensions.ExtractBetweenIndexOfs*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char)
      language: CSharp
      name:
        CSharp: ExtractBoundedSubstrings(String, Char)
        VB: ExtractBoundedSubstrings(String, Char)
      nameWithType:
        CSharp: StringExtensions.ExtractBoundedSubstrings(String, Char)
        VB: StringExtensions.ExtractBoundedSubstrings(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.Char)
        VB: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBoundedSubstrings
        path: ../Core/StringExtensions.cs
        startLine: 1190
      summary: "\nExtract a substring that is bounded by a character. See Remarks.\n"
      remarks: "\nThe left and right ends must be bounded by the same character. To\nextract a string bounded on each end by a different character, use\nthe next overload.\n\nInputs and computed values are thoroughly sanity checked to prevent\nrun-time exceptions. If anything is out of order, an empty string is\nreturned.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExtractBoundedSubstrings(this string pstrWholeString, char pchrBoundingCharacter)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ExtractBoundedSubstrings(pstrWholeString As String, pchrBoundingCharacter As Char) As String
        parameters:
        - id: pstrWholeString
          type: System.String
          description: "\nThe substring is extracted from this string.\n"
        - id: pchrBoundingCharacter
          type: System.Char
          description: "\nSpecify the bounding character. Please see Remarks.\n"
        return:
          type: System.String
          description: "\nThe return value is the desired substring, without its bounding \ncharacters. See Remarks.\n"
      overload: WizardWrx.StringExtensions.ExtractBoundedSubstrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char,System.Char)
      commentId: M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.Char,System.Char)
      language: CSharp
      name:
        CSharp: ExtractBoundedSubstrings(String, Char, Char)
        VB: ExtractBoundedSubstrings(String, Char, Char)
      nameWithType:
        CSharp: StringExtensions.ExtractBoundedSubstrings(String, Char, Char)
        VB: StringExtensions.ExtractBoundedSubstrings(String, Char, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.Char, System.Char)
        VB: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.Char, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBoundedSubstrings
        path: ../Core/StringExtensions.cs
        startLine: 1246
      summary: "\nExtract a substring that is bounded by a character. See Remarks.\n"
      remarks: "\nThe left and right ends are expected to be bounded by different\ncharacters. To  extract a string bounded on each end by the same\ncharacter, use the previous overload.\n\nInputs and computed values are thoroughly sanity checked to prevent\nrun-time exceptions. If anything is out of order, the empty string\nis returned.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExtractBoundedSubstrings(this string pstrWholeString, char pchrLeftBound, char pchrRightBound)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ExtractBoundedSubstrings(pstrWholeString As String, pchrLeftBound As Char, pchrRightBound As Char) As String
        parameters:
        - id: pstrWholeString
          type: System.String
          description: "\nThe substring is extracted from this string.\n"
        - id: pchrLeftBound
          type: System.Char
          description: "\nSpecify the character that marks the left end of the string. See\nRemarks.\n"
        - id: pchrRightBound
          type: System.Char
          description: "\nSpecify the character that marks the right end of the string. See\nRemarks.\n"
        return:
          type: System.String
          description: "\nThe returned substring begins with the character immediately to the\nright of the left hand bounding substring, and ending with the last\ncharacter before the right hand bounding substring.\n"
      overload: WizardWrx.StringExtensions.ExtractBoundedSubstrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.String,System.String)
      commentId: M:WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: ExtractBoundedSubstrings(String, String, String)
        VB: ExtractBoundedSubstrings(String, String, String)
      nameWithType:
        CSharp: StringExtensions.ExtractBoundedSubstrings(String, String, String)
        VB: StringExtensions.ExtractBoundedSubstrings(String, String, String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.String, System.String)
        VB: WizardWrx.StringExtensions.ExtractBoundedSubstrings(System.String, System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBoundedSubstrings
        path: ../Core/StringExtensions.cs
        startLine: 1307
      summary: "\nExtract a substring that is bounded by a pair of substrings. See\nRemarks.\n"
      remarks: "\nThe left and right ends are expected to be bounded by different\nsubstrings. To  extract a string bounded on each end by the same\nsubstring, use the same value for the second and third arguments.\n\nInputs and computed values are thoroughly sanity checked to prevent\nrun-time exceptions. If anything is out of order, an empty string is\nreturned.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExtractBoundedSubstrings(this string pstrWholeString, string pstrLeftBound, string pstrRightBound)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ExtractBoundedSubstrings(pstrWholeString As String, pstrLeftBound As String, pstrRightBound As String) As String
        parameters:
        - id: pstrWholeString
          type: System.String
          description: "\nSpecify the string from which to extract the bounded substring.\n"
        - id: pstrLeftBound
          type: System.String
          description: "\nSpecify the substring that marks the left end of the string. See\nRemarks.\n"
        - id: pstrRightBound
          type: System.String
          description: "\nSpecify the substring that marks the right end of the string. See\nRemarks.\n"
        return:
          type: System.String
          description: "\nThe returned substring begins with the character immediately to the\nright of the left hand bounding substring, and ending with the last\ncharacter before the right hand bounding substring.\n"
      overload: WizardWrx.StringExtensions.ExtractBoundedSubstrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.GuardStringIfNeeded(System.String,System.Char,System.Char)
      commentId: M:WizardWrx.StringExtensions.GuardStringIfNeeded(System.String,System.Char,System.Char)
      language: CSharp
      name:
        CSharp: GuardStringIfNeeded(String, Char, Char)
        VB: GuardStringIfNeeded(String, Char, Char)
      nameWithType:
        CSharp: StringExtensions.GuardStringIfNeeded(String, Char, Char)
        VB: StringExtensions.GuardStringIfNeeded(String, Char, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.GuardStringIfNeeded(System.String, System.Char, System.Char)
        VB: WizardWrx.StringExtensions.GuardStringIfNeeded(System.String, System.Char, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GuardStringIfNeeded
        path: ../Core/StringExtensions.cs
        startLine: 1372
      summary: "\nReturn a new string that is enclosed in a specified quoting\ncharacter, defaulting to a double quote, if the input string\ncontains a specified delimiter character, defaulting to a comma.\n"
      example: []
      syntax:
        content:
          CSharp: public static string GuardStringIfNeeded(this string pstrThisString, char pchrDelimiter = ',', char pchrGuard = '"')
          VB: >-
            <ExtensionAttribute>

            Public Shared Function GuardStringIfNeeded(pstrThisString As String, pchrDelimiter As Char = ","c, pchrGuard As Char = """"c) As String
        parameters:
        - id: pstrThisString
          type: System.String
          description: "\nPass in a reference to a string, which may be a null reference or a\npointer to the empty string.\n"
        - id: pchrDelimiter
          type: System.Char
          description: "\nPass in the delimiter character, which cannot be the NULL character,\nand must differ from the <code data-dev-comment-type=\"paramref\" class=\"paramref\">pchrGuard</code> character.\n"
        - id: pchrGuard
          type: System.Char
          description: "\nPass in the guard character (the quoting character), which cannot be\nthe NULL character, and must differ from the\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pchrDelimiter</code> character.\n"
        return:
          type: System.String
          description: "\nWhen <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrThisString</code> contains at least one instance\nof the <code data-dev-comment-type=\"paramref\" class=\"paramref\">pchrDelimiter</code> character, the return value\nis <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrThisString</code> enclosed in <code data-dev-comment-type=\"paramref\" class=\"paramref\">pchrGuard</code>\ncharacters. Otherwise, the string is returned as is, substituting\nthe empty string when <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrThisString</code> is a NULL\nreference.\n"
      overload: WizardWrx.StringExtensions.GuardStringIfNeeded*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32)
      commentId: M:WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32)
      language: CSharp
      name:
        CSharp: LeftPadNChars(String, Int32)
        VB: LeftPadNChars(String, Int32)
      nameWithType:
        CSharp: StringExtensions.LeftPadNChars(String, Int32)
        VB: StringExtensions.LeftPadNChars(String, Int32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.LeftPadNChars(System.String, System.Int32)
        VB: WizardWrx.StringExtensions.LeftPadNChars(System.String, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LeftPadNChars
        path: ../Core/StringExtensions.cs
        startLine: 1434
      summary: "\nLeft pad the string with a specified number of spaces.\n"
      remarks: "\nThese methods compensate for the completely logical, if unexpected,\nbehavior of the native PadLeft and PadRight methods on the\nSystem.string class. Their objective is to guarantee that the new\nstring is truly padded with a specific number of characters.\n\nThe names of the visible arguments differ from my usual Hungarian\nnaming convention so that they conform to the naming convention of\nthe Base Class Library methods that they wrap.\n"
      example: []
      syntax:
        content:
          CSharp: public static string LeftPadNChars(this string pstrPadThisString, int paddingCharacterCount)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function LeftPadNChars(pstrPadThisString As String, paddingCharacterCount As Integer) As String
        parameters:
        - id: pstrPadThisString
          type: System.String
          description: "\nThis argument is supplied by the framework when it binds the method\nto an instance of the System.String class.\n"
        - id: paddingCharacterCount
          type: System.Int32
          description: "\nSpecify the number of space characters to add on the left end of the\nstring. Please see the Remarks for important details.\n"
        return:
          type: System.String
          description: "\nThe input string is padded on the left with the specified number of\nspace characters.\n\nPlease see the Remarks for important details.\n"
      overload: WizardWrx.StringExtensions.LeftPadNChars*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32,System.Char)
      commentId: M:WizardWrx.StringExtensions.LeftPadNChars(System.String,System.Int32,System.Char)
      language: CSharp
      name:
        CSharp: LeftPadNChars(String, Int32, Char)
        VB: LeftPadNChars(String, Int32, Char)
      nameWithType:
        CSharp: StringExtensions.LeftPadNChars(String, Int32, Char)
        VB: StringExtensions.LeftPadNChars(String, Int32, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.LeftPadNChars(System.String, System.Int32, System.Char)
        VB: WizardWrx.StringExtensions.LeftPadNChars(System.String, System.Int32, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: LeftPadNChars
        path: ../Core/StringExtensions.cs
        startLine: 1476
      summary: "\nLeft pad the string with a specified number of some arbitrary\ncharacter.\n"
      remarks: "\nThese methods compensate for the completely logical, if unexpected,\nbehavior of the native PadLeft and PadRight methods on the\nSystem.string class. Their objective is to guarantee that the new\nstring is truly padded with a specific number of characters.\n\nThe names of the visible arguments differ from my usual Hungarian\nnaming convention so that they conform to the naming convention of\nthe Base Class Library methods that they wrap.\n"
      example: []
      syntax:
        content:
          CSharp: public static string LeftPadNChars(this string pstrPadThisString, int paddingCharacterCount, char paddingChar)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function LeftPadNChars(pstrPadThisString As String, paddingCharacterCount As Integer, paddingChar As Char) As String
        parameters:
        - id: pstrPadThisString
          type: System.String
          description: "\nThis argument is supplied by the framework when it binds the method\nto an instance of the System.String class.\n"
        - id: paddingCharacterCount
          type: System.Int32
          description: "\nSpecify the number of arbitrary characters to add on the left end of\nthe string. Please see the Remarks for important details.\n"
        - id: paddingChar
          type: System.Char
          description: "\nSpecify the arbitrary character with which the string is to be padded.\n"
        return:
          type: System.String
          description: "\nThe input string is padded on the left with the specified number of\nthe specified arbitrary character.\n\nPlease see the Remarks for important details.\n"
      overload: WizardWrx.StringExtensions.LeftPadNChars*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.MakeToken(System.String)
      commentId: M:WizardWrx.StringExtensions.MakeToken(System.String)
      language: CSharp
      name:
        CSharp: MakeToken(String)
        VB: MakeToken(String)
      nameWithType:
        CSharp: StringExtensions.MakeToken(String)
        VB: StringExtensions.MakeToken(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.MakeToken(System.String)
        VB: WizardWrx.StringExtensions.MakeToken(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MakeToken
        path: ../Core/StringExtensions.cs
        startLine: 1508
      summary: "\nGiven a string containing the name of a form control (field) or\nother token, create its place holder token.\n"
      remarks: "\nThe string is constructed by appending a standard token delimiter,\nwhich is a pair of dollar signs, to each end of the string.\n\nThe token is exposed as a static property, DEFAULT_TOKEN_DELM.\n"
      example: []
      syntax:
        content:
          CSharp: public static string MakeToken(this string pstrFieldName)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function MakeToken(pstrFieldName As String) As String
        parameters:
        - id: pstrFieldName
          type: System.String
          description: "\nString containing the name of the token.\n"
        return:
          type: System.String
          description: "\nString containing the text of the corresponding template text place\nholder. See Remarks.\n"
      overload: WizardWrx.StringExtensions.MakeToken*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.MakeToken(System.String,System.String)
      commentId: M:WizardWrx.StringExtensions.MakeToken(System.String,System.String)
      language: CSharp
      name:
        CSharp: MakeToken(String, String)
        VB: MakeToken(String, String)
      nameWithType:
        CSharp: StringExtensions.MakeToken(String, String)
        VB: StringExtensions.MakeToken(String, String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.MakeToken(System.String, System.String)
        VB: WizardWrx.StringExtensions.MakeToken(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MakeToken
        path: ../Core/StringExtensions.cs
        startLine: 1537
      summary: "\nGiven a string containing the name of a form control (field) or\nother token, and another string containing a static token, create\nits place holder token.\n"
      example: []
      syntax:
        content:
          CSharp: public static string MakeToken(this string pstrFieldName, string pstrTokenEnds)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function MakeToken(pstrFieldName As String, pstrTokenEnds As String) As String
        parameters:
        - id: pstrFieldName
          type: System.String
          description: "\nSpecify the string containing the name of the token.\n"
        - id: pstrTokenEnds
          type: System.String
          description: "\nSpecify the string to attach to both ends of the string specified by\npstrFieldName to generate the token.\n"
        return:
          type: System.String
          description: "\nThe string is constructed by appending the token delimiter specified\nin argument pstrTokenEnds to both ends of the string specified in\nargument pstrFieldName.\n"
      overload: WizardWrx.StringExtensions.MakeToken*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.OldMacLineEndings(System.String)
      commentId: M:WizardWrx.StringExtensions.OldMacLineEndings(System.String)
      language: CSharp
      name:
        CSharp: OldMacLineEndings(String)
        VB: OldMacLineEndings(String)
      nameWithType:
        CSharp: StringExtensions.OldMacLineEndings(String)
        VB: StringExtensions.OldMacLineEndings(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.OldMacLineEndings(System.String)
        VB: WizardWrx.StringExtensions.OldMacLineEndings(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OldMacLineEndings
        path: ../Core/StringExtensions.cs
        startLine: 1568
      summary: "\nReplace a string that may contain mixed or unwanted line endings\nwith a string that contains only the expected line ending type.\n"
      example: []
      syntax:
        content:
          CSharp: public static string OldMacLineEndings(this string pstrSource)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function OldMacLineEndings(pstrSource As String) As String
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nString in which to replace line endings\n"
        return:
          type: System.String
          description: "\nA copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>, with non-coformant line\nendings replaced. A line ending is treated as non-conformant when it\nis an otherwise valid line ending, but isn&apos;t a bare CR character.\n"
      overload: WizardWrx.StringExtensions.OldMacLineEndings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ParseCommentInHTMLComment(System.String)
      commentId: M:WizardWrx.StringExtensions.ParseCommentInHTMLComment(System.String)
      language: CSharp
      name:
        CSharp: ParseCommentInHTMLComment(String)
        VB: ParseCommentInHTMLComment(String)
      nameWithType:
        CSharp: StringExtensions.ParseCommentInHTMLComment(String)
        VB: StringExtensions.ParseCommentInHTMLComment(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ParseCommentInHTMLComment(System.String)
        VB: WizardWrx.StringExtensions.ParseCommentInHTMLComment(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ParseCommentInHTMLComment
        path: ../Core/StringExtensions.cs
        startLine: 1610
      summary: "\nExtract parameters, expressed as key-value pairs, from a standard\nHTML comment.\n"
      example:
      - "\n<pre><code>Parse this: &lt;!-- ForPage=default;UseTable=False -->\n\nReturn this:\n\n		=======================\n		Name		Value\n		-----------	-----------\n		ForPage		default\n		UseTable	False\n		=======================</code></pre>\n<p>The returned NameValueCollection contains two members.</p>\n<p>Since this method guarantees to return an initialized\nNameValueCollection, the empty collection is allocated by the first\nstatement, and is unconditionally returned by the last statement.</p>\n"
      syntax:
        content:
          CSharp: public static NameValueCollection ParseCommentInHTMLComment(this string pstrInput)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ParseCommentInHTMLComment(pstrInput As String) As NameValueCollection
        parameters:
        - id: pstrInput
          type: System.String
          description: "\nString containing a well formed HTML comment, surrounding the\nkey-value pairs. If the string is not a well formed HTML comment,\nwith a single space between the comment delimiters and the body,\nor the string is null or empty, the returned collection is empty.\n"
        return:
          type: System.Collections.Specialized.NameValueCollection
          description: "\nA NameValueCollection of parameter names and values, which may be\nempty, but is guaranteed to be returned, empty or not.\n"
      overload: WizardWrx.StringExtensions.ParseCommentInHTMLComment*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.QuoteString(System.String)
      commentId: M:WizardWrx.StringExtensions.QuoteString(System.String)
      language: CSharp
      name:
        CSharp: QuoteString(String)
        VB: QuoteString(String)
      nameWithType:
        CSharp: StringExtensions.QuoteString(String)
        VB: StringExtensions.QuoteString(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.QuoteString(System.String)
        VB: WizardWrx.StringExtensions.QuoteString(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: QuoteString
        path: ../Core/StringExtensions.cs
        startLine: 1667
      summary: "\nAppend a quote character to both ends of a string, unless it is\nalready present.\n"
      example: []
      syntax:
        content:
          CSharp: public static string QuoteString(this string pstrIn)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function QuoteString(pstrIn As String) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString to evaluate, which may, or may not, end with the characterr\nspecified in pchrEnd.\n"
        return:
          type: System.String
          description: "\nString with quote character at both ends.\n"
      overload: WizardWrx.StringExtensions.QuoteString*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.RemoveEndChars(System.String,System.Char)
      commentId: M:WizardWrx.StringExtensions.RemoveEndChars(System.String,System.Char)
      language: CSharp
      name:
        CSharp: RemoveEndChars(String, Char)
        VB: RemoveEndChars(String, Char)
      nameWithType:
        CSharp: StringExtensions.RemoveEndChars(String, Char)
        VB: StringExtensions.RemoveEndChars(String, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.RemoveEndChars(System.String, System.Char)
        VB: WizardWrx.StringExtensions.RemoveEndChars(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RemoveEndChars
        path: ../Core/StringExtensions.cs
        startLine: 1690
      summary: "\nRemove ending character, such as brackets, from a string, if present.\n"
      example: []
      syntax:
        content:
          CSharp: public static string RemoveEndChars(this string pstrIn, char pchrEnd)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function RemoveEndChars(pstrIn As String, pchrEnd As Char) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString to evaluate, which may, or may not, end with the characterr\nspecified in pchrEnd.\n"
        - id: pchrEnd
          type: System.Char
          description: "\nCharacter to remove, if present.\n"
        return:
          type: System.String
          description: "\nString with character pchrEnd removed from both ends.\n"
      overload: WizardWrx.StringExtensions.RemoveEndChars*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.RemoveEndQuotes(System.String)
      commentId: M:WizardWrx.StringExtensions.RemoveEndQuotes(System.String)
      language: CSharp
      name:
        CSharp: RemoveEndQuotes(String)
        VB: RemoveEndQuotes(String)
      nameWithType:
        CSharp: StringExtensions.RemoveEndQuotes(String)
        VB: StringExtensions.RemoveEndQuotes(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.RemoveEndQuotes(System.String)
        VB: WizardWrx.StringExtensions.RemoveEndQuotes(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RemoveEndQuotes
        path: ../Core/StringExtensions.cs
        startLine: 1758
      summary: "\nRemove ending quotation marks from a string, if present.\n"
      example: []
      syntax:
        content:
          CSharp: public static string RemoveEndQuotes(this string pstrIn)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function RemoveEndQuotes(pstrIn As String) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nSpecify the string to evaluate, which may, or may not, end with\nquotes.\n"
        return:
          type: System.String
          description: "\nThe return value is a new string with ending quotes, if present,\nremoved. Otherwise, a copy of the original string is returned.\n"
      overload: WizardWrx.StringExtensions.RemoveEndQuotes*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
      commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
      language: CSharp
      name:
        CSharp: RenderEvenWhenNull<T>(T, String, String, IFormatProvider)
        VB: RenderEvenWhenNull(Of T)(T, String, String, IFormatProvider)
      nameWithType:
        CSharp: StringExtensions.RenderEvenWhenNull<T>(T, String, String, IFormatProvider)
        VB: StringExtensions.RenderEvenWhenNull(Of T)(T, String, String, IFormatProvider)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.RenderEvenWhenNull<T>(T, System.String, System.String, System.IFormatProvider)
        VB: WizardWrx.StringExtensions.RenderEvenWhenNull(Of T)(T, System.String, System.String, System.IFormatProvider)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RenderEvenWhenNull
        path: ../Core/StringExtensions.cs
        startLine: 1824
      summary: "\nFor any object of generic type T, return result from calling the\nToString method on it, unless the instance is a null reference of\ntype T. In that case, return either the supplied string or the\nlocalizable default defined in the string resources expsed by the\nWizardWrx.Common library.\n"
      remarks: "\nBecause this method is generic, it can call the ToString override on\nany object that explicitly implements the IFormattable interface, so\nyou derive the benefits of any such override.\n\nThe optional <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrFormatString</code> and \n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pformatProvider</code> arguments work in\ntandem with the override on the instance ToString method. To use it\nand the default null reference representation, pass a null reference\nas the value of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrValueIfNull</code>.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            public static string RenderEvenWhenNull<T>(this T pgenericObject, string pstrValueIfNull = null, string pstrFormatString = null, IFormatProvider pformatProvider = null)

                where T : IFormattable
          VB: >-
            <ExtensionAttribute>

            Public Shared Function RenderEvenWhenNull(Of T As IFormattable)(pgenericObject As T, pstrValueIfNull As String = Nothing, pstrFormatString As String = Nothing, pformatProvider As IFormatProvider = Nothing) As String
        parameters:
        - id: pgenericObject
          type: '{T}'
          description: "\nPass in a reference to an object of the specified generic type, or a\nnull reference to that type.\n"
        - id: pstrValueIfNull
          type: System.String
          description: "\nUse this optional string parameter to override the default value,\nCommon.Properties.Resources.MSG_OBJECT_REFERENCE_IS_NULL. Pass a\nnull referencr or omit the parameter to use the default string.\n"
        - id: pstrFormatString
          type: System.String
          description: "\nUse this optional string parameter to override the default format of\nthe value returned by the instance ToString method.\n\nPlease see the Remarks.\n"
        - id: pformatProvider
          type: System.IFormatProvider
          description: "\nUse this optional parameter to override the default format provider\nused by the instance ToString method.\n\nPlease see the Remarks.\n"
        typeParameters:
        - id: T
          description: "\nThe specified type T must implement IFormattable.\n"
        return:
          type: System.String
          description: "\nIf <code data-dev-comment-type=\"paramref\" class=\"paramref\">pgenericObject</code> is a null reference, return\nCommon.Properties.Resources.MSG_OBJECT_REFERENCE_IS_NULL if\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrValueIfNull</code> is also a null reference.\n\nIf <code data-dev-comment-type=\"paramref\" class=\"paramref\">pgenericObject</code> is a null reference and \n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrValueIfNull</code> is not, return\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrValueIfNull</code>.\n\nFinally, if <code data-dev-comment-type=\"paramref\" class=\"paramref\">pgenericObject</code> is not null, call its\nToString method.\n\nPlease see the Remarks.\n"
      overload: WizardWrx.StringExtensions.RenderEvenWhenNull*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX(System.String)
      commentId: M:WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX(System.String)
      language: CSharp
      name:
        CSharp: ReplaceEscapedTabsInStringFromResX(String)
        VB: ReplaceEscapedTabsInStringFromResX(String)
      nameWithType:
        CSharp: StringExtensions.ReplaceEscapedTabsInStringFromResX(String)
        VB: StringExtensions.ReplaceEscapedTabsInStringFromResX(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX(System.String)
        VB: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceEscapedTabsInStringFromResX
        path: ../Core/StringExtensions.cs
        startLine: 1858
      summary: "\n\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceEscapedTabsInStringFromResX(this string pstrStringFromResX)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceEscapedTabsInStringFromResX(pstrStringFromResX As String) As String
        parameters:
        - id: pstrStringFromResX
          type: System.String
          description: ''
        return:
          type: System.String
          description: ''
      overload: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection)
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection)
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, NameValueCollection)
        VB: ReplaceTokensFromList(String, NameValueCollection)
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, NameValueCollection)
        VB: StringExtensions.ReplaceTokensFromList(String, NameValueCollection)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Specialized.NameValueCollection)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Specialized.NameValueCollection)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 1885
      summary: "\nGiven a string containing tokens of the form &quot;^^ListKeyValue^^&quot;\nwhere ListKeyValue is the value of a key in the pnvcList collection,\nwhich may or may not exist in the collection, replace all such\ntokens with the contents of the like named value in the collection.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrMsg, NameValueCollection pnvcList)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrMsg As String, pnvcList As NameValueCollection) As String
        parameters:
        - id: pstrMsg
          type: System.String
          description: "\nString containing the message containing the substitution tokens.\n"
        - id: pnvcList
          type: System.Collections.Specialized.NameValueCollection
          description: "\nA NameValueCollection, in which each key represents a token, and its\nvalue represents the value to be substituted for it.\n"
        return:
          type: System.String
          description: "\nString with tokens replaced, and tokens that have no corresponding\nobject in the pnvcList collection preserved.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, NameValueCollection, NameValueCollection)
        VB: ReplaceTokensFromList(String, NameValueCollection, NameValueCollection)
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, NameValueCollection, NameValueCollection)
        VB: StringExtensions.ReplaceTokensFromList(String, NameValueCollection, NameValueCollection)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Specialized.NameValueCollection, System.Collections.Specialized.NameValueCollection)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Specialized.NameValueCollection, System.Collections.Specialized.NameValueCollection)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 1935
      summary: "\nReplace place holders (markers) with the value of the corresponding\nform control (field), or a default value, if the field is empty and\na default is designated.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrTemplate, NameValueCollection pnvcFields, NameValueCollection pnvcDefaults)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrTemplate As String, pnvcFields As NameValueCollection, pnvcDefaults As NameValueCollection) As String
        parameters:
        - id: pstrTemplate
          type: System.String
          description: "\nString containing a template containing the text and place markers.\n"
        - id: pnvcFields
          type: System.Collections.Specialized.NameValueCollection
          description: "\nNameValueCollection containing the form control (field) values.\n"
        - id: pnvcDefaults
          type: System.Collections.Specialized.NameValueCollection
          description: "\nNameValueCollection containing the form control (field) or token\ndefault values.\n\nDefault values are optional. If omitted, the method substitutes an\nempty string.\n"
        return:
          type: System.String
          description: "\nString containing the text in the template, with all tokens\nformatted with default endings replaced by the contents of the\ncorresponding, and like named, control (field) on the input form.\n\nTokens bounded by &quot;##&quot; are replaced by strings from the Session\nvariables collection. The same defaults collection is used for both.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, Dictionary<String, Object>)
        VB: ReplaceTokensFromList(String, Dictionary(Of String, Object))
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, Dictionary<String, Object>)
        VB: StringExtensions.ReplaceTokensFromList(String, Dictionary(Of String, Object))
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary<System.String, System.Object>)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary(Of System.String, System.Object))
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 2007
      summary: "\nGiven a string containing tokens of the form &quot;^^ListKeyValue^^&quot;\nwhere ListKeyValue is the value of a key in the pnvcList collection,\nwhich may or may not exist in the collection, replace all such\ntokens with the contents of the like named value in the collection.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrMsg, Dictionary<string, object> pdctList)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrMsg As String, pdctList As Dictionary(Of String, Object)) As String
        parameters:
        - id: pstrMsg
          type: System.String
          description: "\nString containing the message containing the substitution tokens.\n"
        - id: pdctList
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the value to be substituted for it.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        return:
          type: System.String
          description: "\nString with tokens replaced, and tokens that have no corresponding\nobject in the pnvcList collection preserved.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, Dictionary<String, Object>, Dictionary<String, Object>)
        VB: ReplaceTokensFromList(String, Dictionary(Of String, Object), Dictionary(Of String, Object))
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, Dictionary<String, Object>, Dictionary<String, Object>)
        VB: StringExtensions.ReplaceTokensFromList(String, Dictionary(Of String, Object), Dictionary(Of String, Object))
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary<System.String, System.Object>, System.Collections.Generic.Dictionary<System.String, System.Object>)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary(Of System.String, System.Object), System.Collections.Generic.Dictionary(Of System.String, System.Object))
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 2063
      summary: "\nGiven a string containing tokens of the form &quot;^^ListKeyValue^^&quot;\nwhere ListKeyValue is the value of a key in the pnvcList collection,\nwhich may or may not exist in the collection, replace all such\ntokens with the contents of the like named value in the collection.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrMsg, Dictionary<string, object> pdctList, Dictionary<string, object> pdctDefaults)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrMsg As String, pdctList As Dictionary(Of String, Object), pdctDefaults As Dictionary(Of String, Object)) As String
        parameters:
        - id: pstrMsg
          type: System.String
          description: "\nString containing the message containing the substitution tokens.\n"
        - id: pdctList
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the value to be substituted for it.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        - id: pdctDefaults
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the default value to be substituted for it, if there is\nno corresponding key in dictionary pdctList.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        return:
          type: System.String
          description: "\nString with tokens replaced, and tokens that have no corresponding\nobject in the pnvcList OR the pdctDefaults collection preserved.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, Dictionary<String, Object>, String)
        VB: ReplaceTokensFromList(String, Dictionary(Of String, Object), String)
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, Dictionary<String, Object>, String)
        VB: StringExtensions.ReplaceTokensFromList(String, Dictionary(Of String, Object), String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary<System.String, System.Object>, System.String)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary(Of System.String, System.Object), System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 2130
      summary: "\nGiven a string containing tokens of the form &quot;^^ListKeyValue^^&quot;\nwhere ListKeyValue is the value of a key in the pnvcList collection,\nwhich may or may not exist in the collection, replace all such\ntokens with the contents o object.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrMsg, Dictionary<string, object> pdctList, string pstrFormat)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrMsg As String, pdctList As Dictionary(Of String, Object), pstrFormat As String) As String
        parameters:
        - id: pstrMsg
          type: System.String
          description: "\nString containing the message containing the substitution tokens.\n"
        - id: pdctList
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the value to be substituted for it.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        - id: pstrFormat
          type: System.String
          description: "\nFormat string, acceptable to the static String.Format method, which\nis used to format the string representation of each object.\n\nThe string must contain a &quot;[0}&quot; placeholder, which may occur one or\nmore times in the format string, which is replaced by the string\nreturned by the ToString method of each object.\n"
        return:
          type: System.String
          description: "\nString with tokens replaced, and tokens that have no corresponding\nobject in the pnvcList collection preserved.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String)
      commentId: M:WizardWrx.StringExtensions.ReplaceTokensFromList(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object},System.String)
      language: CSharp
      name:
        CSharp: ReplaceTokensFromList(String, Dictionary<String, Object>, Dictionary<String, Object>, String)
        VB: ReplaceTokensFromList(String, Dictionary(Of String, Object), Dictionary(Of String, Object), String)
      nameWithType:
        CSharp: StringExtensions.ReplaceTokensFromList(String, Dictionary<String, Object>, Dictionary<String, Object>, String)
        VB: StringExtensions.ReplaceTokensFromList(String, Dictionary(Of String, Object), Dictionary(Of String, Object), String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary<System.String, System.Object>, System.Collections.Generic.Dictionary<System.String, System.Object>, System.String)
        VB: WizardWrx.StringExtensions.ReplaceTokensFromList(System.String, System.Collections.Generic.Dictionary(Of System.String, System.Object), System.Collections.Generic.Dictionary(Of System.String, System.Object), System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReplaceTokensFromList
        path: ../Core/StringExtensions.cs
        startLine: 2200
      summary: "\nGiven a string containing tokens of the form &quot;^^ListKeyValue^^&quot;\nwhere ListKeyValue is the value of a key in the pnvcList collection,\nwhich may or may not exist in the collection, replace all such\ntokens with the contents of the like named session object.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReplaceTokensFromList(this string pstrMsg, Dictionary<string, object> pdctList, Dictionary<string, object> pdctDefaults, string pstrFormat)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReplaceTokensFromList(pstrMsg As String, pdctList As Dictionary(Of String, Object), pdctDefaults As Dictionary(Of String, Object), pstrFormat As String) As String
        parameters:
        - id: pstrMsg
          type: System.String
          description: "\nString containing the message containing the substitution tokens.\n"
        - id: pdctList
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the value to be substituted for it.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        - id: pdctDefaults
          type: System.Collections.Generic.Dictionary{System.String,System.Object}
          description: "\nA Dictionary, in which each key represents a token, and its value\nrepresents the default value to be substituted for it, if there is\nno corresponding key in dictionary pdctList.\n\nThe Dictionary may contain anything, as it accepts any Object. The\nrequired substitution string is obtained by calling the default\nToString method on each Object. To supply a format string, which\nwill be applied to each Object, in turn, use the next overload.\n"
        - id: pstrFormat
          type: System.String
          description: "\nFormat string, acceptable to the static String.Format method, which\nis used to format the string representation of each object.\n\nThe string must contain a &quot;[0}&quot; placeholder, which may occur one or\nmore times in the format string, which is replaced by the string\nreturned by the ToString method of each object.\n"
        return:
          type: System.String
          description: "\nString with tokens replaced, and tokens that have no corresponding\nobject in the pnvcList OR the pdctDefaults collection preserved.\n"
      overload: WizardWrx.StringExtensions.ReplaceTokensFromList*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)
      commentId: M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)
      language: CSharp
      name:
        CSharp: ReportUnresolvedEnvironmentStrings(String, UInt32, UInt32)
        VB: ReportUnresolvedEnvironmentStrings(String, UInt32, UInt32)
      nameWithType:
        CSharp: StringExtensions.ReportUnresolvedEnvironmentStrings(String, UInt32, UInt32)
        VB: StringExtensions.ReportUnresolvedEnvironmentStrings(String, UInt32, UInt32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String, System.UInt32, System.UInt32)
        VB: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String, System.UInt32, System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReportUnresolvedEnvironmentStrings
        path: ../Core/StringExtensions.cs
        startLine: 2277
      summary: "\nDisplay a string that contains unmatched environment strings or\nunmatched environment string delimiters, followed by details about\nthe locations of the errors.\n"
      remarks: "\nAfter the count is written onto the standard error stream, control\nreturns to its caller, which may take subsequent actions based upon\nthe return value.\n\nMost of the \n"
      example: []
      syntax:
        content:
          CSharp: public static uint ReportUnresolvedEnvironmentStrings(this string pstrInput, uint puintNEnvStrDlms, uint puintExitCode)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReportUnresolvedEnvironmentStrings(pstrInput As String, puintNEnvStrDlms As UInteger, puintExitCode As UInteger) As UInteger
        parameters:
        - id: pstrInput
          type: System.String
          description: "\nSpecify a string that has had its environment strings expanded.\n"
        - id: puintNEnvStrDlms
          type: System.UInt32
          description: "\nSpecify the count of unmatched delimiters. A companion routine,\nUnresolvedEnvironmentStrings, can deliver the count, although the\ncall cannot be nested. Please see the remarks.\n"
        - id: puintExitCode
          type: System.UInt32
          description: "\nThis routine is intended to report the error and exit the calling\nconsole application, returning the specified value as its exit code.\n"
        return:
          type: System.UInt32
          description: "\nThe exit code is passed through, so that the control need not return\nto the caller, but may exit directly or indirectly through \nEnvironment.Exit.\n"
      overload: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings*
      see:
      - linkId: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
        commentId: M:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String): 
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32)
      commentId: M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32)
      language: CSharp
      name:
        CSharp: ReportUnresolvedEnvironmentStrings(String, UInt32)
        VB: ReportUnresolvedEnvironmentStrings(String, UInt32)
      nameWithType:
        CSharp: StringExtensions.ReportUnresolvedEnvironmentStrings(String, UInt32)
        VB: StringExtensions.ReportUnresolvedEnvironmentStrings(String, UInt32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String, System.UInt32)
        VB: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String, System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReportUnresolvedEnvironmentStrings
        path: ../Core/StringExtensions.cs
        startLine: 2306
      summary: "\nDisplay a string that contains unmatched environment strings or\nunmatched environment string delimiters, followed by details about\nthe locations of the errors.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReportUnresolvedEnvironmentStrings(this string pstrInput, uint puintNEnvStrDlms)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function ReportUnresolvedEnvironmentStrings(pstrInput As String, puintNEnvStrDlms As UInteger) As String
        parameters:
        - id: pstrInput
          type: System.String
          description: "\nSpecify a string that has had its environment strings expanded.\n"
        - id: puintNEnvStrDlms
          type: System.UInt32
          description: "\nSpecify the count of unmatched delimiters. A companion routine,\nUnresolvedEnvironmentStrings, can deliver the count, although the\ncall cannot be nested. Please see the remarks.\n"
        return:
          type: System.String
          description: "\nThe return value is a detailed message that shows each unresolved\nstring.\n"
      overload: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32)
      commentId: M:WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32)
      language: CSharp
      name:
        CSharp: RightPadNChars(String, Int32)
        VB: RightPadNChars(String, Int32)
      nameWithType:
        CSharp: StringExtensions.RightPadNChars(String, Int32)
        VB: StringExtensions.RightPadNChars(String, Int32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.RightPadNChars(System.String, System.Int32)
        VB: WizardWrx.StringExtensions.RightPadNChars(System.String, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RightPadNChars
        path: ../Core/StringExtensions.cs
        startLine: 2389
      summary: "\nRight pad the string with a specified number of spaces.\n"
      remarks: "\nThese methods compensate for the completely logical, if unexpected,\nbehavior of the native PadLeft and PadRight methods on the\nSystem.string class. Their objective is to guarantee that the new\nstring is truly padded with a specific number of characters.\n\nThe names of the visible arguments differ from my usual Hungarian\nnaming convention so that they conform to the naming convention of\nthe Base Class Library methods that they wrap.\n"
      example: []
      syntax:
        content:
          CSharp: public static string RightPadNChars(this string pstrPadThisString, int paddingCharacterCount)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function RightPadNChars(pstrPadThisString As String, paddingCharacterCount As Integer) As String
        parameters:
        - id: pstrPadThisString
          type: System.String
          description: "\nThis argument is supplied by the framework when it binds the method\nto an instance of the System.String class.\n"
        - id: paddingCharacterCount
          type: System.Int32
          description: "\nSpecify the number of space characters to add on the right end of\nthe string.\n\nPlease see the Remarks for important details.\n"
        return:
          type: System.String
          description: "\nThe input string is padded on the right with the specified number of\nspace characters.\n\nPlease see the Remarks for important details.\n"
      overload: WizardWrx.StringExtensions.RightPadNChars*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32,System.Char)
      commentId: M:WizardWrx.StringExtensions.RightPadNChars(System.String,System.Int32,System.Char)
      language: CSharp
      name:
        CSharp: RightPadNChars(String, Int32, Char)
        VB: RightPadNChars(String, Int32, Char)
      nameWithType:
        CSharp: StringExtensions.RightPadNChars(String, Int32, Char)
        VB: StringExtensions.RightPadNChars(String, Int32, Char)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.RightPadNChars(System.String, System.Int32, System.Char)
        VB: WizardWrx.StringExtensions.RightPadNChars(System.String, System.Int32, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RightPadNChars
        path: ../Core/StringExtensions.cs
        startLine: 2430
      summary: "\nLeft pad the string with a specified number of some arbitrary\ncharacter.\n"
      remarks: "\nThese methods compensate for the completely logical, if unexpected,\nbehavior of the native PadLeft and PadRight methods on the\nSystem.string class. Their objective is to guarantee that the new\nstring is truly padded with a specific number of characters.\n\nThe names of the visible arguments differ from my usual Hungarian\nnaming convention so that they conform to the naming convention of\nthe Base Class Library methods that they wrap.\n"
      example: []
      syntax:
        content:
          CSharp: public static string RightPadNChars(this string pstrPadThisString, int paddingCharacterCount, char paddingChar)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function RightPadNChars(pstrPadThisString As String, paddingCharacterCount As Integer, paddingChar As Char) As String
        parameters:
        - id: pstrPadThisString
          type: System.String
          description: "\nThis argument is supplied by the framework when it binds the method\nto an instance of the System.String class.\n"
        - id: paddingCharacterCount
          type: System.Int32
          description: "\nSpecify the number of arbitrary characters to add on the right end \nof the string. Please see the Remarks for important details.\n"
        - id: paddingChar
          type: System.Char
          description: "\nSpecify the arbitrary character with which the string is to be padded.\n"
        return:
          type: System.String
          description: "\nThe input string is padded on the right with the specified number of\nthe specified arbitrary character.\n\nPlease see the Remarks for important details.\n"
      overload: WizardWrx.StringExtensions.RightPadNChars*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.Truncate(System.String,System.Int32)
      commentId: M:WizardWrx.StringExtensions.Truncate(System.String,System.Int32)
      language: CSharp
      name:
        CSharp: Truncate(String, Int32)
        VB: Truncate(String, Int32)
      nameWithType:
        CSharp: StringExtensions.Truncate(String, Int32)
        VB: StringExtensions.Truncate(String, Int32)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.Truncate(System.String, System.Int32)
        VB: WizardWrx.StringExtensions.Truncate(System.String, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Truncate
        path: ../Core/StringExtensions.cs
        startLine: 2470
      summary: "\nSupply the missing Truncate function to members of the String class.\n"
      example: []
      syntax:
        content:
          CSharp: public static string Truncate(this string pstrSource, int pintMaxLength)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function Truncate(pstrSource As String, pintMaxLength As Integer) As String
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nString to truncate, if it is longer than pintMaxLength.\n\nA null string is treated as an empty string, and the return value\nfor either is an empty string.\n"
        - id: pintMaxLength
          type: System.Int32
          description: "\nDesired maximum length of the returned string. If pstrSource is\nlonger than pintMaxLength characters, the first pintMaxLength are\nreturned. Otherwise, the whole string is returned.\n\nIf pintMaxLength is less than or equal to zero, an empty string is\nreturned.\n"
        return:
          type: System.String
          description: "\nIf the string length is less than or equal to the specified maximum\nlength, the whole string is returned.\n\nOtherwise, the first pintMaxLength characters are returned.\n\nRegardless, the return value is a new System.String object.\n"
      overload: WizardWrx.StringExtensions.Truncate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.UnixLineEndings(System.String)
      commentId: M:WizardWrx.StringExtensions.UnixLineEndings(System.String)
      language: CSharp
      name:
        CSharp: UnixLineEndings(String)
        VB: UnixLineEndings(String)
      nameWithType:
        CSharp: StringExtensions.UnixLineEndings(String)
        VB: StringExtensions.UnixLineEndings(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.UnixLineEndings(System.String)
        VB: WizardWrx.StringExtensions.UnixLineEndings(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: UnixLineEndings
        path: ../Core/StringExtensions.cs
        startLine: 2503
      summary: "\nReplace a string that may contain mixed or unwanted line endings\nwith a string that contains only the expected line ending type.\n"
      example: []
      syntax:
        content:
          CSharp: public static string UnixLineEndings(this string pstrSource)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function UnixLineEndings(pstrSource As String) As String
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nString in which to replace line endings\n"
        return:
          type: System.String
          description: "\nA copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>, with non-coformant line\nendings replaced. A line ending is treated as non-conformant when it\nis an otherwise valid line ending, but isn&apos;t a bare LF character.\n"
      overload: WizardWrx.StringExtensions.UnixLineEndings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.StringExtensions.WindowsLineEndings(System.String)
      commentId: M:WizardWrx.StringExtensions.WindowsLineEndings(System.String)
      language: CSharp
      name:
        CSharp: WindowsLineEndings(String)
        VB: WindowsLineEndings(String)
      nameWithType:
        CSharp: StringExtensions.WindowsLineEndings(String)
        VB: StringExtensions.WindowsLineEndings(String)
      qualifiedName:
        CSharp: WizardWrx.StringExtensions.WindowsLineEndings(System.String)
        VB: WizardWrx.StringExtensions.WindowsLineEndings(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/StringExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WindowsLineEndings
        path: ../Core/StringExtensions.cs
        startLine: 2526
      summary: "\nReplace a string that may contain mixed or unwanted line endings\nwith a string that contains only the expected line ending type.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WindowsLineEndings(this string pstrSource)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function WindowsLineEndings(pstrSource As String) As String
        parameters:
        - id: pstrSource
          type: System.String
          description: "\nString in which to replace line endings\n"
        return:
          type: System.String
          description: "\nA copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrSource</code>, with non-coformant line\nendings replaced. A line ending is treated as non-conformant when it\nis an otherwise valid line ending, but doesn&apos;t belong to a CR/LF\ncharacter pair.\n"
      overload: WizardWrx.StringExtensions.WindowsLineEndings*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.SyncRoot
    commentId: T:WizardWrx.SyncRoot
    language: CSharp
    name:
      CSharp: SyncRoot
      VB: SyncRoot
    nameWithType:
      CSharp: SyncRoot
      VB: SyncRoot
    qualifiedName:
      CSharp: WizardWrx.SyncRoot
      VB: WizardWrx.SyncRoot
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/SyncRoot.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: SyncRoot
      path: ../Core/SyncRoot.cs
      startLine: 124
    summary: "\nUse instances of this class to provide classes that must be made\nthread-safe with locks over which the class has complete control.\n"
    remarks: "\nUse labeled instances when you expect to have multiple locks active,\nespecially during the lifetime of a single method, or across calls to\ntwo or more related methods.\n\nThis class cannot be inherited.\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class SyncRoot
        VB: Public NotInheritable Class SyncRoot
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: WizardWrx.SyncRoot.#ctor
      commentId: M:WizardWrx.SyncRoot.#ctor
      language: CSharp
      name:
        CSharp: SyncRoot()
        VB: SyncRoot()
      nameWithType:
        CSharp: SyncRoot.SyncRoot()
        VB: SyncRoot.SyncRoot()
      qualifiedName:
        CSharp: WizardWrx.SyncRoot.SyncRoot()
        VB: WizardWrx.SyncRoot.SyncRoot()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SyncRoot.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/SyncRoot.cs
        startLine: 134
      summary: "\nCreate an unlabeled instance.\n"
      example: []
      syntax:
        content:
          CSharp: public SyncRoot()
          VB: Public Sub New
      overload: WizardWrx.SyncRoot.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.SyncRoot.#ctor(System.String)
      commentId: M:WizardWrx.SyncRoot.#ctor(System.String)
      language: CSharp
      name:
        CSharp: SyncRoot(String)
        VB: SyncRoot(String)
      nameWithType:
        CSharp: SyncRoot.SyncRoot(String)
        VB: SyncRoot.SyncRoot(String)
      qualifiedName:
        CSharp: WizardWrx.SyncRoot.SyncRoot(System.String)
        VB: WizardWrx.SyncRoot.SyncRoot(System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SyncRoot.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/SyncRoot.cs
        startLine: 142
      summary: "\nCreate a labeled lockable object.\n"
      example: []
      syntax:
        content:
          CSharp: public SyncRoot(string pstrLabel)
          VB: Public Sub New(pstrLabel As String)
        parameters:
        - id: pstrLabel
          type: System.String
          description: "\nLabel to assign to the instance.\n"
      overload: WizardWrx.SyncRoot.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.SyncRoot.Label
      commentId: P:WizardWrx.SyncRoot.Label
      language: CSharp
      name:
        CSharp: Label
        VB: Label
      nameWithType:
        CSharp: SyncRoot.Label
        VB: SyncRoot.Label
      qualifiedName:
        CSharp: WizardWrx.SyncRoot.Label
        VB: WizardWrx.SyncRoot.Label
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SyncRoot.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Label
        path: ../Core/SyncRoot.cs
        startLine: 152
      summary: "\nReturn the label assigned to this instance. Labels are read only.\nYou must use the overloaded constructor to create a labeled\ninstance.\n"
      example: []
      syntax:
        content:
          CSharp: public string Label { get; }
          VB: Public ReadOnly Property Label As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.SyncRoot.Label*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.SyncRoot.ToString
      commentId: M:WizardWrx.SyncRoot.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: SyncRoot.ToString()
        VB: SyncRoot.ToString()
      qualifiedName:
        CSharp: WizardWrx.SyncRoot.ToString()
        VB: WizardWrx.SyncRoot.ToString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SyncRoot.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ToString
        path: ../Core/SyncRoot.cs
        startLine: 163
      summary: "\nDisplay the label inside French braces, followed by the fully\nqualified class name, similar to the way many BCL classes render in\ndebugger watch windows.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe returned string is the label, followed by the fully qualified\nclass name.\n"
      overload: WizardWrx.SyncRoot.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
  - id: WizardWrx.SysDateFormatters
    commentId: T:WizardWrx.SysDateFormatters
    language: CSharp
    name:
      CSharp: SysDateFormatters
      VB: SysDateFormatters
    nameWithType:
      CSharp: SysDateFormatters
      VB: SysDateFormatters
    qualifiedName:
      CSharp: WizardWrx.SysDateFormatters
      VB: WizardWrx.SysDateFormatters
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/SysDateFormatters.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: SysDateFormatters
      path: ../Core/SysDateFormatters.cs
      startLine: 179
    summary: "\nThis class implements my stalwart date formatter, ReformatSysDateP6C,\nwhich I created initially as a Windows Interface Language (WIL, \na. k. a. WinBatch) library function, Reformat_Date_YmdHms_P6C, in\nOctober 2001, although its roots go back much further in my WIL script\ndevelopment.\n\nSince static classes are implicitly sealed, this class cannot be inherited.\n"
    example: []
    syntax:
      content:
        CSharp: public static class SysDateFormatters
        VB: Public Module SysDateFormatters
    seealso:
    - linkId: WizardWrx.DisplayFormats
      commentId: T:WizardWrx.DisplayFormats
    - linkId: WizardWrx.Core.TimeDisplayFormatter
      commentId: T:WizardWrx.Core.TimeDisplayFormatter
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.SysDateFormatters.RSD_TOKENS
      commentId: F:WizardWrx.SysDateFormatters.RSD_TOKENS
      language: CSharp
      name:
        CSharp: RSD_TOKENS
        VB: RSD_TOKENS
      nameWithType:
        CSharp: SysDateFormatters.RSD_TOKENS
        VB: SysDateFormatters.RSD_TOKENS
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RSD_TOKENS
        VB: WizardWrx.SysDateFormatters.RSD_TOKENS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RSD_TOKENS
        path: ../Core/SysDateFormatters.cs
        startLine: 186
      summary: "\nThe strings in this array are the substitution tokens supported by\nthe date formatters in this class.\n"
      example: []
      syntax:
        content:
          CSharp: public static readonly string[] RSD_TOKENS
          VB: Public Shared ReadOnly RSD_TOKENS As String()
        return:
          type: System.String[]
      modifiers:
        CSharp:
        - public
        - static
        - readonly
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD
      commentId: F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD
      language: CSharp
      name:
        CSharp: RFD_YYYY_MM_DD
        VB: RFD_YYYY_MM_DD
      nameWithType:
        CSharp: SysDateFormatters.RFD_YYYY_MM_DD
        VB: SysDateFormatters.RFD_YYYY_MM_DD
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD
        VB: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_YYYY_MM_DD
        path: ../Core/SysDateFormatters.cs
        startLine: 214
      summary: "\nApply the following format to a date: YYYY/MM/DD\n\nWith respect to the date only, this format confirms to the ISO 8601\nstandard for time representation.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_YYYY_MM_DD = "^YYYY/^MM/^DD"
          VB: Public Const RFD_YYYY_MM_DD As String = "^YYYY/^MM/^DD"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_MM_DD_YY
      commentId: F:WizardWrx.SysDateFormatters.RFD_MM_DD_YY
      language: CSharp
      name:
        CSharp: RFD_MM_DD_YY
        VB: RFD_MM_DD_YY
      nameWithType:
        CSharp: SysDateFormatters.RFD_MM_DD_YY
        VB: SysDateFormatters.RFD_MM_DD_YY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_MM_DD_YY
        VB: WizardWrx.SysDateFormatters.RFD_MM_DD_YY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_MM_DD_YY
        path: ../Core/SysDateFormatters.cs
        startLine: 224
      summary: "\nApply the following format to a date: MM/DD/YY\n\nThis is the standard short format used in the USA.\n\nOnly the date is returned, including only the year of century, and\nthe month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_MM_DD_YY = "^MM/^DD/^YY"
          VB: Public Const RFD_MM_DD_YY As String = "^MM/^DD/^YY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_MM_DD_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_MM_DD_YYYY
      language: CSharp
      name:
        CSharp: RFD_MM_DD_YYYY
        VB: RFD_MM_DD_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_MM_DD_YYYY
        VB: SysDateFormatters.RFD_MM_DD_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_MM_DD_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_MM_DD_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_MM_DD_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 234
      summary: "\nApply the following format to a date: MM/DD/YYYY\n\nThis is the standard format used in the USA.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_MM_DD_YYYY = "^MM/^DD/^YYYY"
          VB: Public Const RFD_MM_DD_YYYY As String = "^MM/^DD/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_DD_MM_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_DD_MM_YYYY
      language: CSharp
      name:
        CSharp: RFD_DD_MM_YYYY
        VB: RFD_DD_MM_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_DD_MM_YYYY
        VB: SysDateFormatters.RFD_DD_MM_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_DD_MM_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_DD_MM_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_DD_MM_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 246
      summary: "\nApply the following format to a date: DD/MM/YYYY\n\nThis is the standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_DD_MM_YYYY = "^DD/^MM/^YYYY"
          VB: Public Const RFD_DD_MM_YYYY As String = "^DD/^MM/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_HH_MM
      commentId: F:WizardWrx.SysDateFormatters.RFD_HH_MM
      language: CSharp
      name:
        CSharp: RFD_HH_MM
        VB: RFD_HH_MM
      nameWithType:
        CSharp: SysDateFormatters.RFD_HH_MM
        VB: SysDateFormatters.RFD_HH_MM
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_HH_MM
        VB: WizardWrx.SysDateFormatters.RFD_HH_MM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_HH_MM
        path: ../Core/SysDateFormatters.cs
        startLine: 262
      summary: "\nApply the following format to a time: hh:mm\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis is a standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the time is returned, and the hour and minute have leading\nzeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_HH_MM = "^hh:^mm"
          VB: Public Const RFD_HH_MM As String = "^hh:^mm"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_HH_MM_SS
      commentId: F:WizardWrx.SysDateFormatters.RFD_HH_MM_SS
      language: CSharp
      name:
        CSharp: RFD_HH_MM_SS
        VB: RFD_HH_MM_SS
      nameWithType:
        CSharp: SysDateFormatters.RFD_HH_MM_SS
        VB: SysDateFormatters.RFD_HH_MM_SS
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_HH_MM_SS
        VB: WizardWrx.SysDateFormatters.RFD_HH_MM_SS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_HH_MM_SS
        path: ../Core/SysDateFormatters.cs
        startLine: 278
      summary: "\nApply the following format to a time: hh:mm:ss\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis is a standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the time is returned, and the hour, minute, and second have \nleading zeros if any of them is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_HH_MM_SS = "^hh:^mm:^ss"
          VB: Public Const RFD_HH_MM_SS As String = "^hh:^mm:^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_HH_MM_SS_TTT
      commentId: F:WizardWrx.SysDateFormatters.RFD_HH_MM_SS_TTT
      language: CSharp
      name:
        CSharp: RFD_HH_MM_SS_TTT
        VB: RFD_HH_MM_SS_TTT
      nameWithType:
        CSharp: SysDateFormatters.RFD_HH_MM_SS_TTT
        VB: SysDateFormatters.RFD_HH_MM_SS_TTT
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_HH_MM_SS_TTT
        VB: WizardWrx.SysDateFormatters.RFD_HH_MM_SS_TTT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_HH_MM_SS_TTT
        path: ../Core/SysDateFormatters.cs
        startLine: 298
      summary: "\nApply the following format to a time: hh:mm:ss.ttt\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThe final token, ttt, is the milliseconds portion of the time,\nwhich is reported with leading zeros.\n\nThis is an extension of a standard format used in most of the\nEnglish speaking world, by all military organizations of which I am\naware, Europeans, and others who take their lead from any of the\nabove groups.\n\nOnly the time is returned, and the hour, minute, and second have \nleading zeros if any of them is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_HH_MM_SS_TTT = "^hh:^mm:^ss.^ttt"
          VB: Public Const RFD_HH_MM_SS_TTT As String = "^hh:^mm:^ss.^ttt"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
      commentId: F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
      language: CSharp
      name:
        CSharp: RFD_YYYY_MM_DD_HH_MM_SS
        VB: RFD_YYYY_MM_DD_HH_MM_SS
      nameWithType:
        CSharp: SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
        VB: SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
        VB: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_YYYY_MM_DD_HH_MM_SS
        path: ../Core/SysDateFormatters.cs
        startLine: 313
      summary: "\nApply the following format to a date and time: YYYY/MM/DD hh:mm:ss\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis format conforms fully to the ISO 8601 standard for time\nrepresentation.\n\nThe month, day, hour, minute, and second have leading zeros if any\nof them is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_YYYY_MM_DD_HH_MM_SS = "^YYYY/^MM/^DD ^hh:^mm:^ss"
          VB: Public Const RFD_YYYY_MM_DD_HH_MM_SS As String = "^YYYY/^MM/^DD ^hh:^mm:^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
      commentId: F:WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
      language: CSharp
      name:
        CSharp: RFD_YYYY_MM_DD_HH_MM_SS_TTT
        VB: RFD_YYYY_MM_DD_HH_MM_SS_TTT
      nameWithType:
        CSharp: SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
        VB: SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
        VB: WizardWrx.SysDateFormatters.RFD_YYYY_MM_DD_HH_MM_SS_TTT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_YYYY_MM_DD_HH_MM_SS_TTT
        path: ../Core/SysDateFormatters.cs
        startLine: 331
      summary: "\nApply the following format to a date and time: YYYY/MM/DD hh:mm:ss.ttt\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis format conforms fully to the ISO 8601 standard for time\nrepresentation.\n\nThe final token, ttt, is the milliseconds portion of the time,\nwhich is reported with leading zeros.\n\nThe month, day, hour, minute, and second have leading zeros if any\nof them is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_YYYY_MM_DD_HH_MM_SS_TTT = "^YYYY/^MM/^DD ^hh:^mm:^ss.^ttt"
          VB: Public Const RFD_YYYY_MM_DD_HH_MM_SS_TTT As String = "^YYYY/^MM/^DD ^hh:^mm:^ss.^ttt"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WWW_DD_MM_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WWW_DD_MM_YYYY
      language: CSharp
      name:
        CSharp: RFD_WWW_DD_MM_YYYY
        VB: RFD_WWW_DD_MM_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WWW_DD_MM_YYYY
        VB: SysDateFormatters.RFD_WWW_DD_MM_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WWW_DD_MM_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WWW_DD_MM_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WWW_DD_MM_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 348
      summary: "\nApply the following format to a date: WWW DD/MM/YYYY\n\nThe first token, WWW, represents the three letter abbreviation of\nthe weekday name, which is derived from the regional settings in the\nWindows Control Panel. The returned string conforms to the settings\nin the UICulture of the calling thread.\n\nThis is the standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WWW_DD_MM_YYYY = "^WWW ^DD/^MM/^YYYY"
          VB: Public Const RFD_WWW_DD_MM_YYYY As String = "^WWW ^DD/^MM/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WWW_MM_DD_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WWW_MM_DD_YYYY
      language: CSharp
      name:
        CSharp: RFD_WWW_MM_DD_YYYY
        VB: RFD_WWW_MM_DD_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WWW_MM_DD_YYYY
        VB: SysDateFormatters.RFD_WWW_MM_DD_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WWW_MM_DD_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WWW_MM_DD_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WWW_MM_DD_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 363
      summary: "\nApply the following format to a date: WWW DD/MM/YYYY\n\nThe first token, WWW, represents the three letter abbreviation of\nthe weekday name, which is derived from the regional settings in the\nWindows Control Panel. The returned string conforms to the settings\nin the UICulture of the calling thread.\n\nThis is the standard format used in the USA.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WWW_MM_DD_YYYY = "^WWW ^MM/^DD/^YYYY"
          VB: Public Const RFD_WWW_MM_DD_YYYY As String = "^WWW ^MM/^DD/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WW_DD_MM_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WW_DD_MM_YYYY
      language: CSharp
      name:
        CSharp: RFD_WW_DD_MM_YYYY
        VB: RFD_WW_DD_MM_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WW_DD_MM_YYYY
        VB: SysDateFormatters.RFD_WW_DD_MM_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WW_DD_MM_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WW_DD_MM_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WW_DD_MM_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 381
      summary: "\nApply the following format to a date: WW DD/MM/YYYY\n\nThe first token, WW, represents enough of the three letter weekday\nname abbreviation, which is derived from the regional settings in\nthe Windows Control Panel, to uniquely identify the weekday. The\nreturned string conforms to the settings in the UICulture of the\ncalling thread.\n\nThis is the standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WW_DD_MM_YYYY = "^WW ^DD/^MM/^YYYY"
          VB: Public Const RFD_WW_DD_MM_YYYY As String = "^WW ^DD/^MM/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WW_MM_DD_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WW_MM_DD_YYYY
      language: CSharp
      name:
        CSharp: RFD_WW_MM_DD_YYYY
        VB: RFD_WW_MM_DD_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WW_MM_DD_YYYY
        VB: SysDateFormatters.RFD_WW_MM_DD_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WW_MM_DD_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WW_MM_DD_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WW_MM_DD_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 397
      summary: "\nApply the following format to a date: WW DD/MM/YYYY\n\nThe first token, WW, represents enough of the three letter weekday\nname abbreviation, which is derived from the regional settings in\nthe Windows Control Panel, to uniquely identify the weekday. The\nreturned string conforms to the settings in the UICulture of the\ncalling thread.\n\nThis is the standard format used in the USA.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WW_MM_DD_YYYY = "^WW ^MM/^DD/^YYYY"
          VB: Public Const RFD_WW_MM_DD_YYYY As String = "^WW ^MM/^DD/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WWWW_DD_MM_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WWWW_DD_MM_YYYY
      language: CSharp
      name:
        CSharp: RFD_WWWW_DD_MM_YYYY
        VB: RFD_WWWW_DD_MM_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WWWW_DD_MM_YYYY
        VB: SysDateFormatters.RFD_WWWW_DD_MM_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WWWW_DD_MM_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WWWW_DD_MM_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WWWW_DD_MM_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 414
      summary: "\nApply the following format to a date: WWWW DD/MM/YYYY\n\nThe first token, WWWW, represents full name of the weekday, which is\nderived from the regional settings in the Windows Control Panel. The\nreturned string conforms to the settings in the UICulture of the\ncalling thread.\n\nThis is the standard format used in most of the English speaking\nworld, by all military organizations of which I am aware, Europeans,\nand others who take their lead from any of the above groups.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WWWW_DD_MM_YYYY = "^WWWW, ^DD/^MM/^YYYY"
          VB: Public Const RFD_WWWW_DD_MM_YYYY As String = "^WWWW, ^DD/^MM/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFD_WWWW_MM_DD_YYYY
      commentId: F:WizardWrx.SysDateFormatters.RFD_WWWW_MM_DD_YYYY
      language: CSharp
      name:
        CSharp: RFD_WWWW_MM_DD_YYYY
        VB: RFD_WWWW_MM_DD_YYYY
      nameWithType:
        CSharp: SysDateFormatters.RFD_WWWW_MM_DD_YYYY
        VB: SysDateFormatters.RFD_WWWW_MM_DD_YYYY
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFD_WWWW_MM_DD_YYYY
        VB: WizardWrx.SysDateFormatters.RFD_WWWW_MM_DD_YYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFD_WWWW_MM_DD_YYYY
        path: ../Core/SysDateFormatters.cs
        startLine: 429
      summary: "\nApply the following format to a date: WWWW DD/MM/YYYY\n\nThe first token, WWWW, represents full name of the weekday, which is\nderived from the regional settings in the Windows Control Panel. The\nreturned string conforms to the settings in the UICulture of the\ncalling thread.\n\nThis is the standard format used in the USA.\n\nOnly the date is returned, all four digits of the year are included,\nand the month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFD_WWWW_MM_DD_YYYY = "^WWWW, ^MM/^DD/^YYYY"
          VB: Public Const RFD_WWWW_MM_DD_YYYY As String = "^WWWW, ^MM/^DD/^YYYY"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFDYYYYMMDD_HHMMSS
      commentId: F:WizardWrx.SysDateFormatters.RFDYYYYMMDD_HHMMSS
      language: CSharp
      name:
        CSharp: RFDYYYYMMDD_HHMMSS
        VB: RFDYYYYMMDD_HHMMSS
      nameWithType:
        CSharp: SysDateFormatters.RFDYYYYMMDD_HHMMSS
        VB: SysDateFormatters.RFDYYYYMMDD_HHMMSS
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFDYYYYMMDD_HHMMSS
        VB: WizardWrx.SysDateFormatters.RFDYYYYMMDD_HHMMSS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFDYYYYMMDD_HHMMSS
        path: ../Core/SysDateFormatters.cs
        startLine: 444
      summary: "\nApply the following format to a date and time: YYYYMMDD_hhmmss\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis format conforms fully to the ISO 8601 standard for time\nrepresentation.\n\nThe month, day, hour, minute, and second have leading zeros if any\nof them is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFDYYYYMMDD_HHMMSS = "^YYYY^MM^DD_^hh^mm^ss"
          VB: Public Const RFDYYYYMMDD_HHMMSS As String = "^YYYY^MM^DD_^hh^mm^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFDYYYYMMDD
      commentId: F:WizardWrx.SysDateFormatters.RFDYYYYMMDD
      language: CSharp
      name:
        CSharp: RFDYYYYMMDD
        VB: RFDYYYYMMDD
      nameWithType:
        CSharp: SysDateFormatters.RFDYYYYMMDD
        VB: SysDateFormatters.RFDYYYYMMDD
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFDYYYYMMDD
        VB: WizardWrx.SysDateFormatters.RFDYYYYMMDD
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFDYYYYMMDD
        path: ../Core/SysDateFormatters.cs
        startLine: 458
      summary: "\nApply the following format to a date and time: YYYYMMDD\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis format conforms fully to the ISO 8601 standard for time\nrepresentation.\n\nThe month and day have leading zeros if either is less than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFDYYYYMMDD = "^YYYY^MM^DD"
          VB: Public Const RFDYYYYMMDD As String = "^YYYY^MM^DD"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.RFDHHMMSS
      commentId: F:WizardWrx.SysDateFormatters.RFDHHMMSS
      language: CSharp
      name:
        CSharp: RFDHHMMSS
        VB: RFDHHMMSS
      nameWithType:
        CSharp: SysDateFormatters.RFDHHMMSS
        VB: SysDateFormatters.RFDHHMMSS
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.RFDHHMMSS
        VB: WizardWrx.SysDateFormatters.RFDHHMMSS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RFDHHMMSS
        path: ../Core/SysDateFormatters.cs
        startLine: 474
      summary: "\nApply the following format to a date and time: hhmmss\n\nThe returned string represents the hours on a 24 hour clock.\n\nAt present, 12 hour (AM/PM) representation is unsupported.\n\nThis format conforms fully to the ISO 8601 standard for time\nrepresentation.\n\nThe hour, minute, and second have leading zeros if any of them is\nless than 10.\n"
      example: []
      syntax:
        content:
          CSharp: public const string RFDHHMMSS = "^hh^mm^ss"
          VB: Public Const RFDHHMMSS As String = "^hh^mm^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
      commentId: F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
      language: CSharp
      name:
        CSharp: STANDARD_DISPLAY_DATE_FORMAT
        VB: STANDARD_DISPLAY_DATE_FORMAT
      nameWithType:
        CSharp: SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
        VB: SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
        VB: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_FORMAT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: STANDARD_DISPLAY_DATE_FORMAT
        path: ../Core/SysDateFormatters.cs
        startLine: 486
      summary: "\nI use this with my SysDateFormatters class to format a date (sans\ntime) so that it prints as YYYY/MM/DD.\n\nIMPORTANT: This string specifically targets the methods in the\nSysDateFormatters class. SysDateFormatters strings are incompatible\nwith ToString.\n"
      example:
      - "\n2014/09/04\n"
      syntax:
        content:
          CSharp: public const string STANDARD_DISPLAY_DATE_FORMAT = "^YYYY/^MM/^DD"
          VB: Public Const STANDARD_DISPLAY_DATE_FORMAT As String = "^YYYY/^MM/^DD"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
      commentId: F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
      language: CSharp
      name:
        CSharp: STANDARD_DISPLAY_DATE_TIME_FORMAT
        VB: STANDARD_DISPLAY_DATE_TIME_FORMAT
      nameWithType:
        CSharp: SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
        VB: SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
        VB: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_DATE_TIME_FORMAT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: STANDARD_DISPLAY_DATE_TIME_FORMAT
        path: ../Core/SysDateFormatters.cs
        startLine: 499
      summary: "\nI use this with my SysDateFormatters class to format a date and time\nso that it prints as YYYY/MM/DD HH:MM:SS.\n\nIMPORTANT: This string specifically targets the methods in the\nSysDateFormatters class. SysDateFormatters strings are incompatible\nwith ToString.\n"
      example:
      - "\n2014/09/04 16:17:30\n"
      syntax:
        content:
          CSharp: public const string STANDARD_DISPLAY_DATE_TIME_FORMAT = "^YYYY/^MM/^DD ^hh:^mm:^ss"
          VB: Public Const STANDARD_DISPLAY_DATE_TIME_FORMAT As String = "^YYYY/^MM/^DD ^hh:^mm:^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
      commentId: F:WizardWrx.SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
      language: CSharp
      name:
        CSharp: STANDARD_DISPLAY_TIME_FORMAT
        VB: STANDARD_DISPLAY_TIME_FORMAT
      nameWithType:
        CSharp: SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
        VB: SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
        VB: WizardWrx.SysDateFormatters.STANDARD_DISPLAY_TIME_FORMAT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: STANDARD_DISPLAY_TIME_FORMAT
        path: ../Core/SysDateFormatters.cs
        startLine: 512
      summary: "\nI use this with my SysDateFormatters class to format a time (sans\ndate) so that it prints as HH:MM:SS.\n\nIMPORTANT: This string specifically targets the methods in the\nSysDateFormatters class. SysDateFormatters strings are incompatible\nwith ToString.\n"
      example:
      - "\n16:17:30\n"
      syntax:
        content:
          CSharp: public const string STANDARD_DISPLAY_TIME_FORMAT = "^hh:^mm:^ss"
          VB: Public Const STANDARD_DISPLAY_TIME_FORMAT As String = "^hh:^mm:^ss"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.TZ_NAME_FULL
      commentId: F:WizardWrx.SysDateFormatters.TZ_NAME_FULL
      language: CSharp
      name:
        CSharp: TZ_NAME_FULL
        VB: TZ_NAME_FULL
      nameWithType:
        CSharp: SysDateFormatters.TZ_NAME_FULL
        VB: SysDateFormatters.TZ_NAME_FULL
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.TZ_NAME_FULL
        VB: WizardWrx.SysDateFormatters.TZ_NAME_FULL
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TZ_NAME_FULL
        path: ../Core/SysDateFormatters.cs
        startLine: 520
      summary: "\nSpecify this constant as the pfAbbreviateTZName argument value to\nmethod GetDisplayTimeZone to explicitly elicit the default (legacy)\nbehavior of returning the system-defined (spelled out) time zone\nname.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool TZ_NAME_FULL = false
          VB: Public Const TZ_NAME_FULL As Boolean = False
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.TZ_NAME_ABBR
      commentId: F:WizardWrx.SysDateFormatters.TZ_NAME_ABBR
      language: CSharp
      name:
        CSharp: TZ_NAME_ABBR
        VB: TZ_NAME_ABBR
      nameWithType:
        CSharp: SysDateFormatters.TZ_NAME_ABBR
        VB: SysDateFormatters.TZ_NAME_ABBR
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.TZ_NAME_ABBR
        VB: WizardWrx.SysDateFormatters.TZ_NAME_ABBR
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TZ_NAME_ABBR
        path: ../Core/SysDateFormatters.cs
        startLine: 526
      example: []
      syntax:
        content:
          CSharp: public const bool TZ_NAME_ABBR = true
          VB: Public Const TZ_NAME_ABBR As Boolean = True
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.SysDateFormatters.FormatDateForShow(System.DateTime)
      commentId: M:WizardWrx.SysDateFormatters.FormatDateForShow(System.DateTime)
      language: CSharp
      name:
        CSharp: FormatDateForShow(DateTime)
        VB: FormatDateForShow(DateTime)
      nameWithType:
        CSharp: SysDateFormatters.FormatDateForShow(DateTime)
        VB: SysDateFormatters.FormatDateForShow(DateTime)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.FormatDateForShow(System.DateTime)
        VB: WizardWrx.SysDateFormatters.FormatDateForShow(System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDateForShow
        path: ../Core/SysDateFormatters.cs
        startLine: 695
      summary: "\nUse my standard format string for displaying date stamps in\nreports, to format a DateTime structure.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FormatDateForShow(DateTime pdtmTestDate)
          VB: Public Shared Function FormatDateForShow(pdtmTestDate As Date) As String
        parameters:
        - id: pdtmTestDate
          type: System.DateTime
          description: "\nSpecify the populated DateTime to be formatted. Since only the date\ngoes into the format, the time component MAY be uninitialized.\n"
        return:
          type: System.String
          description: "\nThe return value is a string representation of the date and time,\nrendered according to constant STANDARD_DISPLAY_TIME_FORMAT.\n"
      overload: WizardWrx.SysDateFormatters.FormatDateForShow*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.SysDateFormatters.FormatDateTimeForShow(System.DateTime)
      commentId: M:WizardWrx.SysDateFormatters.FormatDateTimeForShow(System.DateTime)
      language: CSharp
      name:
        CSharp: FormatDateTimeForShow(DateTime)
        VB: FormatDateTimeForShow(DateTime)
      nameWithType:
        CSharp: SysDateFormatters.FormatDateTimeForShow(DateTime)
        VB: SysDateFormatters.FormatDateTimeForShow(DateTime)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.FormatDateTimeForShow(System.DateTime)
        VB: WizardWrx.SysDateFormatters.FormatDateTimeForShow(System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatDateTimeForShow
        path: ../Core/SysDateFormatters.cs
        startLine: 716
      summary: "\nUse my standard format string for displaying date/time stamps in\nreports, to format a DateTime structure.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FormatDateTimeForShow(DateTime pdtmTestDate)
          VB: Public Shared Function FormatDateTimeForShow(pdtmTestDate As Date) As String
        parameters:
        - id: pdtmTestDate
          type: System.DateTime
          description: "\nSpecify the populated DateTime to be formatted. Since the date and\ntime go into the output string, the entire structure must be\ninitialized.\n"
        return:
          type: System.String
          description: "\nThe return value is a string representation of the date and time,\nrendered according to constant STANDARD_DISPLAY_DATE_TIME_FORMAT.\n"
      overload: WizardWrx.SysDateFormatters.FormatDateTimeForShow*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.SysDateFormatters.FormatTimeForShow(System.DateTime)
      commentId: M:WizardWrx.SysDateFormatters.FormatTimeForShow(System.DateTime)
      language: CSharp
      name:
        CSharp: FormatTimeForShow(DateTime)
        VB: FormatTimeForShow(DateTime)
      nameWithType:
        CSharp: SysDateFormatters.FormatTimeForShow(DateTime)
        VB: SysDateFormatters.FormatTimeForShow(DateTime)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.FormatTimeForShow(System.DateTime)
        VB: WizardWrx.SysDateFormatters.FormatTimeForShow(System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatTimeForShow
        path: ../Core/SysDateFormatters.cs
        startLine: 736
      summary: "\nUse my standard format string for displaying time stamps in reports,\nto format a DateTime structure.\n"
      example: []
      syntax:
        content:
          CSharp: public static string FormatTimeForShow(DateTime pdtmTestDate)
          VB: Public Shared Function FormatTimeForShow(pdtmTestDate As Date) As String
        parameters:
        - id: pdtmTestDate
          type: System.DateTime
          description: "\nSpecify the populated DateTime to be formatted. Since only the time\ngoes into the format, the date component MAY be uninitialized.\n"
        return:
          type: System.String
          description: "\nThe return value is a string representation of the date and time,\nrendered according to constant STANDARD_DISPLAY_TIME_FORMAT.\n"
      overload: WizardWrx.SysDateFormatters.FormatTimeForShow*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.SysDateFormatters.GetDisplayTimeZone(System.DateTime,System.String,System.Boolean)
      commentId: M:WizardWrx.SysDateFormatters.GetDisplayTimeZone(System.DateTime,System.String,System.Boolean)
      language: CSharp
      name:
        CSharp: GetDisplayTimeZone(DateTime, String, Boolean)
        VB: GetDisplayTimeZone(DateTime, String, Boolean)
      nameWithType:
        CSharp: SysDateFormatters.GetDisplayTimeZone(DateTime, String, Boolean)
        VB: SysDateFormatters.GetDisplayTimeZone(DateTime, String, Boolean)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.GetDisplayTimeZone(System.DateTime, System.String, System.Boolean)
        VB: WizardWrx.SysDateFormatters.GetDisplayTimeZone(System.DateTime, System.String, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetDisplayTimeZone
        path: ../Core/SysDateFormatters.cs
        startLine: 788
      summary: "\nGiven a DateTime and a system time zone ID string, return the\nappropriate text to display, depending on whether the specified time\nis standard or Daylight Saving Time.\n"
      remarks: "\nif in doubt, use TimeZoneInfo.GetSystemTimeZones to enumerate the\ntime zones installed on the local machine. Invalid time zone strings\nalways give rise to one of a number of exceptions, all of which are\nfully described in the documentation of a companion function,\nGetSystemTimeZoneInfo which this routine uses to get the time zone\ninformation that it needs.\n"
      example: []
      syntax:
        content:
          CSharp: public static string GetDisplayTimeZone(DateTime pdtmTestDate, string pstrTimeZoneID, bool pfAbbreviateTZName = false)
          VB: Public Shared Function GetDisplayTimeZone(pdtmTestDate As Date, pstrTimeZoneID As String, pfAbbreviateTZName As Boolean = False) As String
        parameters:
        - id: pdtmTestDate
          type: System.DateTime
          description: "\nSpecify the Syatem.DateTime for which the appropriate time zone\nstring is required. Both DateTime.MinValue and DateTime.MaxValue are\ninvalid; specifying either elicits the empty string.\n"
        - id: pstrTimeZoneID
          type: System.String
          description: "\nSpecify a valid time zone ID string. Please see the Remarks.\n"
        - id: pfAbbreviateTZName
          type: System.Boolean
          description: "\n<p>\nSpecify TZ_NAME_ABBR (Boolean True) to cause the method to return\nthe abbreviated time zone name that it constructs from the full\n(spelled out) name that is the system default.\n</p>\n<p>\nYou may also specify TZ_NAME_FULL to explicitly cause the full time\nzone name to be returned.\n</p>\n<p>\nIf this argument is omitted, the full time zone name is returned, so\nthat this method is backwards compatible.\n</p>\n"
        return:
          type: System.String
          description: "\nIf the function succeeds, the return value is the appropriate string\nto display for the given time. Otherwise, the empty string is\nreturned or one of several exceptions is thrown, the most likely of\nwhich is a TimeZoneNotFoundException, which is thrown when the\nspecified time zone ID string is invalid.\n"
      overload: WizardWrx.SysDateFormatters.GetDisplayTimeZone*
      see:
      - linkId: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
        commentId: M:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String): 
    - id: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
      commentId: M:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
      language: CSharp
      name:
        CSharp: GetSystemTimeZoneInfo(String)
        VB: GetSystemTimeZoneInfo(String)
      nameWithType:
        CSharp: SysDateFormatters.GetSystemTimeZoneInfo(String)
        VB: SysDateFormatters.GetSystemTimeZoneInfo(String)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
        VB: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSystemTimeZoneInfo
        path: ../Core/SysDateFormatters.cs
        startLine: 865
      summary: "\nGiven a system time zone ID string, return the corresponding\nTimeZoneInfo object if the specified time zone is defined on the\nlocal system.\n"
      remarks: "\nif in doubt, use TimeZoneInfo.GetSystemTimeZones to enumerate the\ntime zones installed on the local machine.\n"
      example: []
      syntax:
        content:
          CSharp: public static TimeZoneInfo GetSystemTimeZoneInfo(string pstrTimeZoneID)
          VB: Public Shared Function GetSystemTimeZoneInfo(pstrTimeZoneID As String) As TimeZoneInfo
        parameters:
        - id: pstrTimeZoneID
          type: System.String
          description: "\nSpecify a valid time zone ID string. There are two special IDs,\nLocalTime and UTC, both of which are accessible through static\nproperties on the TimeZoneInfo class. Although you could use the ID\nproperties with this method, the most efficient way to handle these\nspecial cases is by reference to the Local property for LocalTime\nand the UTC property for UTC time. (This method could take the same\nshortcut, but I decided that it wasn&apos;t worth the extra code and\ntesting.\n"
        return:
          type: System.TimeZoneInfo
          description: "\nIf the function succeeds, the return value is a TimeZoneInfo object,\npopulated from the Windows Registry. Otherwise, one of the\nexceptions listed and described below is thrown.\n"
      overload: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo*
      exceptions:
      - type: System.OutOfMemoryException
        commentId: T:System.OutOfMemoryException
        description: "\nYou should restart Windows if this happens.\n"
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nContact the author of the program. This is something that he or she\nmust address.\n"
      - type: System.TimeZoneNotFoundException
        commentId: T:System.TimeZoneNotFoundException
        description: "\nContact the author of the program. This is something that he or she\nmust address.\n"
      - type: System.Security.SecurityException
        commentId: T:System.Security.SecurityException
        description: "\nContact your system administrator to inquire about why your program\nis forbidden to read the regional settings from the Windows\nRegistry.\n"
      - type: System.InvalidTimeZoneException
        commentId: T:System.InvalidTimeZoneException
        description: "\nContact your system support group. A corrupted Windows Registry is a\nrare, but serious matter.\n"
      - type: System.Exception
        commentId: T:System.Exception
        description: "\nStart with your system support group, who may need to request the\nassistance of the author of the program.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.OutOfMemoryException: 
        System.ArgumentNullException: 
        System.TimeZoneNotFoundException: 
        System.Security.SecurityException: 
        System.InvalidTimeZoneException: 
        System.Exception: 
    - id: WizardWrx.SysDateFormatters.ReformatNow(System.String)
      commentId: M:WizardWrx.SysDateFormatters.ReformatNow(System.String)
      language: CSharp
      name:
        CSharp: ReformatNow(String)
        VB: ReformatNow(String)
      nameWithType:
        CSharp: SysDateFormatters.ReformatNow(String)
        VB: SysDateFormatters.ReformatNow(String)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.ReformatNow(System.String)
        VB: WizardWrx.SysDateFormatters.ReformatNow(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReformatNow
        path: ../Core/SysDateFormatters.cs
        startLine: 944
      summary: "\nThis method has a nearly exact analogue in the constellations of WIL\nUser Defined Functions that gave rise to its immediate predecessor,\na like named function implemented in straight C, with a little help\nfrom the Windows National Language Subsystem, which underlies the\nCultureInfo class.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReformatNow(string pstrFormat)
          VB: Public Shared Function ReformatNow(pstrFormat As String) As String
        parameters:
        - id: pstrFormat
          type: System.String
          description: "\nThis System.String is a combination of tokens and literal text that\ngoverns the formatting of the date.\n"
        return:
          type: System.String
          description: "\nThe return value is a string containing the current date and time,\nformatted according to the rules spelled out in format string\npstrFormat.\n"
      overload: WizardWrx.SysDateFormatters.ReformatNow*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.SysDateFormatters.ReformatUtcNow(System.String)
      commentId: M:WizardWrx.SysDateFormatters.ReformatUtcNow(System.String)
      language: CSharp
      name:
        CSharp: ReformatUtcNow(String)
        VB: ReformatUtcNow(String)
      nameWithType:
        CSharp: SysDateFormatters.ReformatUtcNow(String)
        VB: SysDateFormatters.ReformatUtcNow(String)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.ReformatUtcNow(System.String)
        VB: WizardWrx.SysDateFormatters.ReformatUtcNow(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReformatUtcNow
        path: ../Core/SysDateFormatters.cs
        startLine: 962
      summary: "\nIn the original constellation of WinBatch functions and their C\ndescendants, this function took the form of an optional argument to\nReformatNow. I think I prefer this way.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReformatUtcNow(string pstrFormat)
          VB: Public Shared Function ReformatUtcNow(pstrFormat As String) As String
        parameters:
        - id: pstrFormat
          type: System.String
          description: "\nThis System.String is a combination of tokens and literal text that\ngoverns the formatting of the date.\n"
        return:
          type: System.String
          description: "\nThe return value is a string containing the current UTC time,\nformatted according to the rules spelled out in format string\npstrFormat.\n"
      overload: WizardWrx.SysDateFormatters.ReformatUtcNow*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.SysDateFormatters.ReformatSysDate(System.DateTime,System.String)
      commentId: M:WizardWrx.SysDateFormatters.ReformatSysDate(System.DateTime,System.String)
      language: CSharp
      name:
        CSharp: ReformatSysDate(DateTime, String)
        VB: ReformatSysDate(DateTime, String)
      nameWithType:
        CSharp: SysDateFormatters.ReformatSysDate(DateTime, String)
        VB: SysDateFormatters.ReformatSysDate(DateTime, String)
      qualifiedName:
        CSharp: WizardWrx.SysDateFormatters.ReformatSysDate(System.DateTime, System.String)
        VB: WizardWrx.SysDateFormatters.ReformatSysDate(System.DateTime, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/SysDateFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ReformatSysDate
        path: ../Core/SysDateFormatters.cs
        startLine: 983
      summary: "\nReformatSysDate is the core function of the constellation of\nroutines that grew from the original WIL script. Substitution tokens\ndrive construction of a formatted date string.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ReformatSysDate(DateTime pdtmToFormat, string pstrFormat)
          VB: Public Shared Function ReformatSysDate(pdtmToFormat As Date, pstrFormat As String) As String
        parameters:
        - id: pdtmToFormat
          type: System.DateTime
          description: "\nThis System.DateTime is the time to be formatted.\n"
        - id: pstrFormat
          type: System.String
          description: "\nThis System.String is a combination of tokens and literal text that\ngoverns the formatting of the date.\n"
        return:
          type: System.String
          description: "\nThe return value is a string containing the date and/or time in\nargument pdtmToFormat, formatted according to the rules spelled out \nin format string pstrFormat.\n"
      overload: WizardWrx.SysDateFormatters.ReformatSysDate*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    references:
      WizardWrx.DisplayFormats: 
      WizardWrx.Core.TimeDisplayFormatter: 
  - id: WizardWrx.TextBlocks
    commentId: T:WizardWrx.TextBlocks
    language: CSharp
    name:
      CSharp: TextBlocks
      VB: TextBlocks
    nameWithType:
      CSharp: TextBlocks
      VB: TextBlocks
    qualifiedName:
      CSharp: WizardWrx.TextBlocks
      VB: WizardWrx.TextBlocks
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/TextBlocks.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TextBlocks
      path: ../Core/TextBlocks.cs
      startLine: 125
    summary: "\nThis class defines methods for creating and manipulating bounded text blocks.\n"
    example: []
    syntax:
      content:
        CSharp: public class TextBlocks
        VB: Public Class TextBlocks
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.TextBlocks.BLOCK_BEGIN_TEXT
      commentId: F:WizardWrx.TextBlocks.BLOCK_BEGIN_TEXT
      language: CSharp
      name:
        CSharp: BLOCK_BEGIN_TEXT
        VB: BLOCK_BEGIN_TEXT
      nameWithType:
        CSharp: TextBlocks.BLOCK_BEGIN_TEXT
        VB: TextBlocks.BLOCK_BEGIN_TEXT
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.BLOCK_BEGIN_TEXT
        VB: WizardWrx.TextBlocks.BLOCK_BEGIN_TEXT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BLOCK_BEGIN_TEXT
        path: ../Core/TextBlocks.cs
        startLine: 131
      summary: "\nMy text block begin markers always end with this string.\n"
      example: []
      syntax:
        content:
          CSharp: public const string BLOCK_BEGIN_TEXT = "_Begin"
          VB: Public Const BLOCK_BEGIN_TEXT As String = "_Begin"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.TextBlocks.BLOCK_END_TEXT
      commentId: F:WizardWrx.TextBlocks.BLOCK_END_TEXT
      language: CSharp
      name:
        CSharp: BLOCK_END_TEXT
        VB: BLOCK_END_TEXT
      nameWithType:
        CSharp: TextBlocks.BLOCK_END_TEXT
        VB: TextBlocks.BLOCK_END_TEXT
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.BLOCK_END_TEXT
        VB: WizardWrx.TextBlocks.BLOCK_END_TEXT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BLOCK_END_TEXT
        path: ../Core/TextBlocks.cs
        startLine: 136
      summary: "\nMy text block ending markers always end with this string.\n"
      example: []
      syntax:
        content:
          CSharp: public const string BLOCK_END_TEXT = "_End"
          VB: Public Const BLOCK_END_TEXT As String = "_End"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.TextBlocks.#ctor
      commentId: M:WizardWrx.TextBlocks.#ctor
      language: CSharp
      name:
        CSharp: TextBlocks()
        VB: TextBlocks()
      nameWithType:
        CSharp: TextBlocks.TextBlocks()
        VB: TextBlocks.TextBlocks()
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.TextBlocks()
        VB: WizardWrx.TextBlocks.TextBlocks()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/TextBlocks.cs
        startLine: 151
      summary: "\nThe default constructor creates an empty class. Its MarkerText\nproperty must be set before its other properties are useful.\n"
      example: []
      syntax:
        content:
          CSharp: public TextBlocks()
          VB: Public Sub New
      overload: WizardWrx.TextBlocks.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.#ctor(System.String)
      commentId: M:WizardWrx.TextBlocks.#ctor(System.String)
      language: CSharp
      name:
        CSharp: TextBlocks(String)
        VB: TextBlocks(String)
      nameWithType:
        CSharp: TextBlocks.TextBlocks(String)
        VB: TextBlocks.TextBlocks(String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.TextBlocks(System.String)
        VB: WizardWrx.TextBlocks.TextBlocks(System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/TextBlocks.cs
        startLine: 164
      summary: "\nThis overload creates an empty class, and initializes its MarkerText\nproperty.\n"
      example: []
      syntax:
        content:
          CSharp: public TextBlocks(string pstrMarkerText)
          VB: Public Sub New(pstrMarkerText As String)
        parameters:
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
      overload: WizardWrx.TextBlocks.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.#ctor(System.String,System.String)
      commentId: M:WizardWrx.TextBlocks.#ctor(System.String,System.String)
      language: CSharp
      name:
        CSharp: TextBlocks(String, String)
        VB: TextBlocks(String, String)
      nameWithType:
        CSharp: TextBlocks.TextBlocks(String, String)
        VB: TextBlocks.TextBlocks(String, String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.TextBlocks(System.String, System.String)
        VB: WizardWrx.TextBlocks.TextBlocks(System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/TextBlocks.cs
        startLine: 183
      summary: "\nThis overload creates an empty class, and initializes its rInputData\nand MarkerText properties.\n"
      example: []
      syntax:
        content:
          CSharp: public TextBlocks(string pstrInputData, string pstrMarkerText)
          VB: Public Sub New(pstrInputData As String, pstrMarkerText As String)
        parameters:
        - id: pstrInputData
          type: System.String
          description: "\nString containing text from which marked blocks will be extracted.\nAlso sets the InputData property.\n"
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
      overload: WizardWrx.TextBlocks.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.InputData
      commentId: P:WizardWrx.TextBlocks.InputData
      language: CSharp
      name:
        CSharp: InputData
        VB: InputData
      nameWithType:
        CSharp: TextBlocks.InputData
        VB: TextBlocks.InputData
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.InputData
        VB: WizardWrx.TextBlocks.InputData
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InputData
        path: ../Core/TextBlocks.cs
        startLine: 198
      summary: "\nString from which to extract blocks.\n"
      example: []
      syntax:
        content:
          CSharp: public string InputData { get; set; }
          VB: Public Property InputData As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.TextBlocks.InputData*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.TextBlocks.MarkerText
      commentId: P:WizardWrx.TextBlocks.MarkerText
      language: CSharp
      name:
        CSharp: MarkerText
        VB: MarkerText
      nameWithType:
        CSharp: TextBlocks.MarkerText
        VB: TextBlocks.MarkerText
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.MarkerText
        VB: WizardWrx.TextBlocks.MarkerText
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MarkerText
        path: ../Core/TextBlocks.cs
        startLine: 217
      summary: "\nThis is the text that forms the middle (and variable) part of the\nTextBlocks marker strings.\n"
      example: []
      syntax:
        content:
          CSharp: public string MarkerText { get; set; }
          VB: Public Property MarkerText As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.TextBlocks.MarkerText*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.TextBlocks.Prefix
      commentId: P:WizardWrx.TextBlocks.Prefix
      language: CSharp
      name:
        CSharp: Prefix
        VB: Prefix
      nameWithType:
        CSharp: TextBlocks.Prefix
        VB: TextBlocks.Prefix
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.Prefix
        VB: WizardWrx.TextBlocks.Prefix
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Prefix
        path: ../Core/TextBlocks.cs
        startLine: 235
      summary: "\nConstruct, on the fly, and return, the block prefix.\n"
      example: []
      syntax:
        content:
          CSharp: public string Prefix { get; }
          VB: Public ReadOnly Property Prefix As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.TextBlocks.Prefix*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.TextBlocks.Suffix
      commentId: P:WizardWrx.TextBlocks.Suffix
      language: CSharp
      name:
        CSharp: Suffix
        VB: Suffix
      nameWithType:
        CSharp: TextBlocks.Suffix
        VB: TextBlocks.Suffix
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.Suffix
        VB: WizardWrx.TextBlocks.Suffix
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Suffix
        path: ../Core/TextBlocks.cs
        startLine: 254
      summary: "\nConstruct, on the fly, and return, the block suffix.\n"
      example: []
      syntax:
        content:
          CSharp: public string Suffix { get; }
          VB: Public ReadOnly Property Suffix As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.TextBlocks.Suffix*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.TextBlocks.ExtractBlock
      commentId: M:WizardWrx.TextBlocks.ExtractBlock
      language: CSharp
      name:
        CSharp: ExtractBlock()
        VB: ExtractBlock()
      nameWithType:
        CSharp: TextBlocks.ExtractBlock()
        VB: TextBlocks.ExtractBlock()
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlock()
        VB: WizardWrx.TextBlocks.ExtractBlock()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlock
        path: ../Core/TextBlocks.cs
        startLine: 281
      summary: "\nExtract a block marked by text constructed from the string in the\nMarkerText property from the text in the InputData property.\n"
      example: []
      syntax:
        content:
          CSharp: public string ExtractBlock()
          VB: Public Function ExtractBlock As String
        return:
          type: System.String
          description: "\nText between block markers. If the prefix marker is followed by a\nnewline, the newline is removed. Likewise, if the suffix marker is\npreceded by a newline, that newline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlock*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.ExtractBlock(System.String)
      commentId: M:WizardWrx.TextBlocks.ExtractBlock(System.String)
      language: CSharp
      name:
        CSharp: ExtractBlock(String)
        VB: ExtractBlock(String)
      nameWithType:
        CSharp: TextBlocks.ExtractBlock(String)
        VB: TextBlocks.ExtractBlock(String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlock(System.String)
        VB: WizardWrx.TextBlocks.ExtractBlock(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlock
        path: ../Core/TextBlocks.cs
        startLine: 301
      summary: "\nExtract a block marked by text constructed from the string in\nargument pstrMarkerText from the text in the InputData property, and\nupdate the MarkerText property.\n"
      example: []
      syntax:
        content:
          CSharp: public string ExtractBlock(string pstrMarkerText)
          VB: Public Function ExtractBlock(pstrMarkerText As String) As String
        parameters:
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
        return:
          type: System.String
          description: "\nText between block markers. If the prefix marker is followed by a\nnewline, the newline is removed. Likewise, if the suffix marker is\npreceded by a newline, that newline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlock*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.ExtractBlock(System.String,System.String)
      commentId: M:WizardWrx.TextBlocks.ExtractBlock(System.String,System.String)
      language: CSharp
      name:
        CSharp: ExtractBlock(String, String)
        VB: ExtractBlock(String, String)
      nameWithType:
        CSharp: TextBlocks.ExtractBlock(String, String)
        VB: TextBlocks.ExtractBlock(String, String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlock(System.String, System.String)
        VB: WizardWrx.TextBlocks.ExtractBlock(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlock
        path: ../Core/TextBlocks.cs
        startLine: 329
      summary: "\nExtract a block marked by text constructed from the string in\nargument pstrMarkerText from the text in argument pstrInputData.\nUpdate the InputData and MarkerText properties.\n"
      example: []
      syntax:
        content:
          CSharp: public string ExtractBlock(string pstrInputData, string pstrMarkerText)
          VB: Public Function ExtractBlock(pstrInputData As String, pstrMarkerText As String) As String
        parameters:
        - id: pstrInputData
          type: System.String
          description: "\nString containing text from which marked blocks will be extracted.\nAlso sets the InputData property.\n"
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
        return:
          type: System.String
          description: "\nText between block markers. If the prefix marker is followed by a\nnewline, the newline is removed. Likewise, if the suffix marker is\npreceded by a newline, that newline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlock*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.ExtractBlockToArray
      commentId: M:WizardWrx.TextBlocks.ExtractBlockToArray
      language: CSharp
      name:
        CSharp: ExtractBlockToArray()
        VB: ExtractBlockToArray()
      nameWithType:
        CSharp: TextBlocks.ExtractBlockToArray()
        VB: TextBlocks.ExtractBlockToArray()
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlockToArray()
        VB: WizardWrx.TextBlocks.ExtractBlockToArray()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlockToArray
        path: ../Core/TextBlocks.cs
        startLine: 356
      summary: "\nExtract a block marked by text constructed from the string in\nargument pstrMarkerText from the text in argument pstrInputData.\nUpdate the InputData and MarkerText properties.\n"
      example: []
      syntax:
        content:
          CSharp: public string[] ExtractBlockToArray()
          VB: Public Function ExtractBlockToArray As String()
        return:
          type: System.String[]
          description: "\nArray of strings containing the text between block markers. If the\nprefix marker is followed by a newline, the newline is removed.\nLikewise, if the suffix marker is preceded by a newline, that\nnewline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlockToArray*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.ExtractBlockToArray(System.String)
      commentId: M:WizardWrx.TextBlocks.ExtractBlockToArray(System.String)
      language: CSharp
      name:
        CSharp: ExtractBlockToArray(String)
        VB: ExtractBlockToArray(String)
      nameWithType:
        CSharp: TextBlocks.ExtractBlockToArray(String)
        VB: TextBlocks.ExtractBlockToArray(String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlockToArray(System.String)
        VB: WizardWrx.TextBlocks.ExtractBlockToArray(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlockToArray
        path: ../Core/TextBlocks.cs
        startLine: 376
      summary: "\nExtract a block marked by text constructed from the string in\nargument pstrMarkerText from the text in argument pstrInputData.\nUpdate the InputData and MarkerText properties.\n"
      example: []
      syntax:
        content:
          CSharp: public string[] ExtractBlockToArray(string pstrMarkerText)
          VB: Public Function ExtractBlockToArray(pstrMarkerText As String) As String()
        parameters:
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
        return:
          type: System.String[]
          description: "\nArray of strings containing the text between block markers. If the\nprefix marker is followed by a newline, the newline is removed.\nLikewise, if the suffix marker is preceded by a newline, that\nnewline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlockToArray*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.ExtractBlockToArray(System.String,System.String)
      commentId: M:WizardWrx.TextBlocks.ExtractBlockToArray(System.String,System.String)
      language: CSharp
      name:
        CSharp: ExtractBlockToArray(String, String)
        VB: ExtractBlockToArray(String, String)
      nameWithType:
        CSharp: TextBlocks.ExtractBlockToArray(String, String)
        VB: TextBlocks.ExtractBlockToArray(String, String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.ExtractBlockToArray(System.String, System.String)
        VB: WizardWrx.TextBlocks.ExtractBlockToArray(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractBlockToArray
        path: ../Core/TextBlocks.cs
        startLine: 405
      summary: "\nExtract a block marked by text constructed from the string in\nargument pstrMarkerText from the text in argument pstrInputData.\nUpdate the InputData and MarkerText properties.\n"
      example: []
      syntax:
        content:
          CSharp: public string[] ExtractBlockToArray(string pstrInputData, string pstrMarkerText)
          VB: Public Function ExtractBlockToArray(pstrInputData As String, pstrMarkerText As String) As String()
        parameters:
        - id: pstrInputData
          type: System.String
          description: "\nString containing text from which marked blocks will be extracted.\nAlso sets the InputData property.\n"
        - id: pstrMarkerText
          type: System.String
          description: "\nString containing text from which marker prefixes and suffixes are\nconstructed. Also sets the MarkerText property.\n"
        return:
          type: System.String[]
          description: "\nArray of strings containing the text between block markers. If the\nprefix marker is followed by a newline, the newline is removed.\nLikewise, if the suffix marker is preceded by a newline, that\nnewline is also removed.\n"
      overload: WizardWrx.TextBlocks.ExtractBlockToArray*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.TextBlocks.CharToArray(System.Char)
      commentId: M:WizardWrx.TextBlocks.CharToArray(System.Char)
      language: CSharp
      name:
        CSharp: CharToArray(Char)
        VB: CharToArray(Char)
      nameWithType:
        CSharp: TextBlocks.CharToArray(Char)
        VB: TextBlocks.CharToArray(Char)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.CharToArray(System.Char)
        VB: WizardWrx.TextBlocks.CharToArray(System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CharToArray
        path: ../Core/TextBlocks.cs
        startLine: 433
      summary: "\nReturn a one-element array containing the input character.\n"
      example: []
      syntax:
        content:
          CSharp: public static char[] CharToArray(char pchr)
          VB: Public Shared Function CharToArray(pchr As Char) As Char()
        parameters:
        - id: pchr
          type: System.Char
          description: "\nCharacter to place into the returned array.\n"
        return:
          type: System.Char[]
          description: "\nArray of characters, containing exactly one element, which contains\nthe single input character.\n"
      overload: WizardWrx.TextBlocks.CharToArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.TextBlocks.StringOfLinesToArray(System.String)
      commentId: M:WizardWrx.TextBlocks.StringOfLinesToArray(System.String)
      language: CSharp
      name:
        CSharp: StringOfLinesToArray(String)
        VB: StringOfLinesToArray(String)
      nameWithType:
        CSharp: TextBlocks.StringOfLinesToArray(String)
        VB: TextBlocks.StringOfLinesToArray(String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.StringOfLinesToArray(System.String)
        VB: WizardWrx.TextBlocks.StringOfLinesToArray(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: StringOfLinesToArray
        path: ../Core/TextBlocks.cs
        startLine: 449
      summary: "\nSplit a string containing lines of text into an array of strings.\n"
      example: []
      syntax:
        content:
          CSharp: public static string[] StringOfLinesToArray(string pstrLines)
          VB: Public Shared Function StringOfLinesToArray(pstrLines As String) As String()
        parameters:
        - id: pstrLines
          type: System.String
          description: "\nString containing lines of text, terminated by CR/LF pairs.\n"
        return:
          type: System.String[]
          description: "\nArray of strings, one line per string. Blank lines are preserved as\nempty strings.\n"
      overload: WizardWrx.TextBlocks.StringOfLinesToArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.TextBlocks.StringOfLinesToArray(System.String,System.StringSplitOptions)
      commentId: M:WizardWrx.TextBlocks.StringOfLinesToArray(System.String,System.StringSplitOptions)
      language: CSharp
      name:
        CSharp: StringOfLinesToArray(String, StringSplitOptions)
        VB: StringOfLinesToArray(String, StringSplitOptions)
      nameWithType:
        CSharp: TextBlocks.StringOfLinesToArray(String, StringSplitOptions)
        VB: TextBlocks.StringOfLinesToArray(String, StringSplitOptions)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.StringOfLinesToArray(System.String, System.StringSplitOptions)
        VB: WizardWrx.TextBlocks.StringOfLinesToArray(System.String, System.StringSplitOptions)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: StringOfLinesToArray
        path: ../Core/TextBlocks.cs
        startLine: 484
      summary: "\nSplit a string containing lines of text into an array of strings,\nas modified by the StringSplitOptions flag.\n"
      remarks: "\nUse this overload to convert a string, discarding blank lines.\n"
      example: []
      syntax:
        content:
          CSharp: public static string[] StringOfLinesToArray(string pstrLines, StringSplitOptions penmStringSplitOptions)
          VB: Public Shared Function StringOfLinesToArray(pstrLines As String, penmStringSplitOptions As StringSplitOptions) As String()
        parameters:
        - id: pstrLines
          type: System.String
          description: "\nString containing lines of text, terminated by CR/LF pairs.\n"
        - id: penmStringSplitOptions
          type: System.StringSplitOptions
          description: "\nA member of the StringSplitOptions enumeration, presumably other\nthan StringSplitOptions.None, which is assumed by the first\noverload. The only option supported by version 2 of the Microsoft\n.NET CLR is RemoveEmptyEntries.\n"
        return:
          type: System.String[]
          description: "\nArray of strings, one line per string. Blank lines are preserved as\nempty strings unless penmStringSplitOptions is RemoveEmptyEntries,\nas is most likely to be the case.\n"
      overload: WizardWrx.TextBlocks.StringOfLinesToArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.TextBlocks.StringToArray(System.String)
      commentId: M:WizardWrx.TextBlocks.StringToArray(System.String)
      language: CSharp
      name:
        CSharp: StringToArray(String)
        VB: StringToArray(String)
      nameWithType:
        CSharp: TextBlocks.StringToArray(String)
        VB: TextBlocks.StringToArray(String)
      qualifiedName:
        CSharp: WizardWrx.TextBlocks.StringToArray(System.String)
        VB: WizardWrx.TextBlocks.StringToArray(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TextBlocks.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: StringToArray
        path: ../Core/TextBlocks.cs
        startLine: 509
      summary: "\nReturn a one-element array containing the input string.\n"
      example: []
      syntax:
        content:
          CSharp: public static string[] StringToArray(string pstr)
          VB: Public Shared Function StringToArray(pstr As String) As String()
        parameters:
        - id: pstr
          type: System.String
          description: "\nString to place into the returned array.\n"
        return:
          type: System.String[]
          description: "\nArray of strings, containing exactly one element, which contains\nthe single input string.\n"
      overload: WizardWrx.TextBlocks.StringToArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.TimeZoneInfoExtensions
    commentId: T:WizardWrx.TimeZoneInfoExtensions
    language: CSharp
    name:
      CSharp: TimeZoneInfoExtensions
      VB: TimeZoneInfoExtensions
    nameWithType:
      CSharp: TimeZoneInfoExtensions
      VB: TimeZoneInfoExtensions
    qualifiedName:
      CSharp: WizardWrx.TimeZoneInfoExtensions
      VB: WizardWrx.TimeZoneInfoExtensions
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx
    source:
      remote:
        path: Core/TimeZoneInfoExtensions.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TimeZoneInfoExtensions
      path: ../Core/TimeZoneInfoExtensions.cs
      startLine: 85
    summary: "\nExtend the sealed TimeZoneInfo class to support abbreviated time zone\nnames.\n"
    example: []
    syntax:
      content:
        CSharp: public static class TimeZoneInfoExtensions
        VB: Public Module TimeZoneInfoExtensions
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - isExtensionMethod: true
      id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName(System.TimeZoneInfo)
      commentId: M:WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: AbbreviateDaylightName(TimeZoneInfo)
        VB: AbbreviateDaylightName(TimeZoneInfo)
      nameWithType:
        CSharp: TimeZoneInfoExtensions.AbbreviateDaylightName(TimeZoneInfo)
        VB: TimeZoneInfoExtensions.AbbreviateDaylightName(TimeZoneInfo)
      qualifiedName:
        CSharp: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName(System.TimeZoneInfo)
        VB: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName(System.TimeZoneInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TimeZoneInfoExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AbbreviateDaylightName
        path: ../Core/TimeZoneInfoExtensions.cs
        startLine: 100
      summary: "\nGet the abbreviated time zone Daylight Name.\n"
      example: []
      syntax:
        content:
          CSharp: public static string AbbreviateDaylightName(this TimeZoneInfo ptzi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function AbbreviateDaylightName(ptzi As TimeZoneInfo) As String
        parameters:
        - id: ptzi
          type: System.TimeZoneInfo
          description: "\nSpecify the TimeZoneInfo object to process. This implicit paramteer\nis supplied by the runtime when the extension method is called.\n"
        return:
          type: System.String
          description: "\nThe abbreviated name is constructed from the name specified on the\nDaylightName property on the TimeZoneInfo object by extracting from\nit the first letter of each word.\n"
      overload: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName(System.TimeZoneInfo)
      commentId: M:WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: AbbreviateDisplayName(TimeZoneInfo)
        VB: AbbreviateDisplayName(TimeZoneInfo)
      nameWithType:
        CSharp: TimeZoneInfoExtensions.AbbreviateDisplayName(TimeZoneInfo)
        VB: TimeZoneInfoExtensions.AbbreviateDisplayName(TimeZoneInfo)
      qualifiedName:
        CSharp: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName(System.TimeZoneInfo)
        VB: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName(System.TimeZoneInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TimeZoneInfoExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AbbreviateDisplayName
        path: ../Core/TimeZoneInfoExtensions.cs
        startLine: 125
      summary: "\nGet the abbreviated time zone Display Name.\n"
      example: []
      syntax:
        content:
          CSharp: public static string AbbreviateDisplayName(this TimeZoneInfo ptzi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function AbbreviateDisplayName(ptzi As TimeZoneInfo) As String
        parameters:
        - id: ptzi
          type: System.TimeZoneInfo
          description: "\nSpecify the TimeZoneInfo object to process. This implicit paramteer\nis supplied by the runtime when the extension method is called.\n"
        return:
          type: System.String
          description: "\n<p>\nThe abbreviated name is constructed from the name specified on the\nDisplayName property on the TimeZoneInfo object by extracting from\nit the first letter of each word.\n</p>\n<p>\nThe Display Name sees much less use because it includes the UTC\noffset, which confuses users who are unfamiliar with the details of\nUTC in particular and time zones in general.\n</p>\n"
      overload: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName(System.TimeZoneInfo)
      commentId: M:WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName(System.TimeZoneInfo)
      language: CSharp
      name:
        CSharp: AbbreviatedStandardName(TimeZoneInfo)
        VB: AbbreviatedStandardName(TimeZoneInfo)
      nameWithType:
        CSharp: TimeZoneInfoExtensions.AbbreviatedStandardName(TimeZoneInfo)
        VB: TimeZoneInfoExtensions.AbbreviatedStandardName(TimeZoneInfo)
      qualifiedName:
        CSharp: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName(System.TimeZoneInfo)
        VB: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName(System.TimeZoneInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TimeZoneInfoExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AbbreviatedStandardName
        path: ../Core/TimeZoneInfoExtensions.cs
        startLine: 143
      summary: "\nGet the abbreviated time zone Standard Name.\n"
      example: []
      syntax:
        content:
          CSharp: public static string AbbreviatedStandardName(this TimeZoneInfo ptzi)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function AbbreviatedStandardName(ptzi As TimeZoneInfo) As String
        parameters:
        - id: ptzi
          type: System.TimeZoneInfo
          description: "\nSpecify the TimeZoneInfo object to process. This implicit paramteer\nis supplied by the runtime when the extension method is called.\n"
        return:
          type: System.String
          description: "\nThe abbreviated name is constructed from the name specified on the\nStandardName property on the TimeZoneInfo object by extracting from\nit the first letter of each word.\n"
      overload: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - isExtensionMethod: true
      id: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName(System.TimeZoneInfo,System.DateTime,System.Boolean)
      commentId: M:WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName(System.TimeZoneInfo,System.DateTime,System.Boolean)
      language: CSharp
      name:
        CSharp: GetCurrentTimeZoneName(TimeZoneInfo, DateTime, Boolean)
        VB: GetCurrentTimeZoneName(TimeZoneInfo, DateTime, Boolean)
      nameWithType:
        CSharp: TimeZoneInfoExtensions.GetCurrentTimeZoneName(TimeZoneInfo, DateTime, Boolean)
        VB: TimeZoneInfoExtensions.GetCurrentTimeZoneName(TimeZoneInfo, DateTime, Boolean)
      qualifiedName:
        CSharp: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName(System.TimeZoneInfo, System.DateTime, System.Boolean)
        VB: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName(System.TimeZoneInfo, System.DateTime, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx
      source:
        remote:
          path: Core/TimeZoneInfoExtensions.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetCurrentTimeZoneName
        path: ../Core/TimeZoneInfoExtensions.cs
        startLine: 175
      summary: "\nGiven a DateTime object to establish whether to display the Stanadrd\nName or the Daylight Name, return the appropriate string for the\npart of the year that it represents.\n"
      example: []
      syntax:
        content:
          CSharp: public static string GetCurrentTimeZoneName(this TimeZoneInfo ptzi, DateTime pdtmDateTime, bool pfAbbreviate)
          VB: >-
            <ExtensionAttribute>

            Public Shared Function GetCurrentTimeZoneName(ptzi As TimeZoneInfo, pdtmDateTime As Date, pfAbbreviate As Boolean) As String
        parameters:
        - id: ptzi
          type: System.TimeZoneInfo
          description: "\nSpecify the TimeZoneInfo object to process. This implicit paramteer\nis supplied by the runtime when the extension method is called.\n"
        - id: pdtmDateTime
          type: System.DateTime
          description: "\nThe IsDaylightSavingTime method on the <code data-dev-comment-type=\"paramref\" class=\"paramref\">ptzi</code>\ninstance establishes the correct string to return for the time that\nit represents, assuming that its DateTimeKind property is Local or\nthat it is implicitly interpreted as such.\n"
        - id: pfAbbreviate
          type: System.Boolean
          description: "\nWhen True, this flag causes the abbreviated time zone name to be\ndisplayed. Otherwise, the appropriate string from the extended\nTimeZoneInfo instance is returned.\n"
        return:
          type: System.String
          description: "\nThe return value is the standard or daylight time zone name string\nor abbreviation that represents the time specified by argument\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pdtmDateTime</code> as directed by argument\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pfAbbreviate</code>.\n"
      overload: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
- id: WizardWrx.Core
  commentId: N:WizardWrx.Core
  language: CSharp
  name:
    CSharp: WizardWrx.Core
    VB: WizardWrx.Core
  nameWithType:
    CSharp: WizardWrx.Core
    VB: WizardWrx.Core
  qualifiedName:
    CSharp: WizardWrx.Core
    VB: WizardWrx.Core
  type: Namespace
  assemblies:
  - WizardWrx.Core
  modifiers: {}
  items:
  - id: WizardWrx.Core.AgedFileInfo
    commentId: T:WizardWrx.Core.AgedFileInfo
    language: CSharp
    name:
      CSharp: AgedFileInfo
      VB: AgedFileInfo
    nameWithType:
      CSharp: AgedFileInfo
      VB: AgedFileInfo
    qualifiedName:
      CSharp: WizardWrx.Core.AgedFileInfo
      VB: WizardWrx.Core.AgedFileInfo
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/AgedFileInfo.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: AgedFileInfo
      path: ../Core/AgedFileInfo.cs
      startLine: 83
    summary: "\nThis class extends a FileInfo object with a custom IComparable interface\nimplementation.\n"
    remarks: "\nThis class and AgedFileInfoCollection are designed to be used together \nto achieve the goal of processing a list of the files that match a file\nspecification from newest to oldest.\n\nThese objects are not intended for independent use, since they must go\ninto a collection that can be sorted to leverage the IComparable\ninterface implementation that permits them to be sorted in reverse order\nby LastWriteTimeUTC.\n\nEach AgedFileInfo is a FileInfo object, wrapped in a small class that\naugments it with a custom IComparable interface implementation that\nallows the list to be sorted by LastWriteTimeUTC. Using LastWriteTimeUTC\nguarantees that the files are always sorted correctly, even when the set\nincludes one or more files that were created during the transition hour\nthat occurs twice annually, on the days when the transitions to and from\nDaylight Saving Time occur. LastWriteTimeUTC time stamps created during\nthis hour are not guaranteed to sort correctly, especially during the\n&quot;fall back&quot; transition that occurs in Autumn, when the local time is set\nback by 1 hour, so that there are two hours during which the same local\nhour is reported.\n\nIn the course of investigating an unexpected exception, I again read the\nrecommendation from Microsoft (published in the MSDN library) about\noverriding other methods (Equals and GetHashCode), implementing other\ninterfaces (IEquatable and IEqualityComparer), and overloading the\nequality and inequality operators, all of which I went ahead and did,\neven though doing so is almost certainly overkill for this class.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class AgedFileInfo : IComparable<AgedFileInfo>'
        VB: >-
          Public Class AgedFileInfo

              Implements IComparable(Of AgedFileInfo)
    see:
    - linkId: WizardWrx.Core.AgedFileInfoCollection
      commentId: T:WizardWrx.Core.AgedFileInfoCollection
    inheritance:
    - System.Object
    implements:
    - System.IComparable{WizardWrx.Core.AgedFileInfo}
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.AgedFileInfo.#ctor
      commentId: M:WizardWrx.Core.AgedFileInfo.#ctor
      language: CSharp
      name:
        CSharp: AgedFileInfo()
        VB: AgedFileInfo()
      nameWithType:
        CSharp: AgedFileInfo.AgedFileInfo()
        VB: AgedFileInfo.AgedFileInfo()
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.AgedFileInfo()
        VB: WizardWrx.Core.AgedFileInfo.AgedFileInfo()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AgedFileInfo.cs
        startLine: 91
      summary: "\nThe default constructor would be private, except that I believe that\nit must be marked as Public to satisfy the IComparable and IList\ninterfaces.\n"
      example: []
      syntax:
        content:
          CSharp: public AgedFileInfo()
          VB: Public Sub New
      overload: WizardWrx.Core.AgedFileInfo.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfo.#ctor(System.IO.FileInfo)
      commentId: M:WizardWrx.Core.AgedFileInfo.#ctor(System.IO.FileInfo)
      language: CSharp
      name:
        CSharp: AgedFileInfo(FileInfo)
        VB: AgedFileInfo(FileInfo)
      nameWithType:
        CSharp: AgedFileInfo.AgedFileInfo(FileInfo)
        VB: AgedFileInfo.AgedFileInfo(FileInfo)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.AgedFileInfo(System.IO.FileInfo)
        VB: WizardWrx.Core.AgedFileInfo.AgedFileInfo(System.IO.FileInfo)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AgedFileInfo.cs
        startLine: 103
      summary: "\nThe single overloaded constructor stashes a reference to a FileInfo,\nwhich this class augments with a custom implementation of the\nIComparable interface that supports inverse ordering.\n"
      example: []
      syntax:
        content:
          CSharp: public AgedFileInfo(FileInfo pfileInfo)
          VB: Public Sub New(pfileInfo As FileInfo)
        parameters:
        - id: pfileInfo
          type: System.IO.FileInfo
          description: "\nPass in a reference to the FileInfo to be stored in the instance.\n"
      overload: WizardWrx.Core.AgedFileInfo.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfo.Details
      commentId: P:WizardWrx.Core.AgedFileInfo.Details
      language: CSharp
      name:
        CSharp: Details
        VB: Details
      nameWithType:
        CSharp: AgedFileInfo.Details
        VB: AgedFileInfo.Details
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.Details
        VB: WizardWrx.Core.AgedFileInfo.Details
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Details
        path: ../Core/AgedFileInfo.cs
        startLine: 117
      summary: "\nReturn a reference to the FileInfo that was loaded into the\nconstructor.\n"
      remarks: "\nWhile this protects the reference against destruction, it doesn&apos;t\nprevent callers from changing read/write properties. For that, each\nproperty must be individually exposed as a read-only property.\n"
      example: []
      syntax:
        content:
          CSharp: public FileInfo Details { get; }
          VB: Public ReadOnly Property Details As FileInfo
        parameters: []
        return:
          type: System.IO.FileInfo
      overload: WizardWrx.Core.AgedFileInfo.Details*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.AgedFileInfo.ToString
      commentId: M:WizardWrx.Core.AgedFileInfo.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: AgedFileInfo.ToString()
        VB: AgedFileInfo.ToString()
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.ToString()
        VB: WizardWrx.Core.AgedFileInfo.ToString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ToString
        path: ../Core/AgedFileInfo.cs
        startLine: 142
      summary: "\nOverride the base class ToString method, so that it renders the most\ncritical properties of the underlying file.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe returned string lists the name of the exporting class, as usual,\nbut followed immediately by the key properties that a debugger will\nmost likely need.\n"
      overload: WizardWrx.Core.AgedFileInfo.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: WizardWrx.Core.AgedFileInfo.Equals(System.Object)
      commentId: M:WizardWrx.Core.AgedFileInfo.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: AgedFileInfo.Equals(Object)
        VB: AgedFileInfo.Equals(Object)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.Equals(System.Object)
        VB: WizardWrx.Core.AgedFileInfo.Equals(System.Object)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Equals
        path: ../Core/AgedFileInfo.cs
        startLine: 175
      summary: "\nOverride the base imp0lementation of the Equals method to return a\nresult that is consistent with the algorithm implemented by the\nIComparable interface.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: "\nThe object against which to compare must be another AgedFileInfo, or\nthe return value is False.\n"
        return:
          type: System.Boolean
          description: "\nThe returned Boolean value is that returned by comparing the two\n_fileInfo.LastAccessTimeUtc.Ticks property values.\n"
      overload: WizardWrx.Core.AgedFileInfo.Equals*
      overridden: System.Object.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: WizardWrx.Core.AgedFileInfo.GetHashCode
      commentId: M:WizardWrx.Core.AgedFileInfo.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: AgedFileInfo.GetHashCode()
        VB: AgedFileInfo.GetHashCode()
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.GetHashCode()
        VB: WizardWrx.Core.AgedFileInfo.GetHashCode()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetHashCode
        path: ../Core/AgedFileInfo.cs
        startLine: 198
      summary: "\nOverride the base GetHashCode method to return a result that is\nconsistent with the algorithm implemented by the IComparable\ninterface.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nThe return value is the HashCode of the LastWriteTimeUTC.Ticks\nproperty of the underlying FileInfo object.\n"
      overload: WizardWrx.Core.AgedFileInfo.GetHashCode*
      overridden: System.Object.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - isEii: true
      id: WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo(WizardWrx.Core.AgedFileInfo)
      commentId: M:WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo(WizardWrx.Core.AgedFileInfo)
      language: CSharp
      name:
        CSharp: IComparable<AgedFileInfo>.CompareTo(AgedFileInfo)
        VB: System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo(AgedFileInfo)
      nameWithType:
        CSharp: AgedFileInfo.IComparable<AgedFileInfo>.CompareTo(AgedFileInfo)
        VB: AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo(AgedFileInfo)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo(WizardWrx.Core.AgedFileInfo)
        VB: WizardWrx.Core.AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo(WizardWrx.Core.AgedFileInfo)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfo.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
        path: ../Core/AgedFileInfo.cs
        startLine: 206
      syntax:
        content:
          CSharp: int IComparable<AgedFileInfo>.CompareTo(AgedFileInfo other)
          VB: Function System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo(other As AgedFileInfo) As Integer Implements IComparable(Of AgedFileInfo).CompareTo
        parameters:
        - id: other
          type: WizardWrx.Core.AgedFileInfo
        return:
          type: System.Int32
      overload: WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo*
      implements:
      - System.IComparable{WizardWrx.Core.AgedFileInfo}.CompareTo(WizardWrx.Core.AgedFileInfo)
      modifiers:
        CSharp: []
        VB: []
    references:
      WizardWrx.Core.AgedFileInfoCollection: 
  - id: WizardWrx.Core.AgedFileInfoCollection
    commentId: T:WizardWrx.Core.AgedFileInfoCollection
    language: CSharp
    name:
      CSharp: AgedFileInfoCollection
      VB: AgedFileInfoCollection
    nameWithType:
      CSharp: AgedFileInfoCollection
      VB: AgedFileInfoCollection
    qualifiedName:
      CSharp: WizardWrx.Core.AgedFileInfoCollection
      VB: WizardWrx.Core.AgedFileInfoCollection
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/AgedFileInfoCollection.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: AgedFileInfoCollection
      path: ../Core/AgedFileInfoCollection.cs
      startLine: 67
    summary: "\nThis class hides its data in a List of AgedFileInfo objects, which its\nconstructors assemble from permutations of the array of FileInfo objects\nreturned by the GetFiles method on the DirectoryInfo instance that is\nfed into it.\n"
    remarks: "\nThis class and AgedFileInfo are designed to be used together to\nachieve the goal of processing a list of the files that match a file\nspecification from newest to oldest.\n\nEach AgedFileInfo is a FileInfo object, wrapped in a small class that\naugments it with a custom IComparable interface implementation that\nallows the list to be sorted by LastWriteTimeUTC. Using LastWriteTimeUTC\nguarantees that the files are always sorted correctly, even when the set\nincludes one or more files that were created during the transition hour\nthat occurs twice annually, on the days when the transitions to and from\nDaylight Saving Time occur. LastWriteTimeUTC time stamps created during\nthis hour are not guaranteed to sort correctly, especially during the\n&quot;fall back&quot; transition that occurs in Autumn, when the local time is set\nback by 1 hour, so that there are two hours during which the same local\nhour is reported.\n"
    example: []
    syntax:
      content:
        CSharp: public class AgedFileInfoCollection
        VB: Public Class AgedFileInfoCollection
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo)
      commentId: M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo)
      language: CSharp
      name:
        CSharp: AgedFileInfoCollection(DirectoryInfo)
        VB: AgedFileInfoCollection(DirectoryInfo)
      nameWithType:
        CSharp: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo)
        VB: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo)
        VB: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 95
      summary: "\nThe simplest of the three public constructors takes a reference to a\nDirectoryInfo collection, which is loaded in its entirety.\n"
      example: []
      syntax:
        content:
          CSharp: public AgedFileInfoCollection(DirectoryInfo pdirInfoCollection)
          VB: Public Sub New(pdirInfoCollection As DirectoryInfo)
        parameters:
        - id: pdirInfoCollection
          type: System.IO.DirectoryInfo
          description: "\nThe DirectoryInfo collection from which to populate the instance\n"
      overload: WizardWrx.Core.AgedFileInfoCollection.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String)
      commentId: M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String)
      language: CSharp
      name:
        CSharp: AgedFileInfoCollection(DirectoryInfo, String)
        VB: AgedFileInfoCollection(DirectoryInfo, String)
      nameWithType:
        CSharp: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo, String)
        VB: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo, String)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo, System.String)
        VB: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 113
      summary: "\nA slightly more advanced constructor restricts the files to those\nthat match a standard file name mask.\n"
      example: []
      syntax:
        content:
          CSharp: public AgedFileInfoCollection(DirectoryInfo pdirInfoCollection, string pstrFileSpec)
          VB: Public Sub New(pdirInfoCollection As DirectoryInfo, pstrFileSpec As String)
        parameters:
        - id: pdirInfoCollection
          type: System.IO.DirectoryInfo
          description: "\nThe DirectoryInfo collection from which to populate the instance\n"
        - id: pstrFileSpec
          type: System.String
          description: "\nThe string to employ as a search mask\n"
      overload: WizardWrx.Core.AgedFileInfoCollection.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String,System.IO.SearchOption)
      commentId: M:WizardWrx.Core.AgedFileInfoCollection.#ctor(System.IO.DirectoryInfo,System.String,System.IO.SearchOption)
      language: CSharp
      name:
        CSharp: AgedFileInfoCollection(DirectoryInfo, String, SearchOption)
        VB: AgedFileInfoCollection(DirectoryInfo, String, SearchOption)
      nameWithType:
        CSharp: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo, String, SearchOption)
        VB: AgedFileInfoCollection.AgedFileInfoCollection(DirectoryInfo, String, SearchOption)
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo, System.String, System.IO.SearchOption)
        VB: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection(System.IO.DirectoryInfo, System.String, System.IO.SearchOption)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 133
      summary: "\nThe most advanced constructor includes the restriction to a file name mask, to which it adds a SearchOption enumeration member that specifies whether to apply the mask to subdirectories.\n"
      example: []
      syntax:
        content:
          CSharp: public AgedFileInfoCollection(DirectoryInfo pdirInfoCollection, string pstrFileSpec, SearchOption penmSearchOption)
          VB: Public Sub New(pdirInfoCollection As DirectoryInfo, pstrFileSpec As String, penmSearchOption As SearchOption)
        parameters:
        - id: pdirInfoCollection
          type: System.IO.DirectoryInfo
          description: "\nThe DirectoryInfo collection from which to populate the instance\n"
        - id: pstrFileSpec
          type: System.String
          description: "\nThe string to employ as a search mask\n"
        - id: penmSearchOption
          type: System.IO.SearchOption
          description: "\nThe SearchOption that determines whether subdirectories are searched or ignored\n"
      overload: WizardWrx.Core.AgedFileInfoCollection.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfoCollection.Count
      commentId: P:WizardWrx.Core.AgedFileInfoCollection.Count
      language: CSharp
      name:
        CSharp: Count
        VB: Count
      nameWithType:
        CSharp: AgedFileInfoCollection.Count
        VB: AgedFileInfoCollection.Count
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.Count
        VB: WizardWrx.Core.AgedFileInfoCollection.Count
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Count
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 147
      summary: "\nRead the count off the private list.\n"
      example: []
      syntax:
        content:
          CSharp: public int Count { get; }
          VB: Public ReadOnly Property Count As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.AgedFileInfoCollection.Count*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo
      commentId: M:WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo
      language: CSharp
      name:
        CSharp: GetFirstFileInfo()
        VB: GetFirstFileInfo()
      nameWithType:
        CSharp: AgedFileInfoCollection.GetFirstFileInfo()
        VB: AgedFileInfoCollection.GetFirstFileInfo()
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo()
        VB: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetFirstFileInfo
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 167
      summary: "\nUnless the list is empty, return the newest file in it, which is the\nfirst file in the list, since it is reverse sorted by LastWriteTime.\n"
      example: []
      syntax:
        content:
          CSharp: public FileInfo GetFirstFileInfo()
          VB: Public Function GetFirstFileInfo As FileInfo
        return:
          type: System.IO.FileInfo
          description: "\nThe returned FileInfo object represents the newest file in the list,\nwhich occupies its first slot, since the list is sorted in reverse\norder by LastWriteTimeUTC.\n"
      overload: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo
      commentId: M:WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo
      language: CSharp
      name:
        CSharp: GetLastFileInfo()
        VB: GetLastFileInfo()
      nameWithType:
        CSharp: AgedFileInfoCollection.GetLastFileInfo()
        VB: AgedFileInfoCollection.GetLastFileInfo()
      qualifiedName:
        CSharp: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo()
        VB: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AgedFileInfoCollection.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetLastFileInfo
        path: ../Core/AgedFileInfoCollection.cs
        startLine: 189
      summary: "\nUnless the list is empty, return the oldest file in it, which is the\nlast file in the list, since it is reverse sorted by LastWriteTime.\n"
      example: []
      syntax:
        content:
          CSharp: public FileInfo GetLastFileInfo()
          VB: Public Function GetLastFileInfo As FileInfo
        return:
          type: System.IO.FileInfo
          description: "\nThe returned FileInfo object represents the oldest file in the list,\nwhich occupies its last slot, since the list is sorted in reverse\norder by LastWriteTimeUTC.\n"
      overload: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: WizardWrx.Core.AssemblyLocatorBase
    commentId: T:WizardWrx.Core.AssemblyLocatorBase
    language: CSharp
    name:
      CSharp: AssemblyLocatorBase
      VB: AssemblyLocatorBase
    nameWithType:
      CSharp: AssemblyLocatorBase
      VB: AssemblyLocatorBase
    qualifiedName:
      CSharp: WizardWrx.Core.AssemblyLocatorBase
      VB: WizardWrx.Core.AssemblyLocatorBase
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/AssemblyLocatorBase.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: AssemblyLocatorBase
      path: ../Core/AssemblyLocatorBase.cs
      startLine: 218
    summary: "\nUse a class derived from this class to get the fully qualified name of\nthe file from which the assembly in which the derived class is defined\nwas loaded. See Remarks.\n"
    remarks: "\nGiven the location from which an assembly was loaded, you can learn\nalmost anything else you need to know about that file, such as its size,\nage, version, and directory. Given the directory, you can locate\nsatellite files, such as configuration files that contain settings that\nit uses.\n"
    example: []
    syntax:
      content:
        CSharp: public abstract class AssemblyLocatorBase
        VB: Public MustInherit Class AssemblyLocatorBase
    seealso:
    - linkId: WizardWrx.Core.PropertyDefaults
      commentId: T:WizardWrx.Core.PropertyDefaults
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - abstract
      - class
      VB:
      - Public
      - MustInherit
      - Class
    items:
    - id: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
      commentId: F:WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
      language: CSharp
      name:
        CSharp: ASSEMBLYDATAPATH_TOKEN
        VB: ASSEMBLYDATAPATH_TOKEN
      nameWithType:
        CSharp: AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        VB: AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        VB: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ASSEMBLYDATAPATH_TOKEN
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 267
      summary: "\nUse this token in file names stored in DLL configuration files to\nexplicitly state that the file is expected to inhabit the directory\nfrom which the assembly is loaded, unless the assembly was loaded\nfrom the Global Assembly Cache (GAC). In that case, substitute the\napplication directory.\n"
      example: []
      syntax:
        content:
          CSharp: public const string ASSEMBLYDATAPATH_TOKEN = "$$AssemblyDataPath$$"
          VB: Public Const ASSEMBLYDATAPATH_TOKEN As String = "$$AssemblyDataPath$$"
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
      commentId: F:WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
      language: CSharp
      name:
        CSharp: _strAssemblyLocation
        VB: _strAssemblyLocation
      nameWithType:
        CSharp: AssemblyLocatorBase._strAssemblyLocation
        VB: AssemblyLocatorBase._strAssemblyLocation
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
        VB: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: _strAssemblyLocation
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 314
      summary: "\nOnce the energy required to gather the location has been expended,\nsave it for future use.\n"
      example: []
      syntax:
        content:
          CSharp: protected string _strAssemblyLocation
          VB: Protected _strAssemblyLocation As String
        return:
          type: System.String
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.Core.AssemblyLocatorBase.#ctor
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.#ctor
      language: CSharp
      name:
        CSharp: AssemblyLocatorBase()
        VB: AssemblyLocatorBase()
      nameWithType:
        CSharp: AssemblyLocatorBase.AssemblyLocatorBase()
        VB: AssemblyLocatorBase.AssemblyLocatorBase()
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase()
        VB: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 348
      summary: "\nInitialize the one and only property of this class, which holds the\nfully qualified path from which the containing assembly was loaded.\n\nUse this constructor to link the configuration file to the assembly\nthat defines this class.\n"
      remarks: "\nIMPORTANT: If the assembly loads from the Global Assembly Cache, its\nconfiguration file must be stored in the application directory. Be\naware that if an assembly exists in the Global Assembly Cache, it\nloads from there, even if there is a copy in the application\ndirectory.\n"
      example: []
      syntax:
        content:
          CSharp: public AssemblyLocatorBase()
          VB: Public Sub New
      overload: WizardWrx.Core.AssemblyLocatorBase.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AssemblyLocatorBase.#ctor(System.Reflection.Assembly)
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.#ctor(System.Reflection.Assembly)
      language: CSharp
      name:
        CSharp: AssemblyLocatorBase(Assembly)
        VB: AssemblyLocatorBase(Assembly)
      nameWithType:
        CSharp: AssemblyLocatorBase.AssemblyLocatorBase(Assembly)
        VB: AssemblyLocatorBase.AssemblyLocatorBase(Assembly)
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase(System.Reflection.Assembly)
        VB: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase(System.Reflection.Assembly)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 381
      summary: "\nInitialize the one and only property of this class, which holds the\nfully qualified path from which the containing assembly was loaded.\n\nUse this constructor to link the configuration file to the assembly\nthat defines this class.\n"
      remarks: "\nIMPORTANT: If the assembly loads from the Global Assembly Cache, its\nconfiguration file must be stored in the application directory. Be\naware that if an assembly exists in the Global Assembly Cache, it\nloads from there, even if there is a copy in the application\ndirectory.\n"
      example: []
      syntax:
        content:
          CSharp: public AssemblyLocatorBase(Assembly pasmLinkedAssembly)
          VB: Public Sub New(pasmLinkedAssembly As Assembly)
        parameters:
        - id: pasmLinkedAssembly
          type: System.Reflection.Assembly
          description: "\nPass in a reference to the assembly to which the configuration file\nis linked. For example, you can use the executing assembly of the\nobject at the top of the inheritance tree.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
      language: CSharp
      name:
        CSharp: AssemblyDataPath
        VB: AssemblyDataPath
      nameWithType:
        CSharp: AssemblyLocatorBase.AssemblyDataPath
        VB: AssemblyLocatorBase.AssemblyDataPath
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
        VB: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AssemblyDataPath
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 405
      summary: "\nGets a string containing the fully qualified path of the directory\nfrom which the assembly was loaded, unless it was loaded from the\nGlobal Assembly Cache (GAC). In that case, the return value is the\nfully qualified name of the directory from which the first assembly\nwas loaded into the current process. See Remarks.\n"
      remarks: "\nSo far as I know, assemblies must load from one of two locations.\nUnsigned assemblies MUST load from the application directory. If the\nassembly is signed with a strong name, it MAY  be loaded from either\nthe application directory or the Global Assembly Cache. If a signed\nassembly is in the local GAC, it loads from there, even if there is\na copy in the application directory.\n"
      example: []
      syntax:
        content:
          CSharp: public string AssemblyDataPath { get; }
          VB: Public ReadOnly Property AssemblyDataPath As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
      language: CSharp
      name:
        CSharp: AssemblyLocation
        VB: AssemblyLocation
      nameWithType:
        CSharp: AssemblyLocatorBase.AssemblyLocation
        VB: AssemblyLocatorBase.AssemblyLocation
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
        VB: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AssemblyLocation
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 412
      summary: "\nGets a string containing the fully qualified file name from which\nthe assembly in which the derived class is defined was loaded.\n"
      example: []
      syntax:
        content:
          CSharp: public string AssemblyLocation { get; }
          VB: Public ReadOnly Property AssemblyLocation As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
      language: CSharp
      name:
        CSharp: RecoveredConfigurationExceptions
        VB: RecoveredConfigurationExceptions
      nameWithType:
        CSharp: AssemblyLocatorBase.RecoveredConfigurationExceptions
        VB: AssemblyLocatorBase.RecoveredConfigurationExceptions
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
        VB: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RecoveredConfigurationExceptions
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 426
      summary: "\nThis read only property returns a generic List of Exceptions that\narose during the initialization phase of an instance, and were\nsilently recovered, so that they can be reported for investigation.\n"
      remarks: "\nThis property supersedes ConfigMessage, which returned the list of\nexceptions as one long string, discarding their all-important stack\ntraces.\n"
      example: []
      syntax:
        content:
          CSharp: public List<RecoveredException> RecoveredConfigurationExceptions { get; }
          VB: Public ReadOnly Property RecoveredConfigurationExceptions As List(Of RecoveredException)
        parameters: []
        return:
          type: System.Collections.Generic.List{WizardWrx.RecoveredException}
      overload: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
      language: CSharp
      name:
        CSharp: MissingConfigSettings
        VB: MissingConfigSettings
      nameWithType:
        CSharp: AssemblyLocatorBase.MissingConfigSettings
        VB: AssemblyLocatorBase.MissingConfigSettings
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
        VB: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MissingConfigSettings
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 434
      summary: "\nThis read-only property returns a generic List of string, each of\nwhich is a message that names a property that was omitted from the\nconfiguration file, along with its default value.\n"
      example: []
      syntax:
        content:
          CSharp: public UnconfiguredDLLSettings MissingConfigSettings { get; protected set; }
          VB: Public Property MissingConfigSettings As UnconfiguredDLLSettings
        parameters: []
        return:
          type: WizardWrx.Core.UnconfiguredDLLSettings
      overload: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings*
      modifiers:
        CSharp:
        - public
        - get
        - protected set
        VB:
        - Public
        - Get
        - Protected Set
    - id: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
      language: CSharp
      name:
        CSharp: DLLConfiguration
        VB: DLLConfiguration
      nameWithType:
        CSharp: AssemblyLocatorBase.DLLConfiguration
        VB: AssemblyLocatorBase.DLLConfiguration
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
        VB: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DLLConfiguration
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 441
      summary: "\nGets a reference to the entire Configuration object tied to the\nassembly in which the derived class is defined.\n"
      example: []
      syntax:
        content:
          CSharp: protected Configuration DLLConfiguration { get; }
          VB: Protected ReadOnly Property DLLConfiguration As Configuration
        parameters: []
        return:
          type: System.Configuration.Configuration
      overload: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration*
      modifiers:
        CSharp:
        - protected
        - get
        VB:
        - Protected
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
      language: CSharp
      name:
        CSharp: DLLSettingsSection
        VB: DLLSettingsSection
      nameWithType:
        CSharp: AssemblyLocatorBase.DLLSettingsSection
        VB: AssemblyLocatorBase.DLLSettingsSection
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
        VB: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DLLSettingsSection
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 489
      summary: "\nGets a reference to the entire AppSettingsSection object tied to\nthe assembly in which the derived class is defined.\n"
      remarks: "\nSince this property starts from the ConfigurationManager object\nreturned by its DLLConfiguration sibling, it requires only a single\nstatement, with a little help from an explicit cast.\n"
      example: []
      syntax:
        content:
          CSharp: protected AppSettingsSection DLLSettingsSection { get; }
          VB: Protected ReadOnly Property DLLSettingsSection As AppSettingsSection
        parameters: []
        return:
          type: System.Configuration.AppSettingsSection
      overload: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection*
      modifiers:
        CSharp:
        - protected
        - get
        VB:
        - Protected
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
      commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLSettings
      language: CSharp
      name:
        CSharp: DLLSettings
        VB: DLLSettings
      nameWithType:
        CSharp: AssemblyLocatorBase.DLLSettings
        VB: AssemblyLocatorBase.DLLSettings
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
        VB: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DLLSettings
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 540
      summary: "\nGets the DLL Settings section as a KeyValueConfigurationCollection.\n"
      example: []
      syntax:
        content:
          CSharp: protected KeyValueConfigurationCollection DLLSettings { get; }
          VB: Protected ReadOnly Property DLLSettings As KeyValueConfigurationCollection
        parameters: []
        return:
          type: System.Configuration.KeyValueConfigurationCollection
      overload: WizardWrx.Core.AssemblyLocatorBase.DLLSettings*
      modifiers:
        CSharp:
        - protected
        - get
        VB:
        - Protected
        - ReadOnly
    - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate(System.DateTimeKind)
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate(System.DateTimeKind)
      language: CSharp
      name:
        CSharp: GetAssemblyBuildDate(DateTimeKind)
        VB: GetAssemblyBuildDate(DateTimeKind)
      nameWithType:
        CSharp: AssemblyLocatorBase.GetAssemblyBuildDate(DateTimeKind)
        VB: AssemblyLocatorBase.GetAssemblyBuildDate(DateTimeKind)
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate(System.DateTimeKind)
        VB: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate(System.DateTimeKind)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetAssemblyBuildDate
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 614
      summary: "\nReturn the LastWriteTime of the file that contains the executing\nassembly. For all practical purposes, that is the date on which the\nassembly was built.\n"
      example: []
      syntax:
        content:
          CSharp: protected DateTime GetAssemblyBuildDate(DateTimeKind pdtmKind)
          VB: Protected Function GetAssemblyBuildDate(pdtmKind As DateTimeKind) As Date
        parameters:
        - id: pdtmKind
          type: System.DateTimeKind
          description: "\nThis DateTimeKind enumeration member specifies whether to report the\nLastWriteTime or the LastWriteTimeUtc.\n"
        return:
          type: System.DateTime
          description: "\nThe return value is a fully initialized DateTime structure, which\ncontains the requested LastWriteTime (Local or UTC) of the file that\ncontains the code of the executing assembly.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
      language: CSharp
      name:
        CSharp: GetAssemblyVersion()
        VB: GetAssemblyVersion()
      nameWithType:
        CSharp: AssemblyLocatorBase.GetAssemblyVersion()
        VB: AssemblyLocatorBase.GetAssemblyVersion()
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion()
        VB: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetAssemblyVersion
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 638
      summary: "\nReturn the Version structure, to expedite parsing its parts.\n"
      example: []
      syntax:
        content:
          CSharp: protected Version GetAssemblyVersion()
          VB: Protected Function GetAssemblyVersion As Version
        return:
          type: System.Version
          description: "\nThe return value is the version component of the fully qualified\nassembly name.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString
      language: CSharp
      name:
        CSharp: GetAssemblyVersionString()
        VB: GetAssemblyVersionString()
      nameWithType:
        CSharp: AssemblyLocatorBase.GetAssemblyVersionString()
        VB: AssemblyLocatorBase.GetAssemblyVersionString()
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString()
        VB: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetAssemblyVersionString
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 651
      summary: "\nReturn the complete version of the executing assembly.\n"
      example: []
      syntax:
        content:
          CSharp: protected string GetAssemblyVersionString()
          VB: Protected Function GetAssemblyVersionString As String
        return:
          type: System.String
          description: "\nThe return value is a string representation of all version number\n&quot;octets&quot; - Major, Minor, Build, and Revision.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    - id: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
      language: CSharp
      name:
        CSharp: GetDLLSetting(String)
        VB: GetDLLSetting(String)
      nameWithType:
        CSharp: AssemblyLocatorBase.GetDLLSetting(String)
        VB: AssemblyLocatorBase.GetDLLSetting(String)
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
        VB: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetDLLSetting
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 669
      summary: "\nReturn the specified setting value, as a string.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetDLLSetting(string pstrSettingsKey)
          VB: Public Function GetDLLSetting(pstrSettingsKey As String) As String
        parameters:
        - id: pstrSettingsKey
          type: System.String
          description: "\nThis string is the name (key) of the desired setting.\n"
        return:
          type: System.String
          description: "\nThe return value is a string representation of the value stored in\nthe named key.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
      commentId: M:WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
      language: CSharp
      name:
        CSharp: SetPropertiesFromDLLConfiguration(Type)
        VB: SetPropertiesFromDLLConfiguration(Type)
      nameWithType:
        CSharp: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(Type)
        VB: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(Type)
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
        VB: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SetPropertiesFromDLLConfiguration
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 697
      summary: "\nSet the like named properties from the linked configuration file.\n"
      remarks: "\nThis can almost certainly be simplified by enumerating the settings,\nbut either way risks a NOT FOUND exception.\n\nThis method uses some fairly tricky Reflection gymnastics to map the\nkey names in a configuration file to property names on an object.\n"
      example: []
      syntax:
        content:
          CSharp: protected AssemblyLocatorBase.PropertySourceCounts SetPropertiesFromDLLConfiguration(Type pderivedType)
          VB: Protected Function SetPropertiesFromDLLConfiguration(pderivedType As Type) As AssemblyLocatorBase.PropertySourceCounts
        parameters:
        - id: pderivedType
          type: System.Type
          description: "\nWhen the derived class constructor calls this method, it must pass in a\nreference to its own Type property.\n"
        return:
          type: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
          description: "\nThe return value is the count of properties that were set.\n"
      overload: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration*
      modifiers:
        CSharp:
        - protected
        VB:
        - Protected
    references:
      WizardWrx.Core.PropertyDefaults: 
  - id: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
    commentId: T:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
    language: CSharp
    name:
      CSharp: AssemblyLocatorBase.PropertySourceCounts
      VB: AssemblyLocatorBase.PropertySourceCounts
    nameWithType:
      CSharp: AssemblyLocatorBase.PropertySourceCounts
      VB: AssemblyLocatorBase.PropertySourceCounts
    qualifiedName:
      CSharp: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
      VB: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
    type: Struct
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/AssemblyLocatorBase.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: PropertySourceCounts
      path: ../Core/AssemblyLocatorBase.cs
      startLine: 277
    summary: "\nSetPropertiesFromDLLConfiguration fills and returns this structure,\nto account for all defined properties, whether or not their values\nare configured.\n"
    example: []
    syntax:
      content:
        CSharp: public struct PropertySourceCounts
        VB: Public Structure PropertySourceCounts
    inheritedMembers:
    - System.ValueType.Equals(System.Object)
    - System.ValueType.GetHashCode
    - System.ValueType.ToString
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
      commentId: F:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
      language: CSharp
      name:
        CSharp: SpecifiedInConfiguration
        VB: SpecifiedInConfiguration
      nameWithType:
        CSharp: AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
        VB: AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
        VB: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.SpecifiedInConfiguration
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SpecifiedInConfiguration
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 282
      summary: "\nCount of properties read from the configuration file.\n"
      example: []
      syntax:
        content:
          CSharp: public int SpecifiedInConfiguration
          VB: Public SpecifiedInConfiguration As Integer
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.Defaulted
      commentId: F:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.Defaulted
      language: CSharp
      name:
        CSharp: Defaulted
        VB: Defaulted
      nameWithType:
        CSharp: AssemblyLocatorBase.PropertySourceCounts.Defaulted
        VB: AssemblyLocatorBase.PropertySourceCounts.Defaulted
      qualifiedName:
        CSharp: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.Defaulted
        VB: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts.Defaulted
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/AssemblyLocatorBase.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Defaulted
        path: ../Core/AssemblyLocatorBase.cs
        startLine: 288
      summary: "\nCount of properties omitted from the configuration file, and\nleft at their default values.\n"
      example: []
      syntax:
        content:
          CSharp: public int Defaulted
          VB: Public Defaulted As Integer
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: WizardWrx.Core.BasicSystemInfoDisplayMessages
    commentId: T:WizardWrx.Core.BasicSystemInfoDisplayMessages
    language: CSharp
    name:
      CSharp: BasicSystemInfoDisplayMessages
      VB: BasicSystemInfoDisplayMessages
    nameWithType:
      CSharp: BasicSystemInfoDisplayMessages
      VB: BasicSystemInfoDisplayMessages
    qualifiedName:
      CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages
      VB: WizardWrx.Core.BasicSystemInfoDisplayMessages
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/BasicSystemInfoDisplayMessages.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: BasicSystemInfoDisplayMessages
      path: ../Core/BasicSystemInfoDisplayMessages.cs
      startLine: 85
    summary: "\nThe static methods exposed by this class simplify displaying information\nabout the processor on which the calling process is executing that is\notherwise hard to determine accurately.\n"
    example: []
    syntax:
      content:
        CSharp: public static class BasicSystemInfoDisplayMessages
        VB: Public Module BasicSystemInfoDisplayMessages
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
      language: CSharp
      name:
        CSharp: WWKV_GETOSVERSIONINFO_WIN2K
        VB: WWKV_GETOSVERSIONINFO_WIN2K
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
        VB: BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKV_GETOSVERSIONINFO_WIN2K
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKV_GETOSVERSIONINFO_WIN2K
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 97
      summary: "\nUse as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 2000 or newer.\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKV_GETOSVERSIONINFO_WIN2K = 5
          VB: Public Const WWKV_GETOSVERSIONINFO_WIN2K As Integer = 5
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_VISTA
        VB: WWKW_GETOSVERSIONINFO_VISTA
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_VISTA
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_VISTA
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 102
      summary: "\nUse as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows Vista or newer.\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_VISTA = 6
          VB: Public Const WWKW_GETOSVERSIONINFO_VISTA As Integer = 6
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_WIN8
        VB: WWKW_GETOSVERSIONINFO_WIN8
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN8
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_WIN8
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 107
      summary: "\nUse as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 8 or newer.\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_WIN8 = 8
          VB: Public Const WWKW_GETOSVERSIONINFO_WIN8 As Integer = 8
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_WIN10
        VB: WWKW_GETOSVERSIONINFO_WIN10
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_WIN10
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_WIN10
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 112
      summary: "\nUse as argument pintMajorMinimum to WWKW_OSIsMinimumVersionMaj or WWKW_OSIsMinimumVersionMin to test for Windows 10 or newer.\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_WIN10 = 10
          VB: Public Const WWKW_GETOSVERSIONINFO_WIN10 As Integer = 10
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_BASE
        VB: WWKW_GETOSVERSIONINFO_BASE
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_BASE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_BASE
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 117
      summary: "\nUse as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for even numbered (.0) versions of Windows (e. g., Win28, Vista, 8.0, 10.0).\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_BASE = 0
          VB: Public Const WWKW_GETOSVERSIONINFO_BASE As Integer = 0
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_MINOR_1
        VB: WWKW_GETOSVERSIONINFO_MINOR_1
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_1
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_MINOR_1
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 122
      summary: "\nUse as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for point versions of Windows (e. g., Windows XP (5.1), Windows 7 (which has an internal version number of 6.1), etc.\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_MINOR_1 = 1
          VB: Public Const WWKW_GETOSVERSIONINFO_MINOR_1 As Integer = 1
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
      commentId: F:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
      language: CSharp
      name:
        CSharp: WWKW_GETOSVERSIONINFO_MINOR_2
        VB: WWKW_GETOSVERSIONINFO_MINOR_2
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
        VB: BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_GETOSVERSIONINFO_MINOR_2
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_GETOSVERSIONINFO_MINOR_2
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 127
      summary: "\nUse as argument pintOSVersionMinorinimum to WWKW_OSIsMinimumVersionMin to test for point two versions of Windows (e. g., Windows Server 2003, 2008, 2012).\n"
      example: []
      syntax:
        content:
          CSharp: public const int WWKW_GETOSVERSIONINFO_MINOR_2 = 2
          VB: Public Const WWKW_GETOSVERSIONINFO_MINOR_2 As Integer = 2
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture
      language: CSharp
      name:
        CSharp: GetProcessorArchitecture()
        VB: GetProcessorArchitecture()
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.GetProcessorArchitecture()
        VB: BasicSystemInfoDisplayMessages.GetProcessorArchitecture()
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture()
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetProcessorArchitecture
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 173
      summary: "\nGet a ProcessorArchitecture enumeration member that specifies the\nprocessor architecture.\n"
      example: []
      syntax:
        content:
          CSharp: public static ProcessorArchitecture GetProcessorArchitecture()
          VB: Public Shared Function GetProcessorArchitecture As ProcessorArchitecture
        return:
          type: System.Reflection.ProcessorArchitecture
          description: "\nThe return value is a member of the ProcessorArchitecture\nenumeration that specifies the type of processor installed on the\nmachine.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
      language: CSharp
      name:
        CSharp: DisplayProcessorArchitecture()
        VB: DisplayProcessorArchitecture()
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture()
        VB: BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture()
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture()
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DisplayProcessorArchitecture
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 213
      summary: "\nGet a string that describes the processor architecture and the size,\nin bits, of the machine word of the subsystem in which the calling\nprocess is executing.\n"
      example: []
      syntax:
        content:
          CSharp: public static string DisplayProcessorArchitecture()
          VB: Public Shared Function DisplayProcessorArchitecture As String
        return:
          type: System.String
          description: "\nThe return value is a string of the following form.\n\nProcessor Architecture = ProcessorArchitecture\nProcess Machine Word   = NN bits\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
      language: CSharp
      name:
        CSharp: WWKW_OSIsVistaOrNewer()
        VB: WWKW_OSIsVistaOrNewer()
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer()
        VB: BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer()
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer()
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_OSIsVistaOrNewer
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 242
      summary: "\nEvaluate whether the operating system is at least Windows Vista.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool WWKW_OSIsVistaOrNewer()
          VB: Public Shared Function WWKW_OSIsVistaOrNewer As Boolean
        return:
          type: System.Boolean
          description: "\nReturn TRUE if the calling process is executing on Windows Vista or\nnewer. Otherwise, return FALSE.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
      language: CSharp
      name:
        CSharp: WWKW_OSIsWindowsXPOrNewer()
        VB: WWKW_OSIsWindowsXPOrNewer()
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer()
        VB: BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer()
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer()
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_OSIsWindowsXPOrNewer
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 254
      summary: "\nEvaluate whether the operating system is at least Windows XP.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool WWKW_OSIsWindowsXPOrNewer()
          VB: Public Shared Function WWKW_OSIsWindowsXPOrNewer As Boolean
        return:
          type: System.Boolean
          description: "\nReturn TRUE if the calling process is executing on Windows XP or\nnewer. Otherwise, return FALSE.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
      language: CSharp
      name:
        CSharp: WWKW_OSIsWindows7OrNewer()
        VB: WWKW_OSIsWindows7OrNewer()
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer()
        VB: BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer()
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer()
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_OSIsWindows7OrNewer
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 267
      summary: "\nEvaluate whether the operating system is at least Windows 7.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool WWKW_OSIsWindows7OrNewer()
          VB: Public Shared Function WWKW_OSIsWindows7OrNewer As Boolean
        return:
          type: System.Boolean
          description: "\nReturn TRUE if the calling process is executing on Windows 7 or\nnewer. Otherwise, return FALSE.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(System.Int32)
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(System.Int32)
      language: CSharp
      name:
        CSharp: WWKW_OSIsMinimumVersionMaj(Int32)
        VB: WWKW_OSIsMinimumVersionMaj(Int32)
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(Int32)
        VB: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(System.Int32)
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_OSIsMinimumVersionMaj
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 280
      summary: "\nEvaluate whether the operating system is at least equal to the\nspecified major version number.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool WWKW_OSIsMinimumVersionMaj(int pintMajorMinimum)
          VB: Public Shared Function WWKW_OSIsMinimumVersionMaj(pintMajorMinimum As Integer) As Boolean
        parameters:
        - id: pintMajorMinimum
          type: System.Int32
        return:
          type: System.Boolean
          description: "\nReturn TRUE if the calling process is executing on the specified\nmajor version number of Windows or newer. Otherwise, return FALSE.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(System.Int32,System.Int32)
      commentId: M:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: WWKW_OSIsMinimumVersionMin(Int32, Int32)
        VB: WWKW_OSIsMinimumVersionMin(Int32, Int32)
      nameWithType:
        CSharp: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(Int32, Int32)
        VB: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(System.Int32, System.Int32)
        VB: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/BasicSystemInfoDisplayMessages.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WWKW_OSIsMinimumVersionMin
        path: ../Core/BasicSystemInfoDisplayMessages.cs
        startLine: 294
      summary: "\nEvaluate whether the operating system is at least equal to the\nspecified major and minor version number.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool WWKW_OSIsMinimumVersionMin(int pintMajorMinimum, int pintOSVersionMinorinimum)
          VB: Public Shared Function WWKW_OSIsMinimumVersionMin(pintMajorMinimum As Integer, pintOSVersionMinorinimum As Integer) As Boolean
        parameters:
        - id: pintMajorMinimum
          type: System.Int32
        - id: pintOSVersionMinorinimum
          type: System.Int32
        return:
          type: System.Boolean
          description: "\nReturn TRUE if the calling process is executing on the specified\nmajor and minor version number of Windows or newer. Otherwise,\nreturn FALSE.\n"
      overload: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Core.ByteArrayBase64Converters
    commentId: T:WizardWrx.Core.ByteArrayBase64Converters
    language: CSharp
    name:
      CSharp: ByteArrayBase64Converters
      VB: ByteArrayBase64Converters
    nameWithType:
      CSharp: ByteArrayBase64Converters
      VB: ByteArrayBase64Converters
    qualifiedName:
      CSharp: WizardWrx.Core.ByteArrayBase64Converters
      VB: WizardWrx.Core.ByteArrayBase64Converters
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/ByteArrayBase64Converters.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ByteArrayBase64Converters
      path: ../Core/ByteArrayBase64Converters.cs
      startLine: 80
    summary: "\nThis static class exposes methods that efficiently encode binary data as\nBase64 byte arrays and converts such byte arrays into binary data in the\nform of a new byte array or binary data written into a disk file.\n"
    example: []
    syntax:
      content:
        CSharp: public static class ByteArrayBase64Converters
        VB: Public Module ByteArrayBase64Converters
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile(System.String)
      commentId: M:WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile(System.String)
      language: CSharp
      name:
        CSharp: Base64EncodeBinaryFile(String)
        VB: Base64EncodeBinaryFile(String)
      nameWithType:
        CSharp: ByteArrayBase64Converters.Base64EncodeBinaryFile(String)
        VB: ByteArrayBase64Converters.Base64EncodeBinaryFile(String)
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile(System.String)
        VB: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayBase64Converters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Base64EncodeBinaryFile
        path: ../Core/ByteArrayBase64Converters.cs
        startLine: 96
      summary: "\nRead an input file into a byte array of Base64 encoded characters\nthat represents its contents in a form that can be included in a\nMIME encoded email message.\n"
      example: []
      syntax:
        content:
          CSharp: public static byte[] Base64EncodeBinaryFile(string pstrInputFileName)
          VB: Public Shared Function Base64EncodeBinaryFile(pstrInputFileName As String) As Byte()
        parameters:
        - id: pstrInputFileName
          type: System.String
          description: "\nPass in the absolute or relative (to the Current Working Directory)\nname of the file to read and encode into a byte array that represents\nthe Base64 encoded characters.\n"
        return:
          type: System.Byte[]
          description: "\nThe return value is a byte array that contains 4 characters for each\nthree bytes read from the input file.\n"
      overload: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File(System.String,System.Byte[])
      commentId: M:WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File(System.String,System.Byte[])
      language: CSharp
      name:
        CSharp: Base64DecodeByteArray2File(String, Byte[])
        VB: Base64DecodeByteArray2File(String, Byte())
      nameWithType:
        CSharp: ByteArrayBase64Converters.Base64DecodeByteArray2File(String, Byte[])
        VB: ByteArrayBase64Converters.Base64DecodeByteArray2File(String, Byte())
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File(System.String, System.Byte[])
        VB: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File(System.String, System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayBase64Converters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Base64DecodeByteArray2File
        path: ../Core/ByteArrayBase64Converters.cs
        startLine: 120
      summary: "\nDecode byte array <code data-dev-comment-type=\"paramref\" class=\"paramref\">pabytBase64Characters</code> and write\nthe decoded bytes into file <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrFileName</code>.\n"
      example: []
      syntax:
        content:
          CSharp: public static void Base64DecodeByteArray2File(string pstrFileName, byte[] pabytBase64Characters)
          VB: Public Shared Sub Base64DecodeByteArray2File(pstrFileName As String, pabytBase64Characters As Byte())
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nSpecify the name (absolute or relative to the current working\ndirectory) of the file into which to write the decoded bytes\nrepresented by <code data-dev-comment-type=\"paramref\" class=\"paramref\">pabytBase64Characters</code>.\n"
        - id: pabytBase64Characters
          type: System.Byte[]
          description: "\nPass in a reference to the array of Base64 encoded bytes to be\ndecoded and saved into file <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrFileName</code>.\n"
      overload: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray(System.Byte[])
      commentId: M:WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray(System.Byte[])
      language: CSharp
      name:
        CSharp: Base64DecodeByteArray(Byte[])
        VB: Base64DecodeByteArray(Byte())
      nameWithType:
        CSharp: ByteArrayBase64Converters.Base64DecodeByteArray(Byte[])
        VB: ByteArrayBase64Converters.Base64DecodeByteArray(Byte())
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray(System.Byte[])
        VB: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray(System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayBase64Converters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Base64DecodeByteArray
        path: ../Core/ByteArrayBase64Converters.cs
        startLine: 144
      summary: "\nDecode a byte array that represents a set of Base64 encoded\ncharacters, returning a new byte array containing their decoded\nrepresentation.\n"
      example: []
      syntax:
        content:
          CSharp: public static byte[] Base64DecodeByteArray(byte[] pabytBase64Characters)
          VB: Public Shared Function Base64DecodeByteArray(pabytBase64Characters As Byte()) As Byte()
        parameters:
        - id: pabytBase64Characters
          type: System.Byte[]
          description: "\nPass in a reference to the array of Base64 encoded bytes to be\ndecoded and returned.\n"
        return:
          type: System.Byte[]
          description: "\nThe return value is the byte array containing the Base64 decoded\nbytes. Expect an array containing 3/4 as many elements as the input.\n"
      overload: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Core.ByteArrayFormatters
    commentId: T:WizardWrx.Core.ByteArrayFormatters
    language: CSharp
    name:
      CSharp: ByteArrayFormatters
      VB: ByteArrayFormatters
    nameWithType:
      CSharp: ByteArrayFormatters
      VB: ByteArrayFormatters
    qualifiedName:
      CSharp: WizardWrx.Core.ByteArrayFormatters
      VB: WizardWrx.Core.ByteArrayFormatters
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/ByteArrayFormatters.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ByteArrayFormatters
      path: ../Core/ByteArrayFormatters.cs
      startLine: 93
    summary: "\nThe static methods in this class format byte arrays into strings of\nhexadecimal numerals for display on reports and in windows.\n"
    example: []
    syntax:
      content:
        CSharp: public static class ByteArrayFormatters
        VB: Public Module ByteArrayFormatters
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
      commentId: F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
      language: CSharp
      name:
        CSharp: BYTES_TO_STRING_BLOCK_OF_4
        VB: BYTES_TO_STRING_BLOCK_OF_4
      nameWithType:
        CSharp: ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
        VB: ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
        VB: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_4
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BYTES_TO_STRING_BLOCK_OF_4
        path: ../Core/ByteArrayFormatters.cs
        startLine: 100
      summary: "\nUse this to set ByteArrayToHexDigitString argument puintGroupSize to\ninsert a space between every 4th byte.\n"
      example: []
      syntax:
        content:
          CSharp: public const uint BYTES_TO_STRING_BLOCK_OF_4 = 4U
          VB: Public Const BYTES_TO_STRING_BLOCK_OF_4 As UInteger = 4UI
        return:
          type: System.UInt32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
      commentId: F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
      language: CSharp
      name:
        CSharp: BYTES_TO_STRING_BLOCK_OF_8
        VB: BYTES_TO_STRING_BLOCK_OF_8
      nameWithType:
        CSharp: ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
        VB: ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
        VB: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_BLOCK_OF_8
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BYTES_TO_STRING_BLOCK_OF_8
        path: ../Core/ByteArrayFormatters.cs
        startLine: 106
      summary: "\nUse this to set ByteArrayToHexDigitString argument puintGroupSize to\ninsert a space between every 8th byte.\n"
      example: []
      syntax:
        content:
          CSharp: public const uint BYTES_TO_STRING_BLOCK_OF_8 = 8U
          VB: Public Const BYTES_TO_STRING_BLOCK_OF_8 As UInteger = 8UI
        return:
          type: System.UInt32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
      commentId: F:WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
      language: CSharp
      name:
        CSharp: BYTES_TO_STRING_NO_SPACING
        VB: BYTES_TO_STRING_NO_SPACING
      nameWithType:
        CSharp: ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
        VB: ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
        VB: WizardWrx.Core.ByteArrayFormatters.BYTES_TO_STRING_NO_SPACING
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BYTES_TO_STRING_NO_SPACING
        path: ../Core/ByteArrayFormatters.cs
        startLine: 117
      summary: "\nUse this to set ByteArrayToHexDigitString argument puintGroupSize to\nformat the string without any spaces.\n"
      remarks: "\nThis constant is intended primarily for internal use by the first\noverload, which omits the second argument, to call the second\noverload, which does the work.\n"
      example: []
      syntax:
        content:
          CSharp: public const uint BYTES_TO_STRING_NO_SPACING = 0U
          VB: Public Const BYTES_TO_STRING_NO_SPACING As UInteger = 0UI
        return:
          type: System.UInt32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[])
      commentId: M:WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[])
      language: CSharp
      name:
        CSharp: ByteArrayToHexDigitString(Byte[])
        VB: ByteArrayToHexDigitString(Byte())
      nameWithType:
        CSharp: ByteArrayFormatters.ByteArrayToHexDigitString(Byte[])
        VB: ByteArrayFormatters.ByteArrayToHexDigitString(Byte())
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[])
        VB: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ByteArrayToHexDigitString
        path: ../Core/ByteArrayFormatters.cs
        startLine: 131
      summary: "\nConvert a byte array into a printable hexadecimal representation.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ByteArrayToHexDigitString(byte[] pbytInputData)
          VB: Public Shared Function ByteArrayToHexDigitString(pbytInputData As Byte()) As String
        parameters:
        - id: pbytInputData
          type: System.Byte[]
          description: "\nSpecify the byte array to be formatted. Any byte array will do.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that contains two characters for each\nbyte in the array.\n"
      overload: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[],System.UInt32)
      commentId: M:WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[],System.UInt32)
      language: CSharp
      name:
        CSharp: ByteArrayToHexDigitString(Byte[], UInt32)
        VB: ByteArrayToHexDigitString(Byte(), UInt32)
      nameWithType:
        CSharp: ByteArrayFormatters.ByteArrayToHexDigitString(Byte[], UInt32)
        VB: ByteArrayFormatters.ByteArrayToHexDigitString(Byte(), UInt32)
      qualifiedName:
        CSharp: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte[], System.UInt32)
        VB: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString(System.Byte(), System.UInt32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/ByteArrayFormatters.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ByteArrayToHexDigitString
        path: ../Core/ByteArrayFormatters.cs
        startLine: 152
      summary: "\nConvert a byte array into a printable hexadecimal representation.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ByteArrayToHexDigitString(byte[] pbytInputData, uint puintGroupSize)
          VB: Public Shared Function ByteArrayToHexDigitString(pbytInputData As Byte(), puintGroupSize As UInteger) As String
        parameters:
        - id: pbytInputData
          type: System.Byte[]
          description: "\nSpecify the byte array to be formatted. Any byte array will do.\n"
        - id: puintGroupSize
          type: System.UInt32
          description: "\nSpecify the number of bytes to display as a group.\n"
        return:
          type: System.String
          description: "\nThe return value is a string that contains two characters for each\nbyte in the array, plus one space between every puintGroupSizeth\nbyte.\n"
      overload: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Core.CmdLneArgsBasic
    commentId: T:WizardWrx.Core.CmdLneArgsBasic
    language: CSharp
    name:
      CSharp: CmdLneArgsBasic
      VB: CmdLneArgsBasic
    nameWithType:
      CSharp: CmdLneArgsBasic
      VB: CmdLneArgsBasic
    qualifiedName:
      CSharp: WizardWrx.Core.CmdLneArgsBasic
      VB: WizardWrx.Core.CmdLneArgsBasic
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/CmdLneArgsBasic.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: CmdLneArgsBasic
      path: ../Core/CmdLneArgsBasic.cs
      startLine: 225
    summary: "\nAn instance of this class efficiently processes command line switches,\nnamed arguments, and positional arguments, in such a way that they are\neasily accessible. The command line is completely parsed in a single\npass.\n\nSwitches, named arguments, and positional arguments may be freely mixed\nin any way; your users aren&apos;t confined to specifying all switches and/or\nnamed arguments first, last, or in any other order.\n\nSince command line parsing happens in the constructor, your code must\ndefine all the rules in its parameters. To that end, there are 26\nconstructors, which provide access to all of the rich capabilities of\nthis object. In spite of the multitude of constructors, their\norganization, coupled with consistent naming and documentation of their\narguments, is intended to make their features readily accessible.\n\nWhile it is fairly trivial to reverse engineer the underlying Dictionary\nobject, and read the arguments directly, the supported method of reading\nthem is through its methods: GetArgByName, GetArgByPosition, and\nGetSwitchByName.\n"
    example: []
    syntax:
      content:
        CSharp: public class CmdLneArgsBasic
        VB: Public Class CmdLneArgsBasic
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_HAS_ARGS
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_HAS_ARGS
      language: CSharp
      name:
        CSharp: ARG_LIST_HAS_ARGS
        VB: ARG_LIST_HAS_ARGS
      nameWithType:
        CSharp: CmdLneArgsBasic.ARG_LIST_HAS_ARGS
        VB: CmdLneArgsBasic.ARG_LIST_HAS_ARGS
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_HAS_ARGS
        VB: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_HAS_ARGS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ARG_LIST_HAS_ARGS
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 305
      summary: "\nWhen the ArgListIsEmpty property has this value, the command line\ncontains at least one argument. See Remarks.\n"
      remarks: "\nArgListIsEmpty being false means only that there is an argument in\nthe command line, which may be invalid. Check the ArgMatching array\nor the two invalid argument counters, InvalidNamedArgsInCmd and\nInvalidSwitchesInCmd.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool ARG_LIST_HAS_ARGS = false
          VB: Public Const ARG_LIST_HAS_ARGS As Boolean = False
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_IS_EMPTY
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_IS_EMPTY
      language: CSharp
      name:
        CSharp: ARG_LIST_IS_EMPTY
        VB: ARG_LIST_IS_EMPTY
      nameWithType:
        CSharp: CmdLneArgsBasic.ARG_LIST_IS_EMPTY
        VB: CmdLneArgsBasic.ARG_LIST_IS_EMPTY
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_IS_EMPTY
        VB: WizardWrx.Core.CmdLneArgsBasic.ARG_LIST_IS_EMPTY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ARG_LIST_IS_EMPTY
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 312
      summary: "\nWhen the ArgListIsEmpty property has this value, the command line is\nempty, consisting solely of the name of the executing assembly.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool ARG_LIST_IS_EMPTY = true
          VB: Public Const ARG_LIST_IS_EMPTY As Boolean = True
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
      language: CSharp
      name:
        CSharp: BLANK_AS_DEFAULT_ALLOWED
        VB: BLANK_AS_DEFAULT_ALLOWED
      nameWithType:
        CSharp: CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
        VB: CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
        VB: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_ALLOWED
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BLANK_AS_DEFAULT_ALLOWED
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 321
      summary: "\nWhen the AllowEmptyStringAsDefault property has this value, an empty\nstring is permitted as a default value. See the Remarks section of \nthe on-line documentation of the AllowEmptyStringAsDefault property\nfor complete details.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool BLANK_AS_DEFAULT_ALLOWED = true
          VB: Public Const BLANK_AS_DEFAULT_ALLOWED As Boolean = True
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
      language: CSharp
      name:
        CSharp: BLANK_AS_DEFAULT_FORBIDDEN
        VB: BLANK_AS_DEFAULT_FORBIDDEN
      nameWithType:
        CSharp: CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
        VB: CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
        VB: WizardWrx.Core.CmdLneArgsBasic.BLANK_AS_DEFAULT_FORBIDDEN
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: BLANK_AS_DEFAULT_FORBIDDEN
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 330
      summary: "\nWhen the AllowEmptyStringAsDefault property has this value, an empty\nstring as a default value is forbidden. See the Remarks section of \nthe on-line documentation of the AllowEmptyStringAsDefault property\nfor complete details.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool BLANK_AS_DEFAULT_FORBIDDEN = false
          VB: Public Const BLANK_AS_DEFAULT_FORBIDDEN As Boolean = False
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.FIRST_POSITIONAL_ARG
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.FIRST_POSITIONAL_ARG
      language: CSharp
      name:
        CSharp: FIRST_POSITIONAL_ARG
        VB: FIRST_POSITIONAL_ARG
      nameWithType:
        CSharp: CmdLneArgsBasic.FIRST_POSITIONAL_ARG
        VB: CmdLneArgsBasic.FIRST_POSITIONAL_ARG
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.FIRST_POSITIONAL_ARG
        VB: WizardWrx.Core.CmdLneArgsBasic.FIRST_POSITIONAL_ARG
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FIRST_POSITIONAL_ARG
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 338
      summary: "\nUse this constant with the GetArgByPosition method to get the first\npositional argument, or as the initializer of a For loop to get all\npositional arguments.\n"
      example: []
      syntax:
        content:
          CSharp: public const int FIRST_POSITIONAL_ARG = 1
          VB: Public Const FIRST_POSITIONAL_ARG As Integer = 1
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.NAME_VALUE_DELIMITER
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.NAME_VALUE_DELIMITER
      language: CSharp
      name:
        CSharp: NAME_VALUE_DELIMITER
        VB: NAME_VALUE_DELIMITER
      nameWithType:
        CSharp: CmdLneArgsBasic.NAME_VALUE_DELIMITER
        VB: CmdLneArgsBasic.NAME_VALUE_DELIMITER
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.NAME_VALUE_DELIMITER
        VB: WizardWrx.Core.CmdLneArgsBasic.NAME_VALUE_DELIMITER
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: NAME_VALUE_DELIMITER
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 345
      summary: "\nThis class uses the equal sign as its delimiter between the name and\nvalue of named arguments.\n"
      example: []
      syntax:
        content:
          CSharp: public const char NAME_VALUE_DELIMITER = '='
          VB: Public Const NAME_VALUE_DELIMITER As Char = "="c
        return:
          type: System.Char
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.NONE
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.NONE
      language: CSharp
      name:
        CSharp: NONE
        VB: NONE
      nameWithType:
        CSharp: CmdLneArgsBasic.NONE
        VB: CmdLneArgsBasic.NONE
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.NONE
        VB: WizardWrx.Core.CmdLneArgsBasic.NONE
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: NONE
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 352
      summary: "\nCounts are initialized to this value (zero). Making it public\nsimplifies coding well-documented tests.\n"
      example: []
      syntax:
        content:
          CSharp: public const int NONE = 0
          VB: Public Const NONE As Integer = 0
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
      language: CSharp
      name:
        CSharp: POSITIONAL_ARGS_COUNT_LIMIT
        VB: POSITIONAL_ARGS_COUNT_LIMIT
      nameWithType:
        CSharp: CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
        VB: CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
        VB: WizardWrx.Core.CmdLneArgsBasic.POSITIONAL_ARGS_COUNT_LIMIT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: POSITIONAL_ARGS_COUNT_LIMIT
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 359
      summary: "\nThis constant defines the default number of positional arguments\nthat instances of this class will capture.\n"
      example: []
      syntax:
        content:
          CSharp: public const int POSITIONAL_ARGS_COUNT_LIMIT = 9
          VB: Public Const POSITIONAL_ARGS_COUNT_LIMIT As Integer = 9
        return:
          type: System.Int32
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.VALUE_NOT_SET
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.VALUE_NOT_SET
      language: CSharp
      name:
        CSharp: VALUE_NOT_SET
        VB: VALUE_NOT_SET
      nameWithType:
        CSharp: CmdLneArgsBasic.VALUE_NOT_SET
        VB: CmdLneArgsBasic.VALUE_NOT_SET
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.VALUE_NOT_SET
        VB: WizardWrx.Core.CmdLneArgsBasic.VALUE_NOT_SET
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: VALUE_NOT_SET
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 367
      summary: "\nThis symbolic constant maps to the empty string, and indicates that\na specified named or positional argument was omitted from the\ncommand line.\n"
      example: []
      syntax:
        content:
          CSharp: public const string VALUE_NOT_SET = ""
          VB: Public Const VALUE_NOT_SET As String = ""
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic()
        VB: CmdLneArgsBasic()
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic()
        VB: CmdLneArgsBasic.CmdLneArgsBasic()
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic()
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 437
      summary: "\nInitialize an instance that supports exclusively positional\narguments.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic()
          VB: Public Sub New
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Int32)
        VB: CmdLneArgsBasic(Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 493
      summary: "\nInitialize an instance that supports exclusively positional\narguments, and enforces a user-specified limit, in lieu of a default\nlimit of 99 positional arguments\n\nPlease see Remarks for important security considerations.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(int pintPositionalArgCountLimit)
          VB: Public Sub New(pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[])
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[])
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[])
        VB: CmdLneArgsBasic(Char())
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[])
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char())
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[])
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 510
      summary: "\nInitialize the instance with a list of valid switches, all having a\ndefault value of Properties.Resources.SWITCH_IS_OFF.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches)
          VB: Public Sub New(pachrValidSwitches As Char())
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[])
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[])
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(String[])
        VB: CmdLneArgsBasic(String())
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(String[])
        VB: CmdLneArgsBasic.CmdLneArgsBasic(String())
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String[])
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 525
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving a default value of VALUE_NOT_SET.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(string[] pastrValidNamedArgs)
          VB: Public Sub New(pastrValidNamedArgs As String())
        parameters:
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[])
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[])
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], String[])
        VB: CmdLneArgsBasic(Char(), String())
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], String[])
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), String())
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.String[])
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.String())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 543
      summary: "\nInitialize the instance with lists of valid switches and named arguments.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, string[] pastrValidNamedArgs)
          VB: Public Sub New(pachrValidSwitches As Char(), pastrValidNamedArgs As String())
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String})
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String})
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String))
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String))
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String))
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 561
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe value specified in the corresponding item in pdctValidSwitches.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String))
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<String, String>)
        VB: CmdLneArgsBasic(Dictionary(Of String, String))
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<String, String>)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of String, String))
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.String, System.String>)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.String, System.String))
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 577
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving the default value specified in the corresponding item in\npdctValidNamedArgs.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<string, string> pdctValidNamedArgs)
          VB: Public Sub New(pdctValidNamedArgs As Dictionary(Of String, String))
        parameters:
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String})
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String})
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String))
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String))
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.Collections.Generic.Dictionary<System.String, System.String>)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.Collections.Generic.Dictionary(Of System.String, System.String))
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 599
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value specified in the corresponding item in\npdctValidSwitches, and a separate list of valid named arguments,\ndefined in the same manner.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, Dictionary<string, string> pdctValidNamedArgs)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pdctValidNamedArgs As Dictionary(Of String, String))
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Char(), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 621
      summary: "\nInitialize the instance with a list of valid switches, all having a\ndefault value of Properties.Resources.SWITCH_IS_OFF.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pachrValidSwitches As Char(), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(String(), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(String(), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 645
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving a default value of VALUE_NOT_SET.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Char(), String(), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), String(), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 672
      summary: "\nInitialize the instance with lists of valid switches and named arguments.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pachrValidSwitches As Char(), pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 698
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe value specified in the corresponding item in pdctValidSwitches.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 723
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving the default value specified in the corresponding item in\npdctValidNamedArgs.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 753
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value specified in the corresponding item in\npdctValidSwitches, and a separate list of valid named arguments,\ndefined in the same manner.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], Int32)
        VB: CmdLneArgsBasic(Char(), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 817
      summary: "\nInitialize the instance with a list of valid switches, all having a\ndefault value of Properties.Resources.SWITCH_IS_OFF.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(String[], Int32)
        VB: CmdLneArgsBasic(String(), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(String[], Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(String(), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String[], System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String(), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 880
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving a default value of VALUE_NOT_SET.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(string[] pastrValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pastrValidNamedArgs As String(), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], String[], Int32)
        VB: CmdLneArgsBasic(Char(), String(), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], String[], Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), String(), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.String[], System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.String(), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 946
      summary: "\nInitialize the instance with lists of valid switches and named arguments.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, string[] pastrValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), pastrValidNamedArgs As String(), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1011
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe value specified in the corresponding item in pdctValidSwitches.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of String, String), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of String, String), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.String, System.String>, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.String, System.String), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1075
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving the default value specified in the corresponding item in\npdctValidNamedArgs.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<string, string> pdctValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidNamedArgs As Dictionary(Of String, String), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.Collections.Generic.Dictionary<System.String, System.String>, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.Collections.Generic.Dictionary(Of System.String, System.String), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1144
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value specified in the corresponding item in\npdctValidSwitches, and a separate list of valid named arguments,\ndefined in the same manner.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, Dictionary<string, string> pdctValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pdctValidNamedArgs As Dictionary(Of String, String), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Char(), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1213
      summary: "\nInitialize the instance with a list of valid switches, all having a\ndefault value of Properties.Resources.SWITCH_IS_OFF.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(String(), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(String(), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1284
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving a default value of VALUE_NOT_SET.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Char(), String(), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), String(), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1358
      summary: "\nInitialize the instance with lists of valid switches and named arguments.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1431
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe value specified in the corresponding item in pdctValidSwitches.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1503
      summary: "\nInitialize the instance with a list of valid named arguments, each\nhaving the default value specified in the corresponding item in\npdctValidNamedArgs.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1580
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value specified in the corresponding item in\npdctValidSwitches, and a separate list of valid named arguments,\ndefined in the same manner.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), String(), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, String[], CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), String(), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1616
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value specified in the corresponding item in\npdctValidSwitches, and a separate list of valid named arguments, in\nan array of strings, with the class supplying a standard default.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic(Char(), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], Dictionary<String, String>, CmdLneArgsBasic.ArgMatching)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1648
      summary: "\nInitialize the instance with a list of valid named arguments, in\na dictionary strings, where each value is the corresponding default,\nand a list of valid switches in an array of characters, with their\ndefault values as the class default.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching)
          VB: Public Sub New(pachrValidSwitches As Char(), pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String})
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String})
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], Dictionary<String, String>)
        VB: CmdLneArgsBasic(Char(), Dictionary(Of String, String))
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], Dictionary<String, String>)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), Dictionary(Of String, String))
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.Collections.Generic.Dictionary<System.String, System.String>)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.Collections.Generic.Dictionary(Of System.String, System.String))
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1675
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value defined by the class, and a separate list of valid\nnamed arguments, each defined as a DictionaryItem, with its default\nvalue given in the value member.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, Dictionary<string, string> pdctValidNamedArgs)
          VB: Public Sub New(pachrValidSwitches As Char(), pdctValidNamedArgs As Dictionary(Of String, String))
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Char(), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], Dictionary<String, String>, CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), Dictionary(Of String, String), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.Collections.Generic.Dictionary<System.String, System.String>, WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.Collections.Generic.Dictionary(Of System.String, System.String), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1747
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value defined by the class, and a separate list of valid\nnamed arguments, each defined as a DictionaryItem, with its default\nvalue given in the value member.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, Dictionary<string, string> pdctValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), pdctValidNamedArgs As Dictionary(Of String, String), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],WizardWrx.Core.CmdLneArgsBasic.ArgMatching,System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), String(), CmdLneArgsBasic.ArgMatching, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, String[], CmdLneArgsBasic.ArgMatching, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), String(), CmdLneArgsBasic.ArgMatching, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.String[], WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.String(), WizardWrx.Core.CmdLneArgsBasic.ArgMatching, System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1826
      summary: "\nInitialize the instance with a list of valid switches, each having\nits default value defined by the value member of a DictionaryItem,\nand a separate list of valid named arguments, each defined as a\nDictionaryItem, with its default value given in the value member.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, string[] pastrValidNamedArgs, CmdLneArgsBasic.ArgMatching penmArgMatching, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pastrValidNamedArgs As String(), penmArgMatching As CmdLneArgsBasic.ArgMatching, pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: penmArgMatching
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
          description: "\nUse this member of the CmdLneArgs.ArgMatching enumeration to set the\nargument matching rules. At present, two rules are defined. See the\nIntelliSense documentation of any CmdLneArgs argument for details.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Char[],System.Collections.Generic.Dictionary{System.String,System.String},System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Char[], Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic(Char(), Dictionary(Of String, String), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Char[], Dictionary<String, String>, Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Char(), Dictionary(Of String, String), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char[], System.Collections.Generic.Dictionary<System.String, System.String>, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Char(), System.Collections.Generic.Dictionary(Of System.String, System.String), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1900
      summary: "\nInitialize the instance with a list of valid switches, each having\nthe default value defined by the class, and a separate list of valid\nnamed arguments, each defined as a DictionaryItem, with its default\nvalue given in the value member.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(char[] pachrValidSwitches, Dictionary<string, string> pdctValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pachrValidSwitches As Char(), pdctValidNamedArgs As Dictionary(Of String, String), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pachrValidSwitches
          type: System.Char[]
          description: "\nArray of characters, each of which is a valid (supported) switch.\nAll switches are initialized to Properties.Resources.SWITCH_IS_OFF.\n"
        - id: pdctValidNamedArgs
          type: System.Collections.Generic.Dictionary{System.String,System.String}
          description: "\nDictionary, keyed by argument name, a string, containing its desired\ndefault value, also a string.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.#ctor(System.Collections.Generic.Dictionary{System.Char,System.String},System.String[],System.Int32)
      language: CSharp
      name:
        CSharp: CmdLneArgsBasic(Dictionary<Char, String>, String[], Int32)
        VB: CmdLneArgsBasic(Dictionary(Of Char, String), String(), Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary<Char, String>, String[], Int32)
        VB: CmdLneArgsBasic.CmdLneArgsBasic(Dictionary(Of Char, String), String(), Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary<System.Char, System.String>, System.String[], System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic(System.Collections.Generic.Dictionary(Of System.Char, System.String), System.String(), System.Int32)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 1971
      summary: "\nInitialize the instance with a list of valid switches, each having\nits default value defined by the value member of a DictionaryItem,\nand a separate list of valid named arguments, defined in an array of\nstrings, with the default value supplied by the class.\n"
      remarks: "\nSECURITY NOTE\n\nAll constructors in this class enforce a limit on the number of\npositional arguments permitted. The default limit is 9, which is\ndefined as a public constant, POSITIONAL_ARGS_COUNT_LIMIT.\n\nThis limit is imposed to protect your program from being fed an\nexcessively long command line, in an attempt to cause a denial of\nservice. Although few applications require more than nine positional\ncommand line arguments, the level is made adjustable, to meet that\nonce per career need for more than nine arguments.\n\nWhile objects of this class cannot do anything about the number of\ncharacters in the command line (That is the responsibility of the\nCommon Language Runtime.), they can, and do, limit the amount of\nmemory allowed to be consumed to hold arguments parsed from it.\n\nNo such limits are imposed on switches and named arguments, because\nthe number of valid arguments (hence, the upper limit on memory\nconsumed by them) is under programmer control, and unlikely to be an\nissue, since invalid arguments are discarded.\n\nWHY NINE?\n\nI chose the number nine mostly for historical reasons. Starting with\nMS-DOS 1.0, the number of positional parameters supported by batch\nfiles (without resorting to tricks with SHIFT) is 9.\n\nThis limit has been carried forward into modern command processors,\nincluding CMD.EXE, the default console mode command processor of\nWindows NT, 2000, XP, Vista, etc.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic(Dictionary<char, string> pdctValidSwitches, string[] pastrValidNamedArgs, int pintPositionalArgCountLimit)
          VB: Public Sub New(pdctValidSwitches As Dictionary(Of Char, String), pastrValidNamedArgs As String(), pintPositionalArgCountLimit As Integer)
        parameters:
        - id: pdctValidSwitches
          type: System.Collections.Generic.Dictionary{System.Char,System.String}
          description: "\nDictionary, keyed by switch name, a character, containing its desired\ndefault value, a string.\n"
        - id: pastrValidNamedArgs
          type: System.String[]
          description: "\nArray of strings, each of which is a valid (supported) argument\nname. All arguments are initialized to VALUE_NOT_SET.\n"
        - id: pintPositionalArgCountLimit
          type: System.Int32
          description: "\nThe default limit on the number of positional arguments is\nPOSITIONAL_ARGS_COUNT_LIMIT, which is currently set to 9. Use this\nargument to set a lower or higher limit.\n\nA pintPositionalArgCountLimit value of less than zero is discarded\nsilently, and the default limit remains in force.\n\nPlease see Remarks for important security considerations.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases(System.String[])
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases(System.String[])
      language: CSharp
      name:
        CSharp: GetArgByMultipleAliases(String[])
        VB: GetArgByMultipleAliases(String())
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByMultipleAliases(String[])
        VB: CmdLneArgsBasic.GetArgByMultipleAliases(String())
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases(System.String[])
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases(System.String())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByMultipleAliases
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2002
      summary: "\nReturn the value of an argument that has two or more aliases.\n"
      remarks: "\nArguments are evaluated in the order specified in pastrValiddArgNames,\nSynonyms are assumed to return the same default value.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByMultipleAliases(string[] pastrValiddArgNames)
          VB: Public Function GetArgByMultipleAliases(pastrValiddArgNames As String()) As String
        parameters:
        - id: pastrValiddArgNames
          type: System.String[]
          description: "\nThis is an array of strings, each of which is the name of a command\nline argument that is a synonym. See Remarks.\n"
        return:
          type: System.String
          description: "\nThe return value is the specified value, or its default value, of\nnone of the synonyms appears in the input. See Remarks.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String)
      language: CSharp
      name:
        CSharp: GetArgByName(String)
        VB: GetArgByName(String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByName(String)
        VB: CmdLneArgsBasic.GetArgByName(String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2053
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nThis overload is a wrapper around the second overload,\nGetArgByName ( int, string ), which does the real work.\nThis method calls it internally, passing a default value of\nVALUE_NOT_SET.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByName(string pstrArgName)
          VB: Public Function GetArgByName(pstrArgName As String) As String
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        return:
          type: System.String
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pstrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String)
      language: CSharp
      name:
        CSharp: GetArgByName(String, String)
        VB: GetArgByName(String, String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByName(String, String)
        VB: CmdLneArgsBasic.GetArgByName(String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String, System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2095
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nPOTENTIAL BREAKING CHANGE:\n\nWhen the AllowEmptyStringAsDefault property is FALSE and argument\npstrDefault is a null reference, this method returns the null\nreference. Previous versions returned the empty string anyway, which\nwasn&apos;t the intended behavior, and a missing command line argument\nthereby escaped detection.\n\nHence, going forward, when pstrDefault is NULL, you must be prepared\nto handle a null reference as the return value.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByName(string pstrArgName, string pstrDefault)
          VB: Public Function GetArgByName(pstrArgName As String, pstrDefault As String) As String
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pstrDefault
          type: System.String
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line, or VALUE_NOT_SET or a null reference (Nothing in\nVisual Basic), to use an empty string as the default.\n"
        return:
          type: System.String
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pstrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String,System.Boolean)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String,System.String,System.Boolean)
      language: CSharp
      name:
        CSharp: GetArgByName(String, String, Boolean)
        VB: GetArgByName(String, String, Boolean)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByName(String, String, Boolean)
        VB: CmdLneArgsBasic.GetArgByName(String, String, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String, System.String, System.Boolean)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByName(System.String, System.String, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2162
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nPOTENTIAL BREAKING CHANGE:\n\nWhen the AllowEmptyStringAsDefault property is FALSE and argument\npstrDefault is a null reference, this method returns the null\nreference. Previous versions returned the empty string anyway, which\nwasn&apos;t the intended behavior, and a missing command line argument\nthereby escaped detection.\n\nHence, going forward, when pstrDefault is NULL, you must be prepared\nto handle a null reference as the return value.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByName(string pstrArgName, string pstrDefault, bool pfAllowEmptyStringAsDefault)
          VB: Public Function GetArgByName(pstrArgName As String, pstrDefault As String, pfAllowEmptyStringAsDefault As Boolean) As String
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pstrDefault
          type: System.String
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line, or VALUE_NOT_SET or a null reference (Nothing in\nVisual Basic), to use an empty string as the default.\n"
        - id: pfAllowEmptyStringAsDefault
          type: System.Boolean
          description: "\nSet this to TRUE if you want an empty string for the value of the\npstrDefault argument treated as a valid default value. Otherwise,\nempty strings are treated as null references (Nothing in Visual\nBasic).\n"
        return:
          type: System.String
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pstrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String)
      language: CSharp
      name:
        CSharp: GetArgByNameAsChar(String)
        VB: GetArgByNameAsChar(String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsChar(String)
        VB: CmdLneArgsBasic.GetArgByNameAsChar(String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsChar
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2213
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nThis method returns through GetArgByName, by way of \nFirstCharFromString. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      example: []
      syntax:
        content:
          CSharp: public char GetArgByNameAsChar(string pstrArgName)
          VB: Public Function GetArgByNameAsChar(pstrArgName As String) As Char
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        return:
          type: System.Char
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pchrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char)
      language: CSharp
      name:
        CSharp: GetArgByNameAsChar(String, Char)
        VB: GetArgByNameAsChar(String, Char)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsChar(String, Char)
        VB: CmdLneArgsBasic.GetArgByNameAsChar(String, Char)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String, System.Char)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsChar
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2246
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nThis method returns through GetArgByName, by way of \nFirstCharFromString. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      example: []
      syntax:
        content:
          CSharp: public char GetArgByNameAsChar(string pstrArgName, char pchrDefault)
          VB: Public Function GetArgByNameAsChar(pstrArgName As String, pchrDefault As Char) As Char
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pchrDefault
          type: System.Char
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line, or VALUE_NOT_SET or a null reference (Nothing in\nVisual Basic), to use a null character as the default.\n"
        return:
          type: System.Char
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pchrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char,System.Boolean)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String,System.Char,System.Boolean)
      language: CSharp
      name:
        CSharp: GetArgByNameAsChar(String, Char, Boolean)
        VB: GetArgByNameAsChar(String, Char, Boolean)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsChar(String, Char, Boolean)
        VB: CmdLneArgsBasic.GetArgByNameAsChar(String, Char, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String, System.Char, System.Boolean)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar(System.String, System.Char, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsChar
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2290
      summary: "\nGiven the external name of a named argument (the name that was\nsupplied to the constructor), return its value, which is either the\nvalue given on the command line or the default specified in this\nmethod call.\n"
      remarks: "\nThis method returns through GetArgByName, by way of \nFirstCharFromString. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      example: []
      syntax:
        content:
          CSharp: public char GetArgByNameAsChar(string pstrArgName, char pchrDefault, bool pfAllowEmptyStringAsDefault)
          VB: Public Function GetArgByNameAsChar(pstrArgName As String, pchrDefault As Char, pfAllowEmptyStringAsDefault As Boolean) As Char
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pchrDefault
          type: System.Char
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line, or VALUE_NOT_SET or a null reference (Nothing in\nVisual Basic), to use a null character as the default.\n"
        - id: pfAllowEmptyStringAsDefault
          type: System.Boolean
          description: "\nSet this to TRUE if you want an empty string for the value of the\npstrDefault argument treated as a valid default value. Otherwise,\nempty strings are treated as null references (Nothing in Visual\nBasic).\n"
        return:
          type: System.Char
          description: "\nIf the requested name is valid, and the argument was entered on the\ncommand line, the value supplied on the command line is returned. If\nthe argument was omitted from the command line, or if the specified\nname is invalid, the value specified in argument pchrDefault is\nreturned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String)
      language: CSharp
      name:
        CSharp: GetArgByNameAsInt(String)
        VB: GetArgByNameAsInt(String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsInt(String)
        VB: CmdLneArgsBasic.GetArgByNameAsInt(String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2317
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\nzero.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetArgByNameAsInt(string pstrArgName)
          VB: Public Function GetArgByNameAsInt(pstrArgName As String) As Integer
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetArgByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32)
      language: CSharp
      name:
        CSharp: GetArgByNameAsInt(String, Int32)
        VB: GetArgByNameAsInt(String, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsInt(String, Int32)
        VB: CmdLneArgsBasic.GetArgByNameAsInt(String, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2345
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\npintDefault.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetArgByNameAsInt(string pstrArgName, int pintDefault)
          VB: Public Function GetArgByNameAsInt(pstrArgName As String, pintDefault As Integer) As Integer
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetArgByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32,System.Boolean)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String,System.Int32,System.Boolean)
      language: CSharp
      name:
        CSharp: GetArgByNameAsInt(String, Int32, Boolean)
        VB: GetArgByNameAsInt(String, Int32, Boolean)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByNameAsInt(String, Int32, Boolean)
        VB: CmdLneArgsBasic.GetArgByNameAsInt(String, Int32, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String, System.Int32, System.Boolean)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt(System.String, System.Int32, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2380
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\npintDefault.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetArgByNameAsInt(string pstrArgName, int pintDefault, bool pfAllowEmptyStringAsDefault)
          VB: Public Function GetArgByNameAsInt(pstrArgName As String, pintDefault As Integer, pfAllowEmptyStringAsDefault As Boolean) As Integer
        parameters:
        - id: pstrArgName
          type: System.String
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line.\n"
        - id: pfAllowEmptyStringAsDefault
          type: System.Boolean
          description: "\nSet this to TRUE if you want an empty string for the value of the\npstrDefault argument treated as a valid default value. Otherwise,\nempty strings are treated as null references (Nothing in Visual\nBasic).\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetArgByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32)
      language: CSharp
      name:
        CSharp: GetArgByPosition(Int32)
        VB: GetArgByPosition(Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByPosition(Int32)
        VB: CmdLneArgsBasic.GetArgByPosition(Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByPosition
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2411
      summary: "\nGet a positional argument by its ordinal position.\n"
      remarks: "\nThis overload is a wrapper around the second overload,\nGetArgByPosition ( int, string ), which does the real work.\nThis method calls it internally, passing a default value of\nVALUE_NOT_SET.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByPosition(int pintIndex)
          VB: Public Function GetArgByPosition(pintIndex As Integer) As String
        parameters:
        - id: pintIndex
          type: System.Int32
          description: "\nPosition of argument in list. Arguments are numbered from 1.\n"
        return:
          type: System.String
          description: "\nThe argument value at the ordinal position specified by pintIndex is\nreturned, unless pintIndex is out of range, in which case an empty\nstring is returned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32,System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32,System.String)
      language: CSharp
      name:
        CSharp: GetArgByPosition(Int32, String)
        VB: GetArgByPosition(Int32, String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByPosition(Int32, String)
        VB: CmdLneArgsBasic.GetArgByPosition(Int32, String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32, System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition(System.Int32, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByPosition
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2447
      summary: "\nGet a positional argument by its ordinal position.\n"
      remarks: "\nPOTENTIAL BREAKING CHANGE:\n\nWhen the AllowEmptyStringAsDefault property is FALSE and argument\npstrDefault is a null reference, this method returns the null\nreference. Previous versions returned the empty string anyway, which\nwasn&apos;t the intended behavior, and a missing command line argument\nthereby escaped detection.\n\nHence, going forward, when pstrDefault is NULL, you must be prepared\nto handle a null reference as the return value.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetArgByPosition(int pintIndex, string pstrDefault)
          VB: Public Function GetArgByPosition(pintIndex As Integer, pstrDefault As String) As String
        parameters:
        - id: pintIndex
          type: System.Int32
          description: "\nPosition of argument in list. Arguments are numbered from 1.\n"
        - id: pstrDefault
          type: System.String
          description: "\nDefault value to return if argument ordinal is greater than the\nnumber of positional arguments entered on the command line.\n"
        return:
          type: System.String
          description: "\nThe argument value at the ordinal position specified by pintIndex is\nreturned, unless pintIndex is out of range, in which case, the\ndefault value specified in pstrDefault is returned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32)
      language: CSharp
      name:
        CSharp: GetArgByPositionAsInt(Int32)
        VB: GetArgByPositionAsInt(Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByPositionAsInt(Int32)
        VB: CmdLneArgsBasic.GetArgByPositionAsInt(Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByPositionAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2476
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\nzero.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetArgByPositionAsInt(int pintIndex)
          VB: Public Function GetArgByPositionAsInt(pintIndex As Integer) As Integer
        parameters:
        - id: pintIndex
          type: System.Int32
          description: "\nPosition of argument in list. Arguments are numbered from 1.\nthe constructor.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetArgByPosition to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32,System.Int32)
      language: CSharp
      name:
        CSharp: GetArgByPositionAsInt(Int32, Int32)
        VB: GetArgByPositionAsInt(Int32, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetArgByPositionAsInt(Int32, Int32)
        VB: CmdLneArgsBasic.GetArgByPositionAsInt(Int32, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt(System.Int32, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetArgByPositionAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2504
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\npintDefault.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetArgByPositionAsInt(int pintIndex, int pintDefault)
          VB: Public Function GetArgByPositionAsInt(pintIndex As Integer, pintDefault As Integer) As Integer
        parameters:
        - id: pintIndex
          type: System.Int32
          description: "\nPosition of argument in list. Arguments are numbered from 1.\nthe constructor.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetArgByPosition to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName(System.Char)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName(System.Char)
      language: CSharp
      name:
        CSharp: GetBooleanSwitchByName(Char)
        VB: GetBooleanSwitchByName(Char)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetBooleanSwitchByName(Char)
        VB: CmdLneArgsBasic.GetBooleanSwitchByName(Char)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName(System.Char)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName(System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetBooleanSwitchByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2530
      summary: "\nTest for the presence of a defined switch. The modifier, if any, is\nignored.\n"
      example: []
      syntax:
        content:
          CSharp: public bool GetBooleanSwitchByName(char pchrName)
          VB: Public Function GetBooleanSwitchByName(pchrName As Char) As Boolean
        parameters:
        - id: pchrName
          type: System.Char
          description: "\nCharacter to identify switch. This must be one of the characters\nstored in the array, or used as keys in the dictionary passed into\nthe instance constructor.\n"
        return:
          type: System.Boolean
          description: "\nThe return value is TRUE if the switch is present, with or without a\nmodifier (which is ignored). Otherwise, the return value is FALSE.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char)
      language: CSharp
      name:
        CSharp: GetSwitchByName(Char)
        VB: GetSwitchByName(Char)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByName(Char)
        VB: CmdLneArgsBasic.GetSwitchByName(Char)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2572
      summary: "\nReturn the value stored for a switch argument.\n"
      remarks: "\nThis overload is a wrapper around the other overload,\nGetSwitchByName ( char, string ), which does the real work.\nThis method calls it internally, passing a default value of\nProperties.Resources.SWITCH_IS_OFF.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetSwitchByName(char pchrName)
          VB: Public Function GetSwitchByName(pchrName As Char) As String
        parameters:
        - id: pchrName
          type: System.Char
          description: "\nCharacter to identify switch. This must be one of the characters\nstored in the array, or used as keys in the dictionary passed into\nthe instance constructor.\n"
        return:
          type: System.String
          description: "\nIf the switch was defined in the constructor, and it was specified\non the command line of the executing assembly, the value defined on\nthe command line is returned. Otherwise, the default value, if any,\npassed into the constructor is returned. Failing both of those, the\ngeneric default value constant, Properties.Resources.SWITCH_IS_OFF,\nis returned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String)
      language: CSharp
      name:
        CSharp: GetSwitchByName(Char, String)
        VB: GetSwitchByName(Char, String)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByName(Char, String)
        VB: CmdLneArgsBasic.GetSwitchByName(Char, String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char, System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2613
      summary: "\nReturn the value stored for a switch argument.\n"
      remarks: "\nPOTENTIAL BREAKING CHANGE:\n\nWhen the AllowEmptyStringAsDefault property is FALSE and argument\npstrDefault is a null reference, this method returns the null\nreference. Previous versions returned the empty string anyway, which\nwasn&apos;t the intended behavior, and a missing command line argument\nthereby escaped detection.\n\nHence, going forward, when pstrDefault is NULL, you must be prepared\nto handle a null reference as the return value.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetSwitchByName(char pchrName, string pstrDefault)
          VB: Public Function GetSwitchByName(pchrName As Char, pstrDefault As String) As String
        parameters:
        - id: pchrName
          type: System.Char
          description: "\nCharacter to identify switch. This must be one of the characters\nstored in the array, or used as keys in the dictionary passed into\nthe instance constructor.\n"
        - id: pstrDefault
          type: System.String
          description: "\nDefault value to return if argument pchrName is not in the list of\nvalid switches passed into the constructor. See pchrName.\n"
        return:
          type: System.String
          description: "\nIf the switch was defined in the constructor, and it was specified\non the command line of the executing assembly, the value defined on\nthe command line is returned. Otherwise, the default value, if any,\npassed into the constructor is returned. Failing both of those, the\ngeneric default value constant, Properties.Resources.SWITCH_IS_OFF,\nis returned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String,System.Boolean)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char,System.String,System.Boolean)
      language: CSharp
      name:
        CSharp: GetSwitchByName(Char, String, Boolean)
        VB: GetSwitchByName(Char, String, Boolean)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByName(Char, String, Boolean)
        VB: CmdLneArgsBasic.GetSwitchByName(Char, String, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char, System.String, System.Boolean)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName(System.Char, System.String, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByName
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2670
      summary: "\nReturn the value stored for a switch argument.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetSwitchByName(char pchrName, string pstrDefault, bool pfAllowEmptyStringAsDefault)
          VB: Public Function GetSwitchByName(pchrName As Char, pstrDefault As String, pfAllowEmptyStringAsDefault As Boolean) As String
        parameters:
        - id: pchrName
          type: System.Char
          description: "\nCharacter to identify switch. This must be one of the characters\nstored in the array, or used as keys in the dictionary passed into\nthe instance constructor.\n"
        - id: pstrDefault
          type: System.String
          description: "\nDefault value to return if argument pchrName is not in the list of\nvalid switches passed into the constructor. See pchrName.\n"
        - id: pfAllowEmptyStringAsDefault
          type: System.Boolean
          description: "\nSet this to TRUE if you want an empty string for the value of the\npstrDefault argument treated as a valid default value. Otherwise,\nempty strings are treated as null references (Nothing in Visual\nBasic).\n"
        return:
          type: System.String
          description: "\nIf the switch was defined in the constructor, and it was specified\non the command line of the executing assembly, the value defined on\nthe command line is returned. Otherwise, the default value, if any,\npassed into the constructor is returned. Failing both of those, the\ngeneric default value constant, Properties.Resources.SWITCH_IS_OFF,\nis returned.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char)
      language: CSharp
      name:
        CSharp: GetSwitchByNameAsInt(Char)
        VB: GetSwitchByNameAsInt(Char)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByNameAsInt(Char)
        VB: CmdLneArgsBasic.GetSwitchByNameAsInt(Char)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2715
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\nzero.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetSwitchByNameAsInt(char pchrArgName)
          VB: Public Function GetSwitchByNameAsInt(pchrArgName As Char) As Integer
        parameters:
        - id: pchrArgName
          type: System.Char
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetSwitchByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32)
      language: CSharp
      name:
        CSharp: GetSwitchByNameAsInt(Char, Int32)
        VB: GetSwitchByNameAsInt(Char, Int32)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByNameAsInt(Char, Int32)
        VB: CmdLneArgsBasic.GetSwitchByNameAsInt(Char, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char, System.Int32)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2743
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\npintDefault.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetSwitchByNameAsInt(char pchrArgName, int pintDefault)
          VB: Public Function GetSwitchByNameAsInt(pchrArgName As Char, pintDefault As Integer) As Integer
        parameters:
        - id: pchrArgName
          type: System.Char
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line.\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetSwitchByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32,System.Boolean)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char,System.Int32,System.Boolean)
      language: CSharp
      name:
        CSharp: GetSwitchByNameAsInt(Char, Int32, Boolean)
        VB: GetSwitchByNameAsInt(Char, Int32, Boolean)
      nameWithType:
        CSharp: CmdLneArgsBasic.GetSwitchByNameAsInt(Char, Int32, Boolean)
        VB: CmdLneArgsBasic.GetSwitchByNameAsInt(Char, Int32, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char, System.Int32, System.Boolean)
        VB: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt(System.Char, System.Int32, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetSwitchByNameAsInt
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2778
      summary: "\nIf the value of a switch is an integer, return it. Otherwise, return\npintDefault.\n"
      example: []
      syntax:
        content:
          CSharp: public int GetSwitchByNameAsInt(char pchrArgName, int pintDefault, bool pfAllowEmptyStringAsDefault)
          VB: Public Function GetSwitchByNameAsInt(pchrArgName As Char, pintDefault As Integer, pfAllowEmptyStringAsDefault As Boolean) As Integer
        parameters:
        - id: pchrArgName
          type: System.Char
          description: "\nSpecify the external name of the argument, as it was identified to\nthe constructor.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nSpecify a default value to return if the argument was omitted from\nthe command line.\n"
        - id: pfAllowEmptyStringAsDefault
          type: System.Boolean
          description: "\nSet this to TRUE if you want an empty string for the value of the\npstrDefault argument treated as a valid default value. Otherwise,\nempty strings are treated as null references (Nothing in Visual\nBasic).\n"
        return:
          type: System.Int32
          description: "\nThis method passes the value returned by GetSwitchByName to the \nint.TryParse method. Hence, everything that applies to either of\nthem applies as well to this method.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue(System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue(System.String)
      language: CSharp
      name:
        CSharp: ArgNameFromKeyValue(String)
        VB: ArgNameFromKeyValue(String)
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgNameFromKeyValue(String)
        VB: CmdLneArgsBasic.ArgNameFromKeyValue(String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue(System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArgNameFromKeyValue
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2822
      summary: "\nExtract the argument name from a string that consists of the key\n(index) of the collection.\n"
      remarks: "\nSince this class derives from a Dictionary whose keys and values are\nstrings, given the string that becomes the pstrArgKey argument of\nthis method, you could just as easily get the value directly.\nHowever, if you did so, you would lose the benefit of default value\nassignment, not to mention the accessors that bundle conversions to\nInteger, Boolean, and Character types. Moreover, reaching into the\nbase class makes it slightly less obvious that the value retrieved\nis that of a command line argument, let alone its name and intrinsic\ntype (switch versus named argument versus positional argument).\n\nA wiser design would hide the dictionary from view. Notwithstanding\nthis one-off use, it is not too late to do so, since this is the\nonly case in which I have reached into the base class in this way.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ArgNameFromKeyValue(string pstrArgKey)
          VB: Public Shared Function ArgNameFromKeyValue(pstrArgKey As String) As String
        parameters:
        - id: pstrArgKey
          type: System.String
          description: "\nSpecify the key to parse and strip, so that it can be fed into an\ninstance method to retrieve the value of a named argument or switch.\n"
        return:
          type: System.String
          description: "\nIf the function succeeds, the return value is the name of a named\nargument or of a switch, which can be fed into GetArgByName, \nGetSwitchByName, or one of their siblings.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String)
      language: CSharp
      name:
        CSharp: FirstCharFromString(String)
        VB: FirstCharFromString(String)
      nameWithType:
        CSharp: CmdLneArgsBasic.FirstCharFromString(String)
        VB: CmdLneArgsBasic.FirstCharFromString(String)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String)
        VB: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FirstCharFromString
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2861
      summary: "\nExtract the first character from a string, and return it as a char\nvalue type.\n"
      example: []
      syntax:
        content:
          CSharp: public static char FirstCharFromString(string pstrIn)
          VB: Public Shared Function FirstCharFromString(pstrIn As String) As Char
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nThe first character in this string is returned.\n"
        return:
          type: System.Char
          description: "\nThe return value is the first character of string pstrIn, as a\nscalar value type.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString*
      exceptions:
      - type: System.ArgumentException
        commentId: T:System.ArgumentException
        description: "\nIf the input string, pstrIn, is null or empty, an ArgumentException\nis thrown. See the next overload for an alternative that doesn&apos;t\nthrow exceptions.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentException: 
    - id: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String,System.Char)
      commentId: M:WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String,System.Char)
      language: CSharp
      name:
        CSharp: FirstCharFromString(String, Char)
        VB: FirstCharFromString(String, Char)
      nameWithType:
        CSharp: CmdLneArgsBasic.FirstCharFromString(String, Char)
        VB: CmdLneArgsBasic.FirstCharFromString(String, Char)
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String, System.Char)
        VB: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString(System.String, System.Char)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FirstCharFromString
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2895
      summary: "\nExtract the first character from a string, and return it as a char\nvalue type.\n"
      example: []
      syntax:
        content:
          CSharp: public static char FirstCharFromString(string pstrIn, char pchrDefault)
          VB: Public Shared Function FirstCharFromString(pstrIn As String, pchrDefault As Char) As Char
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nThe first character in this string is returned.\n"
        - id: pchrDefault
          type: System.Char
          description: "\nIf string pstrIn is null or empty, this character is returned.\n"
        return:
          type: System.Char
          description: "\nThe return value is the first character of string pstrIn, as a\nscalar value type.\n"
      overload: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
      language: CSharp
      name:
        CSharp: ArgListIsEmpty
        VB: ArgListIsEmpty
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgListIsEmpty
        VB: CmdLneArgsBasic.ArgListIsEmpty
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArgListIsEmpty
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2928
      summary: "\nThis property returns True (ARG_LIST_IS_EMPTY) when the command line\nis devoid of arguments.\n\nOtherwise, it returns False (ARG_LIST_HAS_ARGS), indicating that the\ncommand line contains at least one argument. See Remarks.\n"
      remarks: "\nArgListIsEmpty being false means only that there is an argument in\nthe command line, which may be invalid. Check the ArgMatching array\nor the two invalid argument counters, InvalidNamedArgsInCmd and\nInvalidSwitchesInCmd.\n"
      example: []
      syntax:
        content:
          CSharp: public bool ArgListIsEmpty { get; }
          VB: Public ReadOnly Property ArgListIsEmpty As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
      language: CSharp
      name:
        CSharp: AllowEmptyStringAsDefault
        VB: AllowEmptyStringAsDefault
      nameWithType:
        CSharp: CmdLneArgsBasic.AllowEmptyStringAsDefault
        VB: CmdLneArgsBasic.AllowEmptyStringAsDefault
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
        VB: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: AllowEmptyStringAsDefault
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2975
      summary: "\nThe value of this property determines how the GetArgDefaultToUse and\nGetSwitchDefaultToUse methods treat an empty string supplied as a\ndefault value to return. See Remarks for complete details.\n"
      remarks: "\nThe AllowEmptyStringAsDefault property is initialized to FALSE, to\nmaintain backwards compatibility with previous versions of the\nlibrary that exports this class.\n\nBy default switches return a string value of &quot;OFF&quot; to indicate their\nomission from the command line. To override this behavior, you must\ncall the two-argument overload of GetSwitchDefaultToUse, specifying\na default string value as the second argument.\n\nPrior to version 2.0, this overload treated both null references\n(Nothing in Visual Basic) and empty strings equally, returning the\nclass default value of &quot;OFF&quot; in both cases.\n\nBeginning with version 2.0, this behavior can be overridden in one\nof two ways.\n\n1) Setting the AllowEmptyStringAsDefault property to TRUE (signified\nby symbolic constant BLANK_AS_DEFAULT_ALLOWED) changes the behavior\nfor the entire class for the rest of its lifetime, or until it is\nset back to its default, whichever comes first.\n\n2) Calling method GetSwitchDefaultToUse or GetArgDefaultToUse with a\nthird (Boolean) argument that affects only the behavior of that one\ncall, regardless of the current AllowEmptyStringAsDefault setting.\nThis method leaves the AllowEmptyStringAsDefault property unchanged.\n"
      example: []
      syntax:
        content:
          CSharp: public bool AllowEmptyStringAsDefault { get; set; }
          VB: Public Property AllowEmptyStringAsDefault As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
      language: CSharp
      name:
        CSharp: ArgumentMatching
        VB: ArgumentMatching
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgumentMatching
        VB: CmdLneArgsBasic.ArgumentMatching
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArgumentMatching
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2986
      summary: "\nAlthough you cannot change the rules in the middle of the game,\ntransparency is highly desirable.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic.ArgMatching ArgumentMatching { get; }
          VB: Public ReadOnly Property ArgumentMatching As CmdLneArgsBasic.ArgMatching
        parameters: []
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
      overload: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
      language: CSharp
      name:
        CSharp: ArgumentTypeArray
        VB: ArgumentTypeArray
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgumentTypeArray
        VB: CmdLneArgsBasic.ArgumentTypeArray
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ArgumentTypeArray
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 2994
      summary: "\nThis property is an array of ArgType enumerated types, which has one\nelement for each command line argument. Use this list to find and\nreport invalid command line arguments, if any.\n"
      example: []
      syntax:
        content:
          CSharp: public CmdLneArgsBasic.ArgType[] ArgumentTypeArray { get; }
          VB: Public ReadOnly Property ArgumentTypeArray As CmdLneArgsBasic.ArgType()
        parameters: []
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType[]
      overload: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.Count
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.Count
      language: CSharp
      name:
        CSharp: Count
        VB: Count
      nameWithType:
        CSharp: CmdLneArgsBasic.Count
        VB: CmdLneArgsBasic.Count
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.Count
        VB: WizardWrx.Core.CmdLneArgsBasic.Count
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Count
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3012
      summary: "\nGet the total number of valid arguments of all types.\n"
      example: []
      syntax:
        content:
          CSharp: public int Count { get; }
          VB: Public ReadOnly Property Count As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.Count*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
      language: CSharp
      name:
        CSharp: DefinedNamedArgs
        VB: DefinedNamedArgs
      nameWithType:
        CSharp: CmdLneArgsBasic.DefinedNamedArgs
        VB: CmdLneArgsBasic.DefinedNamedArgs
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
        VB: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DefinedNamedArgs
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3016
      summary: "\nGet the count of named arguments defined by the constructor.\n"
      example: []
      syntax:
        content:
          CSharp: public int DefinedNamedArgs { get; }
          VB: Public ReadOnly Property DefinedNamedArgs As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
      language: CSharp
      name:
        CSharp: DefinedSwitches
        VB: DefinedSwitches
      nameWithType:
        CSharp: CmdLneArgsBasic.DefinedSwitches
        VB: CmdLneArgsBasic.DefinedSwitches
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
        VB: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DefinedSwitches
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3022
      summary: "\nCount of switches defined by the constructor\n"
      example: []
      syntax:
        content:
          CSharp: public int DefinedSwitches { get; }
          VB: Public ReadOnly Property DefinedSwitches As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
      language: CSharp
      name:
        CSharp: InvalidArgsCount
        VB: InvalidArgsCount
      nameWithType:
        CSharp: CmdLneArgsBasic.InvalidArgsCount
        VB: CmdLneArgsBasic.InvalidArgsCount
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
        VB: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InvalidArgsCount
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3030
      summary: "\nTotal number of invalid arguments found in the command line. This is\nthe sum of InvalidNamedArgsInCmd and InvalidSwitchesInCmd. Use it as\na quick check for invalid arguments.\n"
      example: []
      syntax:
        content:
          CSharp: public int InvalidArgsCount { get; }
          VB: Public ReadOnly Property InvalidArgsCount As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
      language: CSharp
      name:
        CSharp: InvalidNamedArgsInCmd
        VB: InvalidNamedArgsInCmd
      nameWithType:
        CSharp: CmdLneArgsBasic.InvalidNamedArgsInCmd
        VB: CmdLneArgsBasic.InvalidNamedArgsInCmd
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
        VB: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InvalidNamedArgsInCmd
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3036
      summary: "\nCount of invalid named arguments found in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: public int InvalidNamedArgsInCmd { get; }
          VB: Public ReadOnly Property InvalidNamedArgsInCmd As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
      language: CSharp
      name:
        CSharp: InvalidSwitchesInCmd
        VB: InvalidSwitchesInCmd
      nameWithType:
        CSharp: CmdLneArgsBasic.InvalidSwitchesInCmd
        VB: CmdLneArgsBasic.InvalidSwitchesInCmd
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
        VB: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InvalidSwitchesInCmd
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3042
      summary: "\nCount of invalid switches found in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: public int InvalidSwitchesInCmd { get; }
          VB: Public ReadOnly Property InvalidSwitchesInCmd As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
      language: CSharp
      name:
        CSharp: PositionalArgsInCmdLine
        VB: PositionalArgsInCmdLine
      nameWithType:
        CSharp: CmdLneArgsBasic.PositionalArgsInCmdLine
        VB: CmdLneArgsBasic.PositionalArgsInCmdLine
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
        VB: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PositionalArgsInCmdLine
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3048
      summary: "\nCount of positional arguments found in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: public int PositionalArgsInCmdLine { get; }
          VB: Public ReadOnly Property PositionalArgsInCmdLine As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
      language: CSharp
      name:
        CSharp: SWITCH_IS_OFF
        VB: SWITCH_IS_OFF
      nameWithType:
        CSharp: CmdLneArgsBasic.SWITCH_IS_OFF
        VB: CmdLneArgsBasic.SWITCH_IS_OFF
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
        VB: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SWITCH_IS_OFF
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3065
      summary: "\nGets the SWITCH_IS_OFF string, which is loaded from the string\nresources of the DLL into a private static read-only string.\n"
      remarks: "\nThis static read-only property replaces a like named constant, which\nI moved into the resource strings because that is really where it\nbelongs, so that the library can be adapted for another language by\nsubstituting a localized string resource.\n\nWhile the simplest approach would be to assign these names to the\nprivate strings, and mark them public, doing so would obscure their\ntheir true nature.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SWITCH_IS_OFF { get; }
          VB: Public Shared ReadOnly Property SWITCH_IS_OFF As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
      language: CSharp
      name:
        CSharp: SWITCH_IS_ON
        VB: SWITCH_IS_ON
      nameWithType:
        CSharp: CmdLneArgsBasic.SWITCH_IS_ON
        VB: CmdLneArgsBasic.SWITCH_IS_ON
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
        VB: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SWITCH_IS_ON
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3088
      summary: "\nGets the SWITCH_IS_ON string, which is loaded from the string\nresources of the DLL into a private static read-only string.\n"
      remarks: "\nThis static read-only property replaces a like named constant, which\nI moved into the resource strings because that is really where it\nbelongs, so that the library can be adapted for another language by\nsubstituting a localized string resource.\n\nWhile the simplest approach would be to assign these names to the\nprivate strings, and mark them public, doing so would obscure their\ntheir true nature.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SWITCH_IS_ON { get; }
          VB: Public Shared ReadOnly Property SWITCH_IS_ON As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
      language: CSharp
      name:
        CSharp: ValidNamedArgsInCmdLine
        VB: ValidNamedArgsInCmdLine
      nameWithType:
        CSharp: CmdLneArgsBasic.ValidNamedArgsInCmdLine
        VB: CmdLneArgsBasic.ValidNamedArgsInCmdLine
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
        VB: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ValidNamedArgsInCmdLine
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3099
      summary: "\nCount of valid named arguments found in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: public int ValidNamedArgsInCmdLine { get; }
          VB: Public ReadOnly Property ValidNamedArgsInCmdLine As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
      commentId: P:WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
      language: CSharp
      name:
        CSharp: ValidSwitchesInCmdLine
        VB: ValidSwitchesInCmdLine
      nameWithType:
        CSharp: CmdLneArgsBasic.ValidSwitchesInCmdLine
        VB: CmdLneArgsBasic.ValidSwitchesInCmdLine
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
        VB: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ValidSwitchesInCmdLine
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 3104
      summary: "\nCount of valid switches found in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: public int ValidSwitchesInCmdLine { get; }
          VB: Public ReadOnly Property ValidSwitchesInCmdLine As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
  - id: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
    commentId: T:WizardWrx.Core.CmdLneArgsBasic.ArgMatching
    language: CSharp
    name:
      CSharp: CmdLneArgsBasic.ArgMatching
      VB: CmdLneArgsBasic.ArgMatching
    nameWithType:
      CSharp: CmdLneArgsBasic.ArgMatching
      VB: CmdLneArgsBasic.ArgMatching
    qualifiedName:
      CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
      VB: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/CmdLneArgsBasic.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ArgMatching
      path: ../Core/CmdLneArgsBasic.cs
      startLine: 233
    summary: "\nArgument matching may be either case sensitive (default) or case\ninsensitive (by constructor override). Constructor argument\npenmArgMatching is of this type.\n"
    example: []
    syntax:
      content:
        CSharp: public enum ArgMatching
        VB: Public Enum ArgMatching
    extensionMethods:
    - WizardWrx.Core.CmdLneArgsBasic.ArgMatching.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseSensitive
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseSensitive
      language: CSharp
      name:
        CSharp: CaseSensitive
        VB: CaseSensitive
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgMatching.CaseSensitive
        VB: CmdLneArgsBasic.ArgMatching.CaseSensitive
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseSensitive
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseSensitive
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CaseSensitive
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 238
      summary: "\nArgument matching is case sensitive.\n"
      example: []
      syntax:
        content:
          CSharp: CaseSensitive = 0
          VB: CaseSensitive = 0
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseInsensitive
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseInsensitive
      language: CSharp
      name:
        CSharp: CaseInsensitive
        VB: CaseInsensitive
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgMatching.CaseInsensitive
        VB: CmdLneArgsBasic.ArgMatching.CaseInsensitive
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseInsensitive
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgMatching.CaseInsensitive
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CaseInsensitive
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 243
      summary: "\nArgument matching is case insensitive.\n"
      example: []
      syntax:
        content:
          CSharp: CaseInsensitive = 1
          VB: CaseInsensitive = 1
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Core.CmdLneArgsBasic.ArgType
    commentId: T:WizardWrx.Core.CmdLneArgsBasic.ArgType
    language: CSharp
    name:
      CSharp: CmdLneArgsBasic.ArgType
      VB: CmdLneArgsBasic.ArgType
    nameWithType:
      CSharp: CmdLneArgsBasic.ArgType
      VB: CmdLneArgsBasic.ArgType
    qualifiedName:
      CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType
      VB: WizardWrx.Core.CmdLneArgsBasic.ArgType
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/CmdLneArgsBasic.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: ArgType
      path: ../Core/CmdLneArgsBasic.cs
      startLine: 258
    summary: "\nArguments may be of three types:\n\n1) Named\n2) Positional\n3) Switch\n\nFurther, the first and third types may be invalid arguments of their\nrespective types. That is, a switch may be invalid, or the name of a\nNamed Argument may be invalid.        ///\n"
    example: []
    syntax:
      content:
        CSharp: public enum ArgType
        VB: Public Enum ArgType
    extensionMethods:
    - WizardWrx.Core.CmdLneArgsBasic.ArgType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidNamed
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidNamed
      language: CSharp
      name:
        CSharp: InvalidNamed
        VB: InvalidNamed
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgType.InvalidNamed
        VB: CmdLneArgsBasic.ArgType.InvalidNamed
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidNamed
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidNamed
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InvalidNamed
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 264
      summary: "\nThe specified argument appears to be a named argument, but its\nname is undefined (not on the list of valid names).\n"
      example: []
      syntax:
        content:
          CSharp: InvalidNamed = 0
          VB: InvalidNamed = 0
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidSwitch
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidSwitch
      language: CSharp
      name:
        CSharp: InvalidSwitch
        VB: InvalidSwitch
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgType.InvalidSwitch
        VB: CmdLneArgsBasic.ArgType.InvalidSwitch
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidSwitch
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgType.InvalidSwitch
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InvalidSwitch
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 270
      summary: "\nThe specified argument appears to be a switch, but its name is\nundefined (not on the list of valid switch characters).\n"
      example: []
      syntax:
        content:
          CSharp: InvalidSwitch = 1
          VB: InvalidSwitch = 1
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgType.Named
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Named
      language: CSharp
      name:
        CSharp: Named
        VB: Named
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgType.Named
        VB: CmdLneArgsBasic.ArgType.Named
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType.Named
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgType.Named
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Named
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 276
      summary: "\nThe argument is named, and its value is in the list of valid\nnames.\n"
      example: []
      syntax:
        content:
          CSharp: Named = 2
          VB: Named = 2
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgType.Positional
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Positional
      language: CSharp
      name:
        CSharp: Positional
        VB: Positional
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgType.Positional
        VB: CmdLneArgsBasic.ArgType.Positional
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType.Positional
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgType.Positional
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Positional
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 283
      summary: "\nThe argument is positional. That is, it is neither a named\nargument, nor a switch. Its meaning is defined by its order of\nappearance in the command line.\n"
      example: []
      syntax:
        content:
          CSharp: Positional = 3
          VB: Positional = 3
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.CmdLneArgsBasic.ArgType.Switch
      commentId: F:WizardWrx.Core.CmdLneArgsBasic.ArgType.Switch
      language: CSharp
      name:
        CSharp: Switch
        VB: Switch
      nameWithType:
        CSharp: CmdLneArgsBasic.ArgType.Switch
        VB: CmdLneArgsBasic.ArgType.Switch
      qualifiedName:
        CSharp: WizardWrx.Core.CmdLneArgsBasic.ArgType.Switch
        VB: WizardWrx.Core.CmdLneArgsBasic.ArgType.Switch
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/CmdLneArgsBasic.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Switch
        path: ../Core/CmdLneArgsBasic.cs
        startLine: 289
      summary: "\nThe argument is a switch, and its value is in the list of valid\nswitch characters.\n"
      example: []
      syntax:
        content:
          CSharp: Switch = 4
          VB: Switch = 4
        return:
          type: WizardWrx.Core.CmdLneArgsBasic.ArgType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Core.EnvTokenExpander
    commentId: T:WizardWrx.Core.EnvTokenExpander
    language: CSharp
    name:
      CSharp: EnvTokenExpander
      VB: EnvTokenExpander
    nameWithType:
      CSharp: EnvTokenExpander
      VB: EnvTokenExpander
    qualifiedName:
      CSharp: WizardWrx.Core.EnvTokenExpander
      VB: WizardWrx.Core.EnvTokenExpander
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/EnvTokenExpander.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: EnvTokenExpander
      path: ../Core/EnvTokenExpander.cs
      startLine: 93
    summary: "\nThis class is implemented as a very lean Singleton.\n"
    example: []
    syntax:
      content:
        CSharp: public class EnvTokenExpander
        VB: Public Class EnvTokenExpander
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.EnvTokenExpander.ENV_STR_DLM
      commentId: F:WizardWrx.Core.EnvTokenExpander.ENV_STR_DLM
      language: CSharp
      name:
        CSharp: ENV_STR_DLM
        VB: ENV_STR_DLM
      nameWithType:
        CSharp: EnvTokenExpander.ENV_STR_DLM
        VB: EnvTokenExpander.ENV_STR_DLM
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.ENV_STR_DLM
        VB: WizardWrx.Core.EnvTokenExpander.ENV_STR_DLM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ENV_STR_DLM
        path: ../Core/EnvTokenExpander.cs
        startLine: 99
      summary: "\nFor reference, the character that delminits an environment string\ntoken is exposed as a public constant.\n"
      example: []
      syntax:
        content:
          CSharp: public const char ENV_STR_DLM = '%'
          VB: Public Const ENV_STR_DLM As Char = "%"c
        return:
          type: System.Char
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.EnvTokenExpander.GetTokenExpander
      commentId: M:WizardWrx.Core.EnvTokenExpander.GetTokenExpander
      language: CSharp
      name:
        CSharp: GetTokenExpander()
        VB: GetTokenExpander()
      nameWithType:
        CSharp: EnvTokenExpander.GetTokenExpander()
        VB: EnvTokenExpander.GetTokenExpander()
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.GetTokenExpander()
        VB: WizardWrx.Core.EnvTokenExpander.GetTokenExpander()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetTokenExpander
        path: ../Core/EnvTokenExpander.cs
        startLine: 138
      summary: "\nAll classes that want to call methods on this object must first call\nthis method.\n"
      remarks: "\nThis pseudo-constructor must be declared static. Its only real job\nis to return a reference to itself, personified as _TheInstance. \n"
      example: []
      syntax:
        content:
          CSharp: public static EnvTokenExpander GetTokenExpander()
          VB: Public Shared Function GetTokenExpander As EnvTokenExpander
        return:
          type: WizardWrx.Core.EnvTokenExpander
          description: "\nA reference to the single instance of this object, which all\nconsumers share.\n"
      overload: WizardWrx.Core.EnvTokenExpander.GetTokenExpander*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.EnvTokenExpander.Acquire
      commentId: M:WizardWrx.Core.EnvTokenExpander.Acquire
      language: CSharp
      name:
        CSharp: Acquire()
        VB: Acquire()
      nameWithType:
        CSharp: EnvTokenExpander.Acquire()
        VB: EnvTokenExpander.Acquire()
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.Acquire()
        VB: WizardWrx.Core.EnvTokenExpander.Acquire()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Acquire
        path: ../Core/EnvTokenExpander.cs
        startLine: 151
      summary: "\nRather than have the caller lock the object, I provide this pair of\nmethods that create a similar effect, by causing a competing caller\nof an object in a Frozen state to told to wait its turn.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Acquire()
          VB: Public Function Acquire As Boolean
        return:
          type: System.Boolean
          description: "\nTRUE, unless the object is already frozen by another thread.\n"
      overload: WizardWrx.Core.EnvTokenExpander.Acquire*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken(System.String)
      commentId: M:WizardWrx.Core.EnvTokenExpander.ContainsEnvToken(System.String)
      language: CSharp
      name:
        CSharp: ContainsEnvToken(String)
        VB: ContainsEnvToken(String)
      nameWithType:
        CSharp: EnvTokenExpander.ContainsEnvToken(String)
        VB: EnvTokenExpander.ContainsEnvToken(String)
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken(System.String)
        VB: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ContainsEnvToken
        path: ../Core/EnvTokenExpander.cs
        startLine: 189
      summary: "\nReturns TRUE if the input string contains at least one environment\nstring token.\n"
      remarks: "\nAn environment string token is defined as a substring delimited\nby &apos;%&apos; charagers, which are symbolically represented by\nENV_STR_DLM in this class.\n\nBecause this is a public method of a singleton, it cannot be marked\nStatic. If it were so marked, it would lose access to the private\nstorage that motivated me to finally sit down and figure out how to\nimplement the Singleton pattern in C#.\n"
      example: []
      syntax:
        content:
          CSharp: public bool ContainsEnvToken(string pstrIn)
          VB: Public Function ContainsEnvToken(pstrIn As String) As Boolean
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString to evaluate for presence of environment string tokens.\n"
        return:
          type: System.Boolean
          description: "\nTRUE if the string contains at least one environment string token.\nOtherwise return FALSE.\n"
      overload: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken(System.String)
      commentId: M:WizardWrx.Core.EnvTokenExpander.ExtractEnvToken(System.String)
      language: CSharp
      name:
        CSharp: ExtractEnvToken(String)
        VB: ExtractEnvToken(String)
      nameWithType:
        CSharp: EnvTokenExpander.ExtractEnvToken(String)
        VB: EnvTokenExpander.ExtractEnvToken(String)
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken(System.String)
        VB: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExtractEnvToken
        path: ../Core/EnvTokenExpander.cs
        startLine: 237
      summary: "\nIf the input string contains an enviroment token, extract and return\nit.\n"
      remarks: "\nAn environment string token is defined as a substring delimited\nby &apos;%&apos; charagers, which are symbolically represented by\nENV_STR_DLM in this class.\n\nSince this method returns the string without its delimiters, pass it\nto static method TokenizeEnvVarName to convert it to a string that\ncan be passed into a Replace method, to replace the token with its\nvalue, which you got by calling Environment.GetEnvironmentVariable.\n\nBecause this is a public method of a singleton, it cannot be marked\nStatic. If it were so marked, it would lose access to the private\nstorage that motivated me to finally sit down and figure out how to\nimplement the Singleton pattern in C#.\n"
      example: []
      syntax:
        content:
          CSharp: public string ExtractEnvToken(string pstrIn)
          VB: Public Function ExtractEnvToken(pstrIn As String) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString from which to extract an environment variable token.\n"
        return:
          type: System.String
          description: "\nString containing the token, minus its delimiters.\n"
      overload: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.EnvTokenExpander.Free
      commentId: M:WizardWrx.Core.EnvTokenExpander.Free
      language: CSharp
      name:
        CSharp: Free()
        VB: Free()
      nameWithType:
        CSharp: EnvTokenExpander.Free()
        VB: EnvTokenExpander.Free()
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.Free()
        VB: WizardWrx.Core.EnvTokenExpander.Free()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Free
        path: ../Core/EnvTokenExpander.cs
        startLine: 265
      summary: "\nRather than have the caller lock the object, I provide this pair of\nmethods that create a similar effect, by causing a competing caller\nof an object in a Frozen state to be thrown and exception.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Free()
          VB: Public Function Free As Boolean
        return:
          type: System.Boolean
          description: "\nAlways True.\n"
      overload: WizardWrx.Core.EnvTokenExpander.Free*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.EnvTokenExpander.Busy
      commentId: P:WizardWrx.Core.EnvTokenExpander.Busy
      language: CSharp
      name:
        CSharp: Busy
        VB: Busy
      nameWithType:
        CSharp: EnvTokenExpander.Busy
        VB: EnvTokenExpander.Busy
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.Busy
        VB: WizardWrx.Core.EnvTokenExpander.Busy
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Busy
        path: ../Core/EnvTokenExpander.cs
        startLine: 287
      summary: "\nReturns TRUE if the EnvTokenExpander is Busy, which means that a thread\nhas acquired it, by calling its Acquire method.\n"
      remarks: "\nBy acquiring the EnvTokenExpander, a thread can shave a tad off the\nprocessing needed to find the first occurrance of a token, in order\nto extract it, if it intends to call ContainsEnvToken before calling\nExtractEnvToken.\n"
      example: []
      syntax:
        content:
          CSharp: public bool Busy { get; }
          VB: Public ReadOnly Property Busy As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.EnvTokenExpander.Busy*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens(System.String,System.String)
      commentId: M:WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens(System.String,System.String)
      language: CSharp
      name:
        CSharp: ExpandEnvironmentTokens(String, String)
        VB: ExpandEnvironmentTokens(String, String)
      nameWithType:
        CSharp: EnvTokenExpander.ExpandEnvironmentTokens(String, String)
        VB: EnvTokenExpander.ExpandEnvironmentTokens(String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens(System.String, System.String)
        VB: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens(System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ExpandEnvironmentTokens
        path: ../Core/EnvTokenExpander.cs
        startLine: 308
      summary: "\nGiven a string that contains one or more environment string tokens,\nexpand the tokens, returning the resulting string.\n"
      example: []
      syntax:
        content:
          CSharp: public static string ExpandEnvironmentTokens(string pstrIn, string pstrDefault = null)
          VB: Public Shared Function ExpandEnvironmentTokens(pstrIn As String, pstrDefault As String = Nothing) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString to parse and expand environment string tokens.\n"
        - id: pstrDefault
          type: System.String
          description: "\nOptional string to return as default if an undefined (empty)\nenvironment variable is encountered in input string\n<code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrIn</code>.\n"
        return:
          type: System.String
          description: "\nThe return value is string <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrIn</code> with its\nenvironment tokens expanded.\n"
      overload: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName(System.String)
      commentId: M:WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName(System.String)
      language: CSharp
      name:
        CSharp: TokenizeEnvVarName(String)
        VB: TokenizeEnvVarName(String)
      nameWithType:
        CSharp: EnvTokenExpander.TokenizeEnvVarName(String)
        VB: EnvTokenExpander.TokenizeEnvVarName(String)
      qualifiedName:
        CSharp: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName(System.String)
        VB: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/EnvTokenExpander.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TokenizeEnvVarName
        path: ../Core/EnvTokenExpander.cs
        startLine: 387
      summary: "\nGiven a string, assumed to be the name of an environment string,\nreturn it with the expected escape (&quot;quote&quot;) characters appended to\nboth ends.\n"
      remarks: "\nUse this method to turn the output of ExtractEnvToken into a string\nthat can be fed to a Replace method to substitute the value of the\nenvironment variable for its token.\n"
      example: []
      syntax:
        content:
          CSharp: public static string TokenizeEnvVarName(string pstrIn)
          VB: Public Shared Function TokenizeEnvVarName(pstrIn As String) As String
        parameters:
        - id: pstrIn
          type: System.String
          description: "\nString to turn into an environment variable token.\n"
        return:
          type: System.String
          description: "\nString pstrIn, with the escape characters (%) appended to both ends.\n"
      overload: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Core.PropertyDefaults
    commentId: T:WizardWrx.Core.PropertyDefaults
    language: CSharp
    name:
      CSharp: PropertyDefaults
      VB: PropertyDefaults
    nameWithType:
      CSharp: PropertyDefaults
      VB: PropertyDefaults
    qualifiedName:
      CSharp: WizardWrx.Core.PropertyDefaults
      VB: WizardWrx.Core.PropertyDefaults
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/PropertyDefaults.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: PropertyDefaults
      path: ../Core/PropertyDefaults.cs
      startLine: 150
    summary: "\nExpose the AppSettingsSection associated with this DLL. \n\nThe configuration settings come from the base class. The configuration\nsettings come from the base class, AssemblyLocatorBase; hence, this\nclass also serves as the concrete example that is recommended to\naccompany distribution of any abstract base class.\n\nThe settings exposed by this class inhabit a configuration file that is\nassociated with the DLL, itself, as opposed to the application \nconfiguration. Though its format is similar to that of the application\nconfiguration file, the DLL configuration lives in its own configuration\nfile that has the same name as the DLL, with an additional suffix of\n.config.\n"
    remarks: "\nThe rationale behind segregating these settings is that the affected\napplication properties are ones that you want to keep consistent, or\nnearly so, across large groups of applications. Keeping them in a\ndedicated configuration file that travels with the DLL that implements\nthem eliminates the thankless task of adding them to every application\nconfiguration file.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class PropertyDefaults : AssemblyLocatorBase'
        VB: >-
          Public Class PropertyDefaults

              Inherits AssemblyLocatorBase
    inheritance:
    - System.Object
    - WizardWrx.Core.AssemblyLocatorBase
    inheritedMembers:
    - WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
    - WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
    - WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
    - WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
    - WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
    - WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
    - WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
    - WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
    - WizardWrx.Core.AssemblyLocatorBase.DLLSettings
    - WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
    - WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
    - WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.PropertyDefaults.#ctor
      commentId: M:WizardWrx.Core.PropertyDefaults.#ctor
      language: CSharp
      name:
        CSharp: PropertyDefaults()
        VB: PropertyDefaults()
      nameWithType:
        CSharp: PropertyDefaults.PropertyDefaults()
        VB: PropertyDefaults.PropertyDefaults()
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.PropertyDefaults()
        VB: WizardWrx.Core.PropertyDefaults.PropertyDefaults()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/PropertyDefaults.cs
        startLine: 162
      summary: "\nUse this constructor when the class instance is a sibling (defined\nin the same assembly).\n"
      example: []
      syntax:
        content:
          CSharp: public PropertyDefaults()
          VB: Public Sub New
      overload: WizardWrx.Core.PropertyDefaults.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.PropertyDefaults.#ctor(System.Reflection.Assembly)
      commentId: M:WizardWrx.Core.PropertyDefaults.#ctor(System.Reflection.Assembly)
      language: CSharp
      name:
        CSharp: PropertyDefaults(Assembly)
        VB: PropertyDefaults(Assembly)
      nameWithType:
        CSharp: PropertyDefaults.PropertyDefaults(Assembly)
        VB: PropertyDefaults.PropertyDefaults(Assembly)
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.PropertyDefaults(System.Reflection.Assembly)
        VB: WizardWrx.Core.PropertyDefaults.PropertyDefaults(System.Reflection.Assembly)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/PropertyDefaults.cs
        startLine: 174
      summary: "\nUse this constructor when the class instance and base class are\ndefined in different assemblies.\n"
      example: []
      syntax:
        content:
          CSharp: public PropertyDefaults(Assembly pasmLinkedAssembly)
          VB: Public Sub New(pasmLinkedAssembly As Assembly)
        parameters:
        - id: pasmLinkedAssembly
          type: System.Reflection.Assembly
          description: ''
      overload: WizardWrx.Core.PropertyDefaults.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.PropertyDefaults.ValuesCollection
      commentId: P:WizardWrx.Core.PropertyDefaults.ValuesCollection
      language: CSharp
      name:
        CSharp: ValuesCollection
        VB: ValuesCollection
      nameWithType:
        CSharp: PropertyDefaults.ValuesCollection
        VB: PropertyDefaults.ValuesCollection
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.ValuesCollection
        VB: WizardWrx.Core.PropertyDefaults.ValuesCollection
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ValuesCollection
        path: ../Core/PropertyDefaults.cs
        startLine: 185
      summary: "\nReturn the KeyValueConfigurationCollection from the\nAppSettingsSection section of the DLL configuration file.\n"
      example: []
      syntax:
        content:
          CSharp: public KeyValueConfigurationCollection ValuesCollection { get; }
          VB: Public ReadOnly Property ValuesCollection As KeyValueConfigurationCollection
        parameters: []
        return:
          type: System.Configuration.KeyValueConfigurationCollection
      overload: WizardWrx.Core.PropertyDefaults.ValuesCollection*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
    - id: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate(System.DateTimeKind)
      commentId: M:WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate(System.DateTimeKind)
      language: CSharp
      name:
        CSharp: GetAssemblyBuildDate(DateTimeKind)
        VB: GetAssemblyBuildDate(DateTimeKind)
      nameWithType:
        CSharp: PropertyDefaults.GetAssemblyBuildDate(DateTimeKind)
        VB: PropertyDefaults.GetAssemblyBuildDate(DateTimeKind)
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate(System.DateTimeKind)
        VB: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate(System.DateTimeKind)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetAssemblyBuildDate
        path: ../Core/PropertyDefaults.cs
        startLine: 199
      summary: "\nGet the date on which the assembly was built.\n"
      example: []
      syntax:
        content:
          CSharp: public DateTime GetAssemblyBuildDate(DateTimeKind pdtmKind)
          VB: Public Function GetAssemblyBuildDate(pdtmKind As DateTimeKind) As Date
        parameters:
        - id: pdtmKind
          type: System.DateTimeKind
          description: "\nSpecify whether to return local or UTC time. Altough all three types\nare nominally supported, Unspecified is treated as Local.\n"
        return:
          type: System.DateTime
          description: "\nThe return value is the System.DateTime when the assembly was built.\n"
      overload: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString
      commentId: M:WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString
      language: CSharp
      name:
        CSharp: GetAssemblyVersionString()
        VB: GetAssemblyVersionString()
      nameWithType:
        CSharp: PropertyDefaults.GetAssemblyVersionString()
        VB: PropertyDefaults.GetAssemblyVersionString()
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString()
        VB: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetAssemblyVersionString
        path: ../Core/PropertyDefaults.cs
        startLine: 209
      summary: "\nGet a version string, suitable for display in reports.\n"
      example: []
      syntax:
        content:
          CSharp: public string GetAssemblyVersionString()
          VB: Public Function GetAssemblyVersionString As String
        return:
          type: System.String
          description: "\nThe fully qualified version (i. e., all four parts) is returned.\n"
      overload: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues
      commentId: M:WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues
      language: CSharp
      name:
        CSharp: EnumerateMissingConfigurationValues()
        VB: EnumerateMissingConfigurationValues()
      nameWithType:
        CSharp: PropertyDefaults.EnumerateMissingConfigurationValues()
        VB: PropertyDefaults.EnumerateMissingConfigurationValues()
      qualifiedName:
        CSharp: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues()
        VB: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/PropertyDefaults.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: EnumerateMissingConfigurationValues
        path: ../Core/PropertyDefaults.cs
        startLine: 234
      summary: "\nEnumeate missing configuration values, if any.\n"
      example: []
      syntax:
        content:
          CSharp: public string EnumerateMissingConfigurationValues()
          VB: Public Function EnumerateMissingConfigurationValues As String
        return:
          type: System.String
          description: "\nThis method returns a message suitable for display on a console or a\nWindows message box. The returned message summarises the state of\naffairs, even when all defined values are represented in the\nconfiguration file.\n"
      overload: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: WizardWrx.Core.RegistryValues
    commentId: T:WizardWrx.Core.RegistryValues
    language: CSharp
    name:
      CSharp: RegistryValues
      VB: RegistryValues
    nameWithType:
      CSharp: RegistryValues
      VB: RegistryValues
    qualifiedName:
      CSharp: WizardWrx.Core.RegistryValues
      VB: WizardWrx.Core.RegistryValues
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/RegistryValues.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: RegistryValues
      path: ../Core/RegistryValues.cs
      startLine: 98
    summary: "\nThis sealed class exposes static methods for efficiently testing for the\npresence of named values in a Registry key that behave more like the\nItem property of a collection, and retrieving Registry value types that\nrequire a transformation of one sort or another to get them into the\nappropriate native type.\n\nSince static classes are implicitly sealed, this class cannot be inherited.\n"
    example: []
    syntax:
      content:
        CSharp: public static class RegistryValues
        VB: Public Module RegistryValues
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Core.RegistryValues.REG_BINARY_NULL_FOR_ABSENT
      commentId: F:WizardWrx.Core.RegistryValues.REG_BINARY_NULL_FOR_ABSENT
      language: CSharp
      name:
        CSharp: REG_BINARY_NULL_FOR_ABSENT
        VB: REG_BINARY_NULL_FOR_ABSENT
      nameWithType:
        CSharp: RegistryValues.REG_BINARY_NULL_FOR_ABSENT
        VB: RegistryValues.REG_BINARY_NULL_FOR_ABSENT
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.REG_BINARY_NULL_FOR_ABSENT
        VB: WizardWrx.Core.RegistryValues.REG_BINARY_NULL_FOR_ABSENT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: REG_BINARY_NULL_FOR_ABSENT
        path: ../Core/RegistryValues.cs
        startLine: 105
      summary: "\nSpecify this constant as the value of RegQueryValue argument pfNullIsOK if\nyour routine expects a null reference when the requested value is absent\nor the wrong type.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool REG_BINARY_NULL_FOR_ABSENT = true
          VB: Public Const REG_BINARY_NULL_FOR_ABSENT As Boolean = True
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
      commentId: F:WizardWrx.Core.RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
      language: CSharp
      name:
        CSharp: REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
        VB: REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
      nameWithType:
        CSharp: RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
        VB: RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
        VB: WizardWrx.Core.RegistryValues.REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT
        path: ../Core/RegistryValues.cs
        startLine: 113
      summary: "\nSpecify this constant as the value of RegQueryValue argument pfNullIsOK if\nyour routine expects an array of some kind, even when the requested value\nis absent or the wrong type.\n"
      example: []
      syntax:
        content:
          CSharp: public const bool REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT = false
          VB: Public Const REG_BIANRY_EMPTY_ARRAY_FOR_ABSENT As Boolean = False
        return:
          type: System.Boolean
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Boolean)
      commentId: M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Boolean)
      language: CSharp
      name:
        CSharp: RegQueryValue(RegistryKey, String, Boolean)
        VB: RegQueryValue(RegistryKey, String, Boolean)
      nameWithType:
        CSharp: RegistryValues.RegQueryValue(RegistryKey, String, Boolean)
        VB: RegistryValues.RegQueryValue(RegistryKey, String, Boolean)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Boolean)
        VB: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Boolean)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RegQueryValue
        path: ../Core/RegistryValues.cs
        startLine: 149
      summary: "\nGet a REG_BINARY value from the Windows Registry.\n"
      example: []
      syntax:
        content:
          CSharp: public static byte[] RegQueryValue(RegistryKey phRegKey, string pstrValueName, bool pfNullIsOK)
          VB: Public Shared Function RegQueryValue(phRegKey As RegistryKey, pstrValueName As String, pfNullIsOK As Boolean) As Byte()
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nSpecify the handle of the Registry key where the value is expected\nto exist. This must be the key that holds the value, since neither\nRegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.\n"
        - id: pstrValueName
          type: System.String
          description: "\nSpecify the name, sans square brackets, which aren&apos;t needed, since\nthe string is the unqualified name of a value.\n"
        - id: pfNullIsOK
          type: System.Boolean
          description: "\nSpecify True if your code tests the return value for a null\nreference. Otherwise, specify False, and expect an uninitialized\none-element byte array.\n\nThis is a specific instance in which I believe that a null reference\nis the best solution to the problem of what to use as a default for\na missing REG_BINARY value.\n"
        return:
          type: System.Byte[]
          description: "\nIf the specified value exists and its type is REG_BINARY, the return\nvalue is a byte array containing the value read from the Registry.\nOtherwise, the return value is null (Nothing in Visual Basic).\n"
      overload: WizardWrx.Core.RegistryValues.RegQueryValue*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference (Nothing in Visual Basic), when this\nmethod calls companion method ValueExists to query the Registry for\nthe specified value, that method throws an ArgumentNullException\nexception, listing this method as its calling method in its stack\ntrace.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
    - id: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int32)
      commentId: M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int32)
      language: CSharp
      name:
        CSharp: RegQueryValue(RegistryKey, String, Int32)
        VB: RegQueryValue(RegistryKey, String, Int32)
      nameWithType:
        CSharp: RegistryValues.RegQueryValue(RegistryKey, String, Int32)
        VB: RegistryValues.RegQueryValue(RegistryKey, String, Int32)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Int32)
        VB: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Int32)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RegQueryValue
        path: ../Core/RegistryValues.cs
        startLine: 203
      summary: "\nGet a REG_DWORD value from the Windows Registry.\n"
      example: []
      syntax:
        content:
          CSharp: public static int RegQueryValue(RegistryKey phRegKey, string pstrValueName, int pintDefault)
          VB: Public Shared Function RegQueryValue(phRegKey As RegistryKey, pstrValueName As String, pintDefault As Integer) As Integer
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nSpecify the handle of the Registry key where the value is expected\nto exist. This must be the key that holds the value, since neither\nRegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.\n"
        - id: pstrValueName
          type: System.String
          description: "\nSpecify the name, sans square brackets, which aren&apos;t needed, since\nthe string is the unqualified name of a value.\n"
        - id: pintDefault
          type: System.Int32
          description: "\nAlthough a DWORD seems logically more like an unsigned integer, I am\nsomewhat surprised that the framework casts it to int, which carries\na sign. Nevertheless, since the return is cast to int, so is its\ndefault, which is returned if the specified value is absent, or if\nit exists, but has a different type (ValueKind) property.\n"
        return:
          type: System.Int32
          description: "\nIf the named value exists in the specified key and its type is \nREG_DWORD, it is returned, as a SIGNED integer. Otherwise, the value\nspecified in pintDefault is returned.\n"
      overload: WizardWrx.Core.RegistryValues.RegQueryValue*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference (Nothing in Visual Basic), when this\nmethod calls companion method ValueExists to query the Registry for\nthe specified value, that method throws an ArgumentNullException\nexception, listing this method as its calling method in its stack\ntrace.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
    - id: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int64)
      commentId: M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.Int64)
      language: CSharp
      name:
        CSharp: RegQueryValue(RegistryKey, String, Int64)
        VB: RegQueryValue(RegistryKey, String, Int64)
      nameWithType:
        CSharp: RegistryValues.RegQueryValue(RegistryKey, String, Int64)
        VB: RegistryValues.RegQueryValue(RegistryKey, String, Int64)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Int64)
        VB: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.Int64)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RegQueryValue
        path: ../Core/RegistryValues.cs
        startLine: 254
      summary: "\nGet a REG_QWORD value from the Windows Registry.\n"
      example: []
      syntax:
        content:
          CSharp: public static long RegQueryValue(RegistryKey phRegKey, string pstrValueName, long plngDefault)
          VB: Public Shared Function RegQueryValue(phRegKey As RegistryKey, pstrValueName As String, plngDefault As Long) As Long
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nSpecify the handle of the Registry key where the value is expected\nto exist. This must be the key that holds the value, since neither\nRegistryKey.GetValueKind, nor RegistryKey.GetValue supports paths.\n"
        - id: pstrValueName
          type: System.String
          description: "\nSpecify the name, sans square brackets, which aren&apos;t needed, since\nthe string is the unqualified name of a value.\n"
        - id: plngDefault
          type: System.Int64
          description: "\nAlthough a QWORD seems logically more like an unsigned long, I am\nsomewhat surprised that the framework casts it to long, which\ncarries a sign. Nevertheless, since the return is cast to long, so\nis its default, which is returned if the specified value is absent,\nor if it exists, but has a different type (ValueKind) property.\n"
        return:
          type: System.Int64
          description: "\nIf the named value exists in the specified key and its type is\nREG_QWORD, it is returned, as a SIGNED long integer. Otherwise, the\nvalue specified in plngDefault is returned.\n"
      overload: WizardWrx.Core.RegistryValues.RegQueryValue*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference (Nothing in Visual Basic), this\nmethod throws an ArgumentNullException exception.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
    - id: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.String)
      commentId: M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String,System.String)
      language: CSharp
      name:
        CSharp: RegQueryValue(RegistryKey, String, String)
        VB: RegQueryValue(RegistryKey, String, String)
      nameWithType:
        CSharp: RegistryValues.RegQueryValue(RegistryKey, String, String)
        VB: RegistryValues.RegQueryValue(RegistryKey, String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.String)
        VB: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RegQueryValue
        path: ../Core/RegistryValues.cs
        startLine: 310
      summary: "\nReturn the single string representation of a REG_SZ or \nREG_EXPAND_SZ Registry value.\n"
      example: []
      syntax:
        content:
          CSharp: public static string RegQueryValue(RegistryKey phRegKey, string pstrValueName, string pstrDefault)
          VB: Public Shared Function RegQueryValue(phRegKey As RegistryKey, pstrValueName As String, pstrDefault As String) As String
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nPass in a handle to the Registry sub-key that is supposed to contain\nthe required REG_SZ or REG_EXPAND_SZ value.\n"
        - id: pstrValueName
          type: System.String
          description: "\nPass in a string that contains the name of the value to be queried\nand returned if present. See notes in the Return Value comment.\n"
        - id: pstrDefault
          type: System.String
          description: "\nSpecify the string to return if the value is missing or of the wrong type.\n"
        return:
          type: System.String
          description: "\nIf the function succeeds, the return value is a string containing\nthe value. If the value type is REG_EXPAND_SZ, environment variables\nare expanded.\n\nIf the value specified by pstrValueName is missing entirely, the\nreturn value is pstrDefault.\n\nIf the requested string is something other than REG_SZ or \nREG_EXPAND_SZ, the return value is pstrDefault.\n"
      overload: WizardWrx.Core.RegistryValues.RegQueryValue*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference (Nothing in Visual Basic), when this\nmethod calls companion method ValueExists to query the Registry for\nthe specified value, that method throws an ArgumentNullException\nexception, listing this method as its calling method in its stack\ntrace.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
    - id: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String)
      commentId: M:WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey,System.String)
      language: CSharp
      name:
        CSharp: RegQueryValue(RegistryKey, String)
        VB: RegQueryValue(RegistryKey, String)
      nameWithType:
        CSharp: RegistryValues.RegQueryValue(RegistryKey, String)
        VB: RegistryValues.RegQueryValue(RegistryKey, String)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String)
        VB: WizardWrx.Core.RegistryValues.RegQueryValue(Microsoft.Win32.RegistryKey, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: RegQueryValue
        path: ../Core/RegistryValues.cs
        startLine: 365
      summary: "\nReturn the multiple values stored in a REG_MULTI_SZ Registry value.\n"
      example: []
      syntax:
        content:
          CSharp: public static string[] RegQueryValue(RegistryKey phRegKey, string pstrValueName)
          VB: Public Shared Function RegQueryValue(phRegKey As RegistryKey, pstrValueName As String) As String()
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nPass in a handle to the Registry sub-key that is supposed to contain\nthe required REG_MULTI_SZ value.\n"
        - id: pstrValueName
          type: System.String
          description: "\nPass in a string that contains the name of the value to be queried\nand returned if present. See notes in the Return Value comment.\n"
        return:
          type: System.String[]
          description: "\nIf the function succeeds, the return value is an array of strings\nthat contains one string for each substring in the REG_MULTI_SZ\nvalue.\n\nIf the value specified by pstrValueName is missing entirely, an\nempty array is returned.\n\nIf the requested string is something other than REG_MULTI_SZ, this\nmethod treats the call as a degenerate case, returning an array of\none element if the value is either REG_SZ or REG_EXPAND_SZ.\n\nALL other types return empty arrays.\n"
      overload: WizardWrx.Core.RegistryValues.RegQueryValue*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference (Nothing in Visual Basic), when this\nmethod calls companion method ValueExists to query the Registry for\nthe specified value, that method throws an ArgumentNullException\nexception, listing this method as its calling method in its stack\ntrace.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
    - id: WizardWrx.Core.RegistryValues.ValueExists(Microsoft.Win32.RegistryKey,System.String)
      commentId: M:WizardWrx.Core.RegistryValues.ValueExists(Microsoft.Win32.RegistryKey,System.String)
      language: CSharp
      name:
        CSharp: ValueExists(RegistryKey, String)
        VB: ValueExists(RegistryKey, String)
      nameWithType:
        CSharp: RegistryValues.ValueExists(RegistryKey, String)
        VB: RegistryValues.ValueExists(RegistryKey, String)
      qualifiedName:
        CSharp: WizardWrx.Core.RegistryValues.ValueExists(Microsoft.Win32.RegistryKey, System.String)
        VB: WizardWrx.Core.RegistryValues.ValueExists(Microsoft.Win32.RegistryKey, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/RegistryValues.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ValueExists
        path: ../Core/RegistryValues.cs
        startLine: 415
      summary: "\nReturn TRUE if a specified value exists on a specified key of the\nWindows Registry.\n"
      remarks: "\nThis was written as a service routine for companion methods\nGetRegDwordValue and GetRegMultiStringValue. However, since it is\nalmost certain to find use on its own, I marked it public.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool ValueExists(RegistryKey phRegKey, string pstrValueName)
          VB: Public Shared Function ValueExists(phRegKey As RegistryKey, pstrValueName As String) As Boolean
        parameters:
        - id: phRegKey
          type: Microsoft.Win32.RegistryKey
          description: "\nPass in a handle to the Registry sub-key that is supposed to contain\nthe desired value.\n"
        - id: pstrValueName
          type: System.String
          description: "\nPass in a string that contains the name of the value to be queried\nand returned if present. See notes in the Return Value comment.\n"
        return:
          type: System.Boolean
          description: "\nThe function returns true if the key contains a value with the \nspecified name, or if pstrValueName is the empty string or a null\nreference, either of which stands for the default value, which is\nalways present, though seldom set. Otherwise, the return value is\nfalse.\n"
      overload: WizardWrx.Core.RegistryValues.ValueExists*
      exceptions:
      - type: System.ArgumentNullException
        commentId: T:System.ArgumentNullException
        description: "\nIf phRegKey is a null reference, an ArgumentNullException exception\nis thrown.\n"
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
      references:
        System.ArgumentNullException: 
  - id: WizardWrx.Core.StringFixups
    commentId: T:WizardWrx.Core.StringFixups
    language: CSharp
    name:
      CSharp: StringFixups
      VB: StringFixups
    nameWithType:
      CSharp: StringFixups
      VB: StringFixups
    qualifiedName:
      CSharp: WizardWrx.Core.StringFixups
      VB: WizardWrx.Core.StringFixups
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/StringFixups.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: StringFixups
      path: ../Core/StringFixups.cs
      startLine: 83
    summary: "\nInstances of this class represent pairs of fixup strings to apply as\nreplacement pairs to amend a string, such as the JSON response from a\nREST endpoint that motivated its creation.\n"
    example: []
    syntax:
      content:
        CSharp: public class StringFixups
        VB: Public Class StringFixups
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.StringFixups.#ctor(WizardWrx.Core.StringFixups.StringFixup[])
      commentId: M:WizardWrx.Core.StringFixups.#ctor(WizardWrx.Core.StringFixups.StringFixup[])
      language: CSharp
      name:
        CSharp: StringFixups(StringFixups.StringFixup[])
        VB: StringFixups(StringFixups.StringFixup())
      nameWithType:
        CSharp: StringFixups.StringFixups(StringFixups.StringFixup[])
        VB: StringFixups.StringFixups(StringFixups.StringFixup())
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.StringFixups(WizardWrx.Core.StringFixups.StringFixup[])
        VB: WizardWrx.Core.StringFixups.StringFixups(WizardWrx.Core.StringFixups.StringFixup())
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/StringFixups.cs
        startLine: 156
      summary: "\nThe public constructor is overloaded, to guarantee that instances\nare properly initialized.\n"
      example: []
      syntax:
        content:
          CSharp: public StringFixups(StringFixups.StringFixup[] pafixupPair)
          VB: Public Sub New(pafixupPair As StringFixups.StringFixup())
        parameters:
        - id: pafixupPair
          type: WizardWrx.Core.StringFixups.StringFixup[]
          description: "\nThe array of StringFixup string pairs to apply to string fed into\nthe ApplyFixups method\n"
      overload: WizardWrx.Core.StringFixups.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.StringFixups.ApplyFixups(System.String)
      commentId: M:WizardWrx.Core.StringFixups.ApplyFixups(System.String)
      language: CSharp
      name:
        CSharp: ApplyFixups(String)
        VB: ApplyFixups(String)
      nameWithType:
        CSharp: StringFixups.ApplyFixups(String)
        VB: StringFixups.ApplyFixups(String)
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.ApplyFixups(System.String)
        VB: WizardWrx.Core.StringFixups.ApplyFixups(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ApplyFixups
        path: ../Core/StringFixups.cs
        startLine: 174
      summary: "\nCall this method to apply the StringFixup array that was passed into\nthe constructor.\n"
      example: []
      syntax:
        content:
          CSharp: public string ApplyFixups(string pstrInputString)
          VB: Public Function ApplyFixups(pstrInputString As String) As String
        parameters:
        - id: pstrInputString
          type: System.String
          description: "\nString to transform by applying the StringFixup array that was passed into\nthe constructor\n"
        return:
          type: System.String
          description: "\nThe <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrInputString</code>, transformed by applying each\nStringFixup to it in turn\n"
      overload: WizardWrx.Core.StringFixups.ApplyFixups*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
  - id: WizardWrx.Core.StringFixups.StringFixup
    commentId: T:WizardWrx.Core.StringFixups.StringFixup
    language: CSharp
    name:
      CSharp: StringFixups.StringFixup
      VB: StringFixups.StringFixup
    nameWithType:
      CSharp: StringFixups.StringFixup
      VB: StringFixups.StringFixup
    qualifiedName:
      CSharp: WizardWrx.Core.StringFixups.StringFixup
      VB: WizardWrx.Core.StringFixups.StringFixup
    type: Struct
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/StringFixups.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: StringFixup
      path: ../Core/StringFixups.cs
      startLine: 88
    summary: "\nA fixup pair is a pair of strings.\n"
    example: []
    syntax:
      content:
        CSharp: public struct StringFixup
        VB: Public Structure StringFixup
    inheritedMembers:
    - System.ValueType.Equals(System.Object)
    - System.ValueType.GetHashCode
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    modifiers:
      CSharp:
      - public
      - struct
      VB:
      - Public
      - Structure
    items:
    - id: WizardWrx.Core.StringFixups.StringFixup.InputValue
      commentId: F:WizardWrx.Core.StringFixups.StringFixup.InputValue
      language: CSharp
      name:
        CSharp: InputValue
        VB: InputValue
      nameWithType:
        CSharp: StringFixups.StringFixup.InputValue
        VB: StringFixups.StringFixup.InputValue
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.StringFixup.InputValue
        VB: WizardWrx.Core.StringFixups.StringFixup.InputValue
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: InputValue
        path: ../Core/StringFixups.cs
        startLine: 94
      summary: "\nSpecify the string to be replaced with OutputValue when found in\nan input string.\n"
      example: []
      syntax:
        content:
          CSharp: public string InputValue
          VB: Public InputValue As String
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.StringFixups.StringFixup.OutputValue
      commentId: F:WizardWrx.Core.StringFixups.StringFixup.OutputValue
      language: CSharp
      name:
        CSharp: OutputValue
        VB: OutputValue
      nameWithType:
        CSharp: StringFixups.StringFixup.OutputValue
        VB: StringFixups.StringFixup.OutputValue
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.StringFixup.OutputValue
        VB: WizardWrx.Core.StringFixups.StringFixup.OutputValue
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: OutputValue
        path: ../Core/StringFixups.cs
        startLine: 100
      summary: "\nSpecify the string to substitute for InputValue when found in an\ninput string.\n"
      example: []
      syntax:
        content:
          CSharp: public string OutputValue
          VB: Public OutputValue As String
        return:
          type: System.String
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.StringFixups.StringFixup.#ctor(System.String,System.String)
      commentId: M:WizardWrx.Core.StringFixups.StringFixup.#ctor(System.String,System.String)
      language: CSharp
      name:
        CSharp: StringFixup(String, String)
        VB: StringFixup(String, String)
      nameWithType:
        CSharp: StringFixups.StringFixup.StringFixup(String, String)
        VB: StringFixups.StringFixup.StringFixup(String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.StringFixup.StringFixup(System.String, System.String)
        VB: WizardWrx.Core.StringFixups.StringFixup.StringFixup(System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/StringFixups.cs
        startLine: 113
      summary: "\nThis constructor permits initializing static read-only arrays of\nthese structures.\n"
      example: []
      syntax:
        content:
          CSharp: public StringFixup(string pstrInputValue, string pstroutputValue)
          VB: Public Sub New(pstrInputValue As String, pstroutputValue As String)
        parameters:
        - id: pstrInputValue
          type: System.String
          description: "\nString to assign to the InputValue property\n"
        - id: pstroutputValue
          type: System.String
          description: "\nString to assign to the OutpuValue property\n"
      overload: WizardWrx.Core.StringFixups.StringFixup.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.StringFixups.StringFixup.ToString
      commentId: M:WizardWrx.Core.StringFixups.StringFixup.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: StringFixups.StringFixup.ToString()
        VB: StringFixups.StringFixup.ToString()
      qualifiedName:
        CSharp: WizardWrx.Core.StringFixups.StringFixup.ToString()
        VB: WizardWrx.Core.StringFixups.StringFixup.ToString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/StringFixups.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ToString
        path: ../Core/StringFixups.cs
        startLine: 129
      summary: "\nOverride the ToString method on the base class to render the two\nstructure members&apos; values when the framework invokes the default\nToString method, such as when it populates a watch window.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe return value is a formatted string that displays the name\nand value of each of the two members of the structure.\n"
      overload: WizardWrx.Core.StringFixups.StringFixup.ToString*
      overridden: System.ValueType.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
  - id: WizardWrx.Core.TimeDisplayFormatter
    commentId: T:WizardWrx.Core.TimeDisplayFormatter
    language: CSharp
    name:
      CSharp: TimeDisplayFormatter
      VB: TimeDisplayFormatter
    nameWithType:
      CSharp: TimeDisplayFormatter
      VB: TimeDisplayFormatter
    qualifiedName:
      CSharp: WizardWrx.Core.TimeDisplayFormatter
      VB: WizardWrx.Core.TimeDisplayFormatter
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/TimeDisplayFormatter.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TimeDisplayFormatter
      path: ../Core/TimeDisplayFormatter.cs
      startLine: 137
    summary: "\nUse instances of this class to return dates and times, uniformly\nformatted by rules set by way of its properties.\n\nThis class is sealed, and cannot be inherited.\n"
    example: []
    syntax:
      content:
        CSharp: public sealed class TimeDisplayFormatter
        VB: Public NotInheritable Class TimeDisplayFormatter
    seealso:
    - linkId: WizardWrx.DisplayFormats
      commentId: T:WizardWrx.DisplayFormats
    - linkId: WizardWrx.SysDateFormatters
      commentId: T:WizardWrx.SysDateFormatters
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
      language: CSharp
      name:
        CSharp: CalendarDateFormat
        VB: CalendarDateFormat
      nameWithType:
        CSharp: TimeDisplayFormatter.CalendarDateFormat
        VB: TimeDisplayFormatter.CalendarDateFormat
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
        VB: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CalendarDateFormat
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 420
      summary: "\nSet this property to override the default formatting of calendar\ndates, which is governed by the active CultureInfo settings, which\nare, themselves, governed by the active Regional Settings of the\noperating system.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeDisplayFormatter.DateFieldOrder CalendarDateFormat { get; set; }
          VB: Public Property CalendarDateFormat As TimeDisplayFormatter.DateFieldOrder
        parameters: []
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      overload: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormat
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.HoursFormat
      language: CSharp
      name:
        CSharp: HoursFormat
        VB: HoursFormat
      nameWithType:
        CSharp: TimeDisplayFormatter.HoursFormat
        VB: TimeDisplayFormatter.HoursFormat
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.HoursFormat
        VB: WizardWrx.Core.TimeDisplayFormatter.HoursFormat
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HoursFormat
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 465
      summary: "\nSet the display format for hours. See the HoursFormatType enumeration\nfor more details.\n\nWhen the value is DateFieldOrder.CultureInfoShortDate, the\nHoursFormat and TimePrecision properties are ignored.\n\nThe default format is Military, and the value must be a member of\nthe HoursFormatType enumeration. If an invalid value is specified, a\nSystem.ArgumentOutOfRangeException exception is thrown, and the\nproperty value is unchanged.\n\nWhen the value of this property is CultureInfoShortTime, the\nTimePrecision property is ignored.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeDisplayFormatter.HoursFormatType HoursFormat { get; set; }
          VB: Public Property HoursFormat As TimeDisplayFormatter.HoursFormatType
        parameters: []
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      overload: WizardWrx.Core.TimeDisplayFormatter.HoursFormat*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
      language: CSharp
      name:
        CSharp: MachineTimeZone
        VB: MachineTimeZone
      nameWithType:
        CSharp: TimeDisplayFormatter.MachineTimeZone
        VB: TimeDisplayFormatter.MachineTimeZone
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
        VB: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MachineTimeZone
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 500
      summary: "\nThis static property provides convenience access to the\nCurrentTimeZone property maintained in a static TimeZone instance\nfor its own use.\n"
      example: []
      syntax:
        content:
          CSharp: public static TimeZone MachineTimeZone { get; }
          VB: Public Shared ReadOnly Property MachineTimeZone As TimeZone
        parameters: []
        return:
          type: System.TimeZone
      overload: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone*
      modifiers:
        CSharp:
        - public
        - static
        - get
        VB:
        - Public
        - Shared
        - ReadOnly
    - id: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
      language: CSharp
      name:
        CSharp: ShowAmPmAsUC
        VB: ShowAmPmAsUC
      nameWithType:
        CSharp: TimeDisplayFormatter.ShowAmPmAsUC
        VB: TimeDisplayFormatter.ShowAmPmAsUC
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
        VB: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ShowAmPmAsUC
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 510
      summary: "\nSet this property to TRUE to have the AM and PM tokens displayed in\nupper case.\n\nUnless the HoursFormat property is HoursFormatType.Civilian, this\nproperty is ignored.\n"
      example: []
      syntax:
        content:
          CSharp: public bool ShowAmPmAsUC { get; set; }
          VB: Public Property ShowAmPmAsUC As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
      language: CSharp
      name:
        CSharp: ShowTimeZone
        VB: ShowTimeZone
      nameWithType:
        CSharp: TimeDisplayFormatter.ShowTimeZone
        VB: TimeDisplayFormatter.ShowTimeZone
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
        VB: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ShowTimeZone
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 524
      summary: "\nSet this property to TRUE to have the local time zone displayed with\nthe time. By default, the time zone is omitted.\n\nThis property is applied independently of the HoursFormatType and\nPrecision properties.\n"
      example: []
      syntax:
        content:
          CSharp: public bool ShowTimeZone { get; set; }
          VB: Public Property ShowTimeZone As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
      language: CSharp
      name:
        CSharp: ShowWeekday
        VB: ShowWeekday
      nameWithType:
        CSharp: TimeDisplayFormatter.ShowWeekday
        VB: TimeDisplayFormatter.ShowWeekday
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
        VB: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ShowWeekday
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 538
      summary: "\nSet this property to TRUE to have the local weekday name displayed\nwith the time. By default, the weekday name is omitted.\n\nThis property is applied independently of the HoursFormatType and\nPrecision properties.\n"
      example: []
      syntax:
        content:
          CSharp: public bool ShowWeekday { get; set; }
          VB: Public Property ShowWeekday As Boolean
        parameters: []
        return:
          type: System.Boolean
      overload: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecision
      commentId: P:WizardWrx.Core.TimeDisplayFormatter.TimePrecision
      language: CSharp
      name:
        CSharp: TimePrecision
        VB: TimePrecision
      nameWithType:
        CSharp: TimeDisplayFormatter.TimePrecision
        VB: TimeDisplayFormatter.TimePrecision
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecision
        VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecision
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: TimePrecision
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 554
      summary: "\nThis property governs the precision used for time displays. The\nclass default is HMST.\n\nWhen the value of the HoursFormat property is CultureInfoShortTime,\nthe value of this property is ignored.\n\nFor additional information, see the TimePrecisionType enumeration.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeDisplayFormatter.TimePrecisionType TimePrecision { get; set; }
          VB: Public Property TimePrecision As TimeDisplayFormatter.TimePrecisionType
        parameters: []
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      overload: WizardWrx.Core.TimeDisplayFormatter.TimePrecision*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.#ctor
      commentId: M:WizardWrx.Core.TimeDisplayFormatter.#ctor
      language: CSharp
      name:
        CSharp: TimeDisplayFormatter()
        VB: TimeDisplayFormatter()
      nameWithType:
        CSharp: TimeDisplayFormatter.TimeDisplayFormatter()
        VB: TimeDisplayFormatter.TimeDisplayFormatter()
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimeDisplayFormatter()
        VB: WizardWrx.Core.TimeDisplayFormatter.TimeDisplayFormatter()
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 598
      summary: "\nThe default constructor initializes an instance that follows the\ndefault preferences built into the class. Hence, methods called on\nobjects created by it are guaranteed to yield a usable string unless\nthe DateTime value supplied to the method is, itself, invalid.\n"
      remarks: "\nRather than attempt to create the numerous constructors that would\nbe required to cover every possible combination of properties, there\nis just one constructor. All properties are read-write. Use them to\nchange the operating parameters.\n\nIf you always use the same combination of settings, you can wrap\nyour own class around an instance of this one.\n"
      example: []
      syntax:
        content:
          CSharp: public TimeDisplayFormatter()
          VB: Public Sub New
      overload: WizardWrx.Core.TimeDisplayFormatter.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime(System.DateTime)
      commentId: M:WizardWrx.Core.TimeDisplayFormatter.FormatThisTime(System.DateTime)
      language: CSharp
      name:
        CSharp: FormatThisTime(DateTime)
        VB: FormatThisTime(DateTime)
      nameWithType:
        CSharp: TimeDisplayFormatter.FormatThisTime(DateTime)
        VB: TimeDisplayFormatter.FormatThisTime(DateTime)
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime(System.DateTime)
        VB: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime(System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatThisTime
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 613
      summary: "\nFormat the specified time.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatThisTime(DateTime pdtmThisTime)
          VB: Public Function FormatThisTime(pdtmThisTime As Date) As String
        parameters:
        - id: pdtmThisTime
          type: System.DateTime
          description: "\nThe DateTime instance to format.\n"
        return:
          type: System.String
          description: "\nThe input time, formatted as dictated by the current settings of the\nproperties of the class instance.\n"
      overload: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime
      commentId: M:WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime
      language: CSharp
      name:
        CSharp: FormatCurrentTime()
        VB: FormatCurrentTime()
      nameWithType:
        CSharp: TimeDisplayFormatter.FormatCurrentTime()
        VB: TimeDisplayFormatter.FormatCurrentTime()
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime()
        VB: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: FormatCurrentTime
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 633
      summary: "\nFormat the current time.\n"
      example: []
      syntax:
        content:
          CSharp: public string FormatCurrentTime()
          VB: Public Function FormatCurrentTime As String
        return:
          type: System.String
          description: "\nThe current time, formatted as dictated by the current settings of\nthe properties of the class instance.\n"
      overload: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime(System.DateTime)
      commentId: M:WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime(System.DateTime)
      language: CSharp
      name:
        CSharp: GetTimeZoneForTime(DateTime)
        VB: GetTimeZoneForTime(DateTime)
      nameWithType:
        CSharp: TimeDisplayFormatter.GetTimeZoneForTime(DateTime)
        VB: TimeDisplayFormatter.GetTimeZoneForTime(DateTime)
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime(System.DateTime)
        VB: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime(System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetTimeZoneForTime
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 658
      summary: "\nReturn the time zone name that corresponds to a local time.\n"
      example: []
      syntax:
        content:
          CSharp: public static string GetTimeZoneForTime(DateTime pdtmTheTime)
          VB: Public Shared Function GetTimeZoneForTime(pdtmTheTime As Date) As String
        parameters:
        - id: pdtmTheTime
          type: System.DateTime
          description: "\nSpecify the System.DateTime for which the correct time zone string\nis required.\n"
        return:
          type: System.String
          description: "\nIf the DateTimeKind of argument pdtmTheTime is Local, the return\nvalue is a string representation of the spelled out time zone name.\nOtherwise, an ArgumentException is thrown.\n"
      overload: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes(System.DateTime,System.DateTime)
      commentId: M:WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes(System.DateTime,System.DateTime)
      language: CSharp
      name:
        CSharp: PrepareLocalAndUTCTimes(DateTime, DateTime)
        VB: PrepareLocalAndUTCTimes(DateTime, DateTime)
      nameWithType:
        CSharp: TimeDisplayFormatter.PrepareLocalAndUTCTimes(DateTime, DateTime)
        VB: TimeDisplayFormatter.PrepareLocalAndUTCTimes(DateTime, DateTime)
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes(System.DateTime, System.DateTime)
        VB: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes(System.DateTime, System.DateTime)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PrepareLocalAndUTCTimes
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 698
      summary: "\nGiven a pair of DateTime structures, return them in a standardized\nformat.\n"
      example:
      - "\n2017/03/27 18:18:58 (2017/03/27 23:18:58 UTC)\n"
      syntax:
        content:
          CSharp: public static string PrepareLocalAndUTCTimes(DateTime dtmTimeLocal, DateTime dtmTimeUtc)
          VB: Public Shared Function PrepareLocalAndUTCTimes(dtmTimeLocal As Date, dtmTimeUtc As Date) As String
        parameters:
        - id: dtmTimeLocal
          type: System.DateTime
          description: "\nSpecify the local time to include in the standardized message.\n"
        - id: dtmTimeUtc
          type: System.DateTime
          description: "\nSpecify the UTC time to include in the standardized message.\n"
        return:
          type: System.String
          description: "\nThe returned string is of the format {0} ({1} UTC), where {0} is\nreplaced with the local time, while {1} is replaced with the\ncorresponding UTC time.\n"
      overload: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    references:
      WizardWrx.DisplayFormats: 
      WizardWrx.SysDateFormatters: 
  - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
    language: CSharp
    name:
      CSharp: TimeDisplayFormatter.DateFieldOrder
      VB: TimeDisplayFormatter.DateFieldOrder
    nameWithType:
      CSharp: TimeDisplayFormatter.DateFieldOrder
      VB: TimeDisplayFormatter.DateFieldOrder
    qualifiedName:
      CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/TimeDisplayFormatter.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: DateFieldOrder
      path: ../Core/TimeDisplayFormatter.cs
      startLine: 143
    summary: "\nIndicate the format to use for displaying the calendar date.\n"
    example: []
    syntax:
      content:
        CSharp: public enum DateFieldOrder
        VB: Public Enum DateFieldOrder
    extensionMethods:
    - WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
      language: CSharp
      name:
        CSharp: CultureInfoShortDate
        VB: CultureInfoShortDate
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
        VB: TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.CultureInfoShortDate
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CultureInfoShortDate
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 148
      summary: "\nUse the ShortDate format defined in the current CultureInfo.\n"
      example: []
      syntax:
        content:
          CSharp: CultureInfoShortDate = 0
          VB: CultureInfoShortDate = 0
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
      language: CSharp
      name:
        CSharp: MMDDYYYY
        VB: MMDDYYYY
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
        VB: TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MMDDYYYY
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 153
      summary: "\nDisplay Month, Day, and Year, showing all four digits of the year.\n"
      example: []
      syntax:
        content:
          CSharp: MMDDYYYY = 1
          VB: MMDDYYYY = 1
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
      language: CSharp
      name:
        CSharp: YYYYMMDD
        VB: YYYYMMDD
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
        VB: TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYYYMMDD
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: YYYYMMDD
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 158
      summary: "\nDisplay Year, Month, and Day, showing all four digits of the year.\n"
      example: []
      syntax:
        content:
          CSharp: YYYYMMDD = 2
          VB: YYYYMMDD = 2
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
      language: CSharp
      name:
        CSharp: DDMMYYYY
        VB: DDMMYYYY
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
        VB: TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYYYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DDMMYYYY
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 163
      summary: "\nDisplay Day, Month, and Year, showing all four digits of the year.\n"
      example: []
      syntax:
        content:
          CSharp: DDMMYYYY = 3
          VB: DDMMYYYY = 3
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYY
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYY
      language: CSharp
      name:
        CSharp: MMDDYY
        VB: MMDDYY
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.MMDDYY
        VB: TimeDisplayFormatter.DateFieldOrder.MMDDYY
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYY
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.MMDDYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MMDDYY
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 168
      summary: "\nDisplay Month, Day, and Year, discarding the century from the year.\n"
      example: []
      syntax:
        content:
          CSharp: MMDDYY = 4
          VB: MMDDYY = 4
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYMMDD
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYMMDD
      language: CSharp
      name:
        CSharp: YYMMDD
        VB: YYMMDD
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.YYMMDD
        VB: TimeDisplayFormatter.DateFieldOrder.YYMMDD
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYMMDD
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.YYMMDD
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: YYMMDD
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 173
      summary: "\nDisplay Year, Month, and Day, discarding the century from the year.\n"
      example: []
      syntax:
        content:
          CSharp: YYMMDD = 5
          VB: YYMMDD = 5
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYY
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYY
      language: CSharp
      name:
        CSharp: DDMMYY
        VB: DDMMYY
      nameWithType:
        CSharp: TimeDisplayFormatter.DateFieldOrder.DDMMYY
        VB: TimeDisplayFormatter.DateFieldOrder.DDMMYY
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYY
        VB: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.DDMMYY
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: DDMMYY
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 178
      summary: "\nDisplay Day, Month, and Year, discarding the century from the year.\n"
      example: []
      syntax:
        content:
          CSharp: DDMMYY = 6
          VB: DDMMYY = 6
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
    language: CSharp
    name:
      CSharp: TimeDisplayFormatter.HoursFormatType
      VB: TimeDisplayFormatter.HoursFormatType
    nameWithType:
      CSharp: TimeDisplayFormatter.HoursFormatType
      VB: TimeDisplayFormatter.HoursFormatType
    qualifiedName:
      CSharp: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      VB: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/TimeDisplayFormatter.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: HoursFormatType
      path: ../Core/TimeDisplayFormatter.cs
      startLine: 186
    summary: "\nIndicate time format to use (CultureInfoShortTime, Civilian, or\nMilitary).\n"
    example: []
    syntax:
      content:
        CSharp: public enum HoursFormatType
        VB: Public Enum HoursFormatType
    extensionMethods:
    - WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
      language: CSharp
      name:
        CSharp: CultureInfoShortTime
        VB: CultureInfoShortTime
      nameWithType:
        CSharp: TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
        VB: TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
        VB: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.CultureInfoShortTime
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: CultureInfoShortTime
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 191
      summary: "\nUse the ShortTime format defined in the current CultureInfo.\n"
      example: []
      syntax:
        content:
          CSharp: CultureInfoShortTime = 0
          VB: CultureInfoShortTime = 0
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Civilian
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Civilian
      language: CSharp
      name:
        CSharp: Civilian
        VB: Civilian
      nameWithType:
        CSharp: TimeDisplayFormatter.HoursFormatType.Civilian
        VB: TimeDisplayFormatter.HoursFormatType.Civilian
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Civilian
        VB: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Civilian
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Civilian
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 196
      summary: "\nUse civilian (12 hour) display format.\n"
      example: []
      syntax:
        content:
          CSharp: Civilian = 1
          VB: Civilian = 1
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Military
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Military
      language: CSharp
      name:
        CSharp: Military
        VB: Military
      nameWithType:
        CSharp: TimeDisplayFormatter.HoursFormatType.Military
        VB: TimeDisplayFormatter.HoursFormatType.Military
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Military
        VB: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.Military
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Military
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 201
      summary: "\nUse Military (24 hour) display format.\n"
      example: []
      syntax:
        content:
          CSharp: Military = 2
          VB: Military = 2
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
    language: CSharp
    name:
      CSharp: TimeDisplayFormatter.TimePrecisionType
      VB: TimeDisplayFormatter.TimePrecisionType
    nameWithType:
      CSharp: TimeDisplayFormatter.TimePrecisionType
      VB: TimeDisplayFormatter.TimePrecisionType
    qualifiedName:
      CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
    type: Enum
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/TimeDisplayFormatter.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TimePrecisionType
      path: ../Core/TimeDisplayFormatter.cs
      startLine: 209
    summary: "\nIndicate the precision to use for the time display. The class\ndefault is HMST.\n"
    example: []
    syntax:
      content:
        CSharp: public enum TimePrecisionType
        VB: Public Enum TimePrecisionType
    extensionMethods:
    - WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
    modifiers:
      CSharp:
      - public
      - enum
      VB:
      - Public
      - Enum
    items:
    - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HM
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HM
      language: CSharp
      name:
        CSharp: HM
        VB: HM
      nameWithType:
        CSharp: TimeDisplayFormatter.TimePrecisionType.HM
        VB: TimeDisplayFormatter.TimePrecisionType.HM
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HM
        VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HM
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HM
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 214
      summary: "\nDisplay only hours and minutes (HH:MM).\n"
      example: []
      syntax:
        content:
          CSharp: HM = 0
          VB: HM = 0
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMS
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMS
      language: CSharp
      name:
        CSharp: HMS
        VB: HMS
      nameWithType:
        CSharp: TimeDisplayFormatter.TimePrecisionType.HMS
        VB: TimeDisplayFormatter.TimePrecisionType.HMS
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMS
        VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMS
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HMS
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 219
      summary: "\nDisplay hours, minutes, and seconds (HH:MM:SS).\n"
      example: []
      syntax:
        content:
          CSharp: HMS = 1
          VB: HMS = 1
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMST
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMST
      language: CSharp
      name:
        CSharp: HMST
        VB: HMST
      nameWithType:
        CSharp: TimeDisplayFormatter.TimePrecisionType.HMST
        VB: TimeDisplayFormatter.TimePrecisionType.HMST
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMST
        VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMST
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HMST
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 224
      summary: "\nDisplay hours, minutes, seconds, and milliseconds.\n"
      example: []
      syntax:
        content:
          CSharp: HMST = 2
          VB: HMST = 2
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
    - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMSTN
      commentId: F:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMSTN
      language: CSharp
      name:
        CSharp: HMSTN
        VB: HMSTN
      nameWithType:
        CSharp: TimeDisplayFormatter.TimePrecisionType.HMSTN
        VB: TimeDisplayFormatter.TimePrecisionType.HMSTN
      qualifiedName:
        CSharp: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMSTN
        VB: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.HMSTN
      type: Field
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TimeDisplayFormatter.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: HMSTN
        path: ../Core/TimeDisplayFormatter.cs
        startLine: 229
      summary: "\nDisplay hours, minutes, seconds, milliseconds, and ticks.\n"
      example: []
      syntax:
        content:
          CSharp: HMSTN = 3
          VB: HMSTN = 3
        return:
          type: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      modifiers:
        CSharp:
        - public
        - const
        VB:
        - Public
        - Const
  - id: WizardWrx.Core.TraceLogger
    commentId: T:WizardWrx.Core.TraceLogger
    language: CSharp
    name:
      CSharp: TraceLogger
      VB: TraceLogger
    nameWithType:
      CSharp: TraceLogger
      VB: TraceLogger
    qualifiedName:
      CSharp: WizardWrx.Core.TraceLogger
      VB: WizardWrx.Core.TraceLogger
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/TraceLogger.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: TraceLogger
      path: ../Core/TraceLogger.cs
      startLine: 107
    summary: "\nThis static class exposes methods that support every conceivable\ncombination of local and UTC time stamps for trace logging.\n"
    remarks: "\nThe methods that record both local and UTC time capture the current UTC\ntime, then convert it into local time. This guarantees that both times\nare truly equal, and that local and UTC times are unambiguous.\n"
    example: []
    syntax:
      content:
        CSharp: public static class TraceLogger
        VB: Public Module TraceLogger
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Core.TraceLogger.ForceAutoFlush(System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.ForceAutoFlush(System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: ForceAutoFlush(StreamWriter)
        VB: ForceAutoFlush(StreamWriter)
      nameWithType:
        CSharp: TraceLogger.ForceAutoFlush(StreamWriter)
        VB: TraceLogger.ForceAutoFlush(StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.ForceAutoFlush(System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.ForceAutoFlush(System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ForceAutoFlush
        path: ../Core/TraceLogger.cs
        startLine: 130
      summary: "\nForce a System.IO.StreamWriter into AutoFlush mode.\n"
      example: []
      syntax:
        content:
          CSharp: public static bool ForceAutoFlush(StreamWriter psw)
          VB: Public Shared Function ForceAutoFlush(psw As StreamWriter) As Boolean
        parameters:
        - id: psw
          type: System.IO.StreamWriter
          description: "\nSpecify the System.IO.StreamWriter to make AutoFlush.\n"
        return:
          type: System.Boolean
          description: "\nThe return value is True when <code data-dev-comment-type=\"paramref\" class=\"paramref\">psw</code> is already set\nto AutoFlush mode. Otherwise, the mode is set, and the return value\nis False, to indicate that it wasn&apos;t set on entry.\n"
      overload: WizardWrx.Core.TraceLogger.ForceAutoFlush*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesLabeledLocalFirst(String, StreamWriter)
        VB: WriteWithBothTimesLabeledLocalFirst(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesLabeledLocalFirst(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesLabeledLocalFirst(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesLabeledLocalFirst
        path: ../Core/TraceLogger.cs
        startLine: 158
      summary: "\nWrite a time stamped trace log message, using the local and UTC \nmachine times as its time stamp prefix, local first, followed by\nUTC in parentheses.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithBothTimesLabeledLocalFirst(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithBothTimesLabeledLocalFirst(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesLabeledLocalFirstWithPassThrough(String, StreamWriter)
        VB: WriteWithBothTimesLabeledLocalFirstWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesLabeledLocalFirstWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 211
      summary: "\nCall WriteWithBothTimesLabeledLocalFirst to write the message either\nto the active Trace Listener or the alternate StreamWriter, then\nreturn the message to the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithBothTimesLabeledLocalFirstWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithBothTimesLabeledLocalFirstWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesLabeledUTCFirst(String, StreamWriter)
        VB: WriteWithBothTimesLabeledUTCFirst(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesLabeledUTCFirst(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesLabeledUTCFirst(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesLabeledUTCFirst
        path: ../Core/TraceLogger.cs
        startLine: 238
      summary: "\nWrite a time stamped trace log message, using the local and UTC \nmachine times as its time stamp prefix, UTC first, followed by\nlocal in parentheses.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithBothTimesLabeledUTCFirst(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithBothTimesLabeledUTCFirst(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesLabeledUTCFirstWithPassTrhough(String, StreamWriter)
        VB: WriteWithBothTimesLabeledUTCFirstWithPassTrhough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesLabeledUTCFirstWithPassTrhough
        path: ../Core/TraceLogger.cs
        startLine: 297
      summary: "\nCall WriteWithBothTimesLabeledUTCFirst and write the message to the\nactive Trace Listener or the supplied StreamWriter, then return the\nmessage to the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithBothTimesLabeledUTCFirstWithPassTrhough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithBothTimesLabeledUTCFirstWithPassTrhough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesUnlabeledLocalFirst(String, StreamWriter)
        VB: WriteWithBothTimesUnlabeledLocalFirst(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesUnlabeledLocalFirst
        path: ../Core/TraceLogger.cs
        startLine: 323
      summary: "\nWrite a time stamped trace log message, using the local and UTC \nmachine times as its time stamp prefix, local first, followed by\nUTC in parentheses.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithBothTimesUnlabeledLocalFirst(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithBothTimesUnlabeledLocalFirst(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(String, StreamWriter)
        VB: WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 371
      summary: "\nCall WriteWithBothTimesUnlabeledLocalFirst and write the message to\nthe active Trace Listener or the supplied StreamWriter, then return\nthe message to the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithBothTimesUnlabeledLocalFirstWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesUnlabeledUTCFirst(String, StreamWriter)
        VB: WriteWithBothTimesUnlabeledUTCFirst(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesUnlabeledUTCFirst
        path: ../Core/TraceLogger.cs
        startLine: 397
      summary: "\nWrite a time stamped trace log message, using the local and UTC \nmachine times as its time stamp prefix, UTC first, followed by\nlocal in parentheses.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithBothTimesUnlabeledUTCFirst(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithBothTimesUnlabeledUTCFirst(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(String, StreamWriter)
        VB: WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 445
      summary: "\nCall WriteWithBothTimesUnlabeledUTCFirst and write the message to\nthe active Trace Listener or the supplied StreamWriter, then return\nthe message to the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithBothTimesUnlabeledUTCFirstWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithLabeledLocalTime(String, StreamWriter)
        VB: WriteWithLabeledLocalTime(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithLabeledLocalTime(String, StreamWriter)
        VB: TraceLogger.WriteWithLabeledLocalTime(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithLabeledLocalTime
        path: ../Core/TraceLogger.cs
        startLine: 470
      summary: "\nWrite a time stamped trace log message, using the local machine time\nas its time stamp prefix.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithLabeledLocalTime(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithLabeledLocalTime(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithLabeledLocalTimeWithPassThrough(String, StreamWriter)
        VB: WriteWithLabeledLocalTimeWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithLabeledLocalTimeWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 515
      summary: "\nCall WriteWithLabeledLocalTime and write the message to the active\nTrace Listener or the supplied StreamWriter, then return the message\nto the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithLabeledLocalTimeWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithLabeledLocalTimeWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithUnlabeledLocalTime(String, StreamWriter)
        VB: WriteWithUnlabeledLocalTime(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithUnlabeledLocalTime(String, StreamWriter)
        VB: TraceLogger.WriteWithUnlabeledLocalTime(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithUnlabeledLocalTime
        path: ../Core/TraceLogger.cs
        startLine: 540
      summary: "\nWrite a time stamped trace log message, using the local machine time\nas its time stamp prefix.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithUnlabeledLocalTime(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithUnlabeledLocalTime(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithUnlabeledLocalTimeWithPassThrough(String, StreamWriter)
        VB: WriteWithUnlabeledLocalTimeWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithUnlabeledLocalTimeWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 583
      summary: "\nCall WriteWithUnlabeledLocalTime and write the message to the active\nTrace Listener or the supplied StreamWriter, then return the message\nto the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithUnlabeledLocalTimeWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithUnlabeledLocalTimeWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithLabeledUTCTime(String, StreamWriter)
        VB: WriteWithLabeledUTCTime(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithLabeledUTCTime(String, StreamWriter)
        VB: TraceLogger.WriteWithLabeledUTCTime(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithLabeledUTCTime
        path: ../Core/TraceLogger.cs
        startLine: 608
      summary: "\nWrite a time stamped trace log message, using the UTC machine time\nas its time stamp prefix.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithLabeledUTCTime(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithLabeledUTCTime(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithLabeledUTCTimeWithPassThrough(String, StreamWriter)
        VB: WriteWithLabeledUTCTimeWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithLabeledUTCTimeWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 649
      summary: "\nCall WriteWithLabeledUTCTime and write the message to the active\nTrace Listener or the supplied StreamWriter, then return the message\nto the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithLabeledUTCTimeWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithLabeledUTCTimeWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithUnlabeledUTCTime(String, StreamWriter)
        VB: WriteWithUnlabeledUTCTime(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithUnlabeledUTCTime(String, StreamWriter)
        VB: TraceLogger.WriteWithUnlabeledUTCTime(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithUnlabeledUTCTime
        path: ../Core/TraceLogger.cs
        startLine: 674
      summary: "\nWrite a time stamped trace log message, using the UTC machine time\nas its time stamp prefix.\n"
      example: []
      syntax:
        content:
          CSharp: public static void WriteWithUnlabeledUTCTime(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Sub WriteWithUnlabeledUTCTime(pstrMessage As String, psw As StreamWriter = Nothing)
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(System.String,System.IO.StreamWriter)
      commentId: M:WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(System.String,System.IO.StreamWriter)
      language: CSharp
      name:
        CSharp: WriteWithUnlabeledUTCTimeWithPassThrough(String, StreamWriter)
        VB: WriteWithUnlabeledUTCTimeWithPassThrough(String, StreamWriter)
      nameWithType:
        CSharp: TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(String, StreamWriter)
        VB: TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(String, StreamWriter)
      qualifiedName:
        CSharp: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(System.String, System.IO.StreamWriter)
        VB: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough(System.String, System.IO.StreamWriter)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/TraceLogger.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: WriteWithUnlabeledUTCTimeWithPassThrough
        path: ../Core/TraceLogger.cs
        startLine: 713
      summary: "\nCall WriteWithUnlabeledUTCTime and write the message to the active\nTrace Listener or the supplied StreamWriter, then return the message\nto the calling routine.\n"
      example: []
      syntax:
        content:
          CSharp: public static string WriteWithUnlabeledUTCTimeWithPassThrough(string pstrMessage, StreamWriter psw = null)
          VB: Public Shared Function WriteWithUnlabeledUTCTimeWithPassThrough(pstrMessage As String, psw As StreamWriter = Nothing) As String
        parameters:
        - id: pstrMessage
          type: System.String
          description: "\nThe specified string is written verbatim, immediately after the time\nstamp.\n"
        - id: psw
          type: System.IO.StreamWriter
          description: "\nWhen supplied, this StreamWriter takes the place of the Trace Listener.\n"
        return:
          type: System.String
          description: "\nThe return value is a copy of <code data-dev-comment-type=\"paramref\" class=\"paramref\">pstrMessage</code>.\n"
      overload: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Core.UnconfiguredDLLSettings
    commentId: T:WizardWrx.Core.UnconfiguredDLLSettings
    language: CSharp
    name:
      CSharp: UnconfiguredDLLSettings
      VB: UnconfiguredDLLSettings
    nameWithType:
      CSharp: UnconfiguredDLLSettings
      VB: UnconfiguredDLLSettings
    qualifiedName:
      CSharp: WizardWrx.Core.UnconfiguredDLLSettings
      VB: WizardWrx.Core.UnconfiguredDLLSettings
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/UnconfiguredDLLSettings.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: UnconfiguredDLLSettings
      path: ../Core/UnconfiguredDLLSettings.cs
      startLine: 76
    summary: "\nOrganize the DLL configuration values that were omitted from the\nassociated configuration file. Since multiple classes can and do share a\nDLL configuration file, this class must be a Singleton.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class UnconfiguredDLLSettings : GenericSingletonBase<UnconfiguredDLLSettings>'
        VB: >-
          Public Class UnconfiguredDLLSettings

              Inherits GenericSingletonBase(Of UnconfiguredDLLSettings)
    inheritance:
    - System.Object
    - WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}
    inheritedMembers:
    - WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.s_genTheOnlyInstance
    - WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.TheOnlyInstance
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance
      language: CSharp
      name:
        CSharp: GetTheSingleInstance()
        VB: GetTheSingleInstance()
      nameWithType:
        CSharp: UnconfiguredDLLSettings.GetTheSingleInstance()
        VB: UnconfiguredDLLSettings.GetTheSingleInstance()
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance()
        VB: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetTheSingleInstance
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 99
      summary: "\nReturn a reference to the single instance after initializing it if\nneeded.\n"
      remarks: "\nInitializing the dictionary is handled by the private instance\nconstructor.\n"
      example: []
      syntax:
        content:
          CSharp: public static UnconfiguredDLLSettings GetTheSingleInstance()
          VB: Public Shared Function GetTheSingleInstance As UnconfiguredDLLSettings
        return:
          type: WizardWrx.Core.UnconfiguredDLLSettings
          description: "\nThis method overrides the like-named method on the base class, so\nthat it can initialize its Dictionary object.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Core.UnconfiguredDLLSettings.Add(System.String,System.String,System.String)
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.Add(System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: Add(String, String, String)
        VB: Add(String, String, String)
      nameWithType:
        CSharp: UnconfiguredDLLSettings.Add(String, String, String)
        VB: UnconfiguredDLLSettings.Add(String, String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.Add(System.String, System.String, System.String)
        VB: WizardWrx.Core.UnconfiguredDLLSettings.Add(System.String, System.String, System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Add
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 125
      summary: "\nAdd a new unconfigured setting.\n"
      example: []
      syntax:
        content:
          CSharp: public void Add(string configFileName, string propName, string propValue)
          VB: Public Sub Add(configFileName As String, propName As String, propValue As String)
        parameters:
        - id: configFileName
          type: System.String
          description: "\nIdentify the affected configuration file.\n"
        - id: propName
          type: System.String
          description: "\nIdentify the name of the missing property.\n"
        - id: propValue
          type: System.String
          description: "\nRecird its default value.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.Add*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile(System.String)
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile(System.String)
      language: CSharp
      name:
        CSharp: GetMissingPropsForFile(String)
        VB: GetMissingPropsForFile(String)
      nameWithType:
        CSharp: UnconfiguredDLLSettings.GetMissingPropsForFile(String)
        VB: UnconfiguredDLLSettings.GetMissingPropsForFile(String)
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile(System.String)
        VB: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetMissingPropsForFile
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 162
      summary: "\nReturn the list of parameters that are missing from the specified\nconfiguration file.\n"
      example: []
      syntax:
        content:
          CSharp: public List<UnconfiguredDLLSettings.UnconfiguredSetting> GetMissingPropsForFile(string pstrConfigFileName)
          VB: Public Function GetMissingPropsForFile(pstrConfigFileName As String) As List(Of UnconfiguredDLLSettings.UnconfiguredSetting)
        parameters:
        - id: pstrConfigFileName
          type: System.String
          description: "\nSpecify the name of the file for which the list is wanted.\n"
        return:
          type: System.Collections.Generic.List{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}
          description: "\nThe return value is a list of UnconfiguredSetting objects, which may\nbe empty.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.UnconfiguredDLLSettings.Count
      commentId: P:WizardWrx.Core.UnconfiguredDLLSettings.Count
      language: CSharp
      name:
        CSharp: Count
        VB: Count
      nameWithType:
        CSharp: UnconfiguredDLLSettings.Count
        VB: UnconfiguredDLLSettings.Count
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.Count
        VB: WizardWrx.Core.UnconfiguredDLLSettings.Count
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Count
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 184
      summary: "\nExpose the Count property of the dictionary.\n"
      example: []
      syntax:
        content:
          CSharp: public int Count { get; }
          VB: Public ReadOnly Property Count As Integer
        parameters: []
        return:
          type: System.Int32
      overload: WizardWrx.Core.UnconfiguredDLLSettings.Count*
      modifiers:
        CSharp:
        - public
        - get
        VB:
        - Public
        - ReadOnly
  - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
    commentId: T:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
    language: CSharp
    name:
      CSharp: UnconfiguredDLLSettings.UnconfiguredSetting
      VB: UnconfiguredDLLSettings.UnconfiguredSetting
    nameWithType:
      CSharp: UnconfiguredDLLSettings.UnconfiguredSetting
      VB: UnconfiguredDLLSettings.UnconfiguredSetting
    qualifiedName:
      CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/UnconfiguredDLLSettings.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: UnconfiguredSetting
      path: ../Core/UnconfiguredDLLSettings.cs
      startLine: 197
    summary: "\nSettings are organized into a private collection that belongs to the\nsingleton.\n"
    example: []
    syntax:
      content:
        CSharp: 'public class UnconfiguredSetting : IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>'
        VB: >-
          Public Class UnconfiguredSetting

              Implements IComparable(Of UnconfiguredDLLSettings.UnconfiguredSetting)
    inheritance:
    - System.Object
    implements:
    - System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}
    inheritedMembers:
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - class
      VB:
      - Public
      - Class
    items:
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor(System.String,System.String,System.String)
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor(System.String,System.String,System.String)
      language: CSharp
      name:
        CSharp: UnconfiguredSetting(String, String, String)
        VB: UnconfiguredSetting(String, String, String)
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting(String, String, String)
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting(String, String, String)
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting(System.String, System.String, System.String)
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting(System.String, System.String, System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 221
      summary: "\nAll interaction is expected to be with this constructor.\n"
      example: []
      syntax:
        content:
          CSharp: public UnconfiguredSetting(string configFileName, string propertyName, string propertyValue)
          VB: Public Sub New(configFileName As String, propertyName As String, propertyValue As String)
        parameters:
        - id: configFileName
          type: System.String
          description: "\nSettings are associated with a named configuration file. Only\nits base name matters, however.\n"
        - id: propertyName
          type: System.String
          description: "\nEach property name must be unique within the scope of its\nconfiguration file.\n"
        - id: propertyValue
          type: System.String
          description: "\nThe default property value is recorded herein for reference.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
      commentId: P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
      language: CSharp
      name:
        CSharp: ConfigFileName
        VB: ConfigFileName
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ConfigFileName
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 235
      summary: "\nGets or sets the configuration file name\n"
      example: []
      syntax:
        content:
          CSharp: public string ConfigFileName { get; set; }
          VB: Public Property ConfigFileName As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
      commentId: P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
      language: CSharp
      name:
        CSharp: PropName
        VB: PropName
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.PropName
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.PropName
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PropName
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 244
      summary: "\nGets or sets the property name\n"
      example: []
      syntax:
        content:
          CSharp: public string PropName { get; set; }
          VB: Public Property PropName As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
      commentId: P:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
      language: CSharp
      name:
        CSharp: PropValue
        VB: PropValue
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
      type: Property
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: PropValue
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 253
      summary: "\nGets or sets the default value assigned to the property\n"
      example: []
      syntax:
        content:
          CSharp: public string PropValue { get; set; }
          VB: Public Property PropValue As String
        parameters: []
        return:
          type: System.String
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue*
      modifiers:
        CSharp:
        - public
        - get
        - set
        VB:
        - Public
    - isEii: true
      id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
      language: CSharp
      name:
        CSharp: IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(UnconfiguredDLLSettings.UnconfiguredSetting)
        VB: System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(UnconfiguredDLLSettings.UnconfiguredSetting)
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(UnconfiguredDLLSettings.UnconfiguredSetting)
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(UnconfiguredDLLSettings.UnconfiguredSetting)
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 259
      syntax:
        content:
          CSharp: int IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(UnconfiguredDLLSettings.UnconfiguredSetting other)
          VB: Function System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo(other As UnconfiguredDLLSettings.UnconfiguredSetting) As Integer Implements IComparable(Of UnconfiguredDLLSettings.UnconfiguredSetting).CompareTo
        parameters:
        - id: other
          type: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        return:
          type: System.Int32
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo*
      implements:
      - System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}.CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
      modifiers:
        CSharp: []
        VB: []
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals(System.Object)
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals(System.Object)
      language: CSharp
      name:
        CSharp: Equals(Object)
        VB: Equals(Object)
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.Equals(Object)
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.Equals(Object)
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals(System.Object)
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals(System.Object)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Equals
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 277
      summary: "\nOverride the Equals method on the base class to give a value\nthat contains the absolute (fully qualified) configuration value\nname, composed of the configuration file name and the key name.\n"
      example: []
      syntax:
        content:
          CSharp: public override bool Equals(object obj)
          VB: Public Overrides Function Equals(obj As Object) As Boolean
        parameters:
        - id: obj
          type: System.Object
          description: "\nComparand\n"
        return:
          type: System.Boolean
          description: "\nTrue if this instance and the other refer to the same\nconfiguration file key.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals*
      overridden: System.Object.Equals(System.Object)
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
      language: CSharp
      name:
        CSharp: GetHashCode()
        VB: GetHashCode()
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode()
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode()
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode()
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetHashCode
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 291
      summary: "\nReturn a hash code based on the equality value.\n"
      example: []
      syntax:
        content:
          CSharp: public override int GetHashCode()
          VB: Public Overrides Function GetHashCode As Integer
        return:
          type: System.Int32
          description: "\nThe return value is the hash code that corresponds to the\nequality value.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode*
      overridden: System.Object.GetHashCode
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
    - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString
      commentId: M:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString
      language: CSharp
      name:
        CSharp: ToString()
        VB: ToString()
      nameWithType:
        CSharp: UnconfiguredDLLSettings.UnconfiguredSetting.ToString()
        VB: UnconfiguredDLLSettings.UnconfiguredSetting.ToString()
      qualifiedName:
        CSharp: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString()
        VB: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnconfiguredDLLSettings.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: ToString
        path: ../Core/UnconfiguredDLLSettings.cs
        startLine: 305
      summary: "\nReturn a concatenated string composed of the name of the\nconfiguration file followed by the configuration value name.\n"
      example: []
      syntax:
        content:
          CSharp: public override string ToString()
          VB: Public Overrides Function ToString As String
        return:
          type: System.String
          description: "\nThe return value is the configuration file name and key name,\nseparated by an underscore character.\n"
      overload: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString*
      overridden: System.Object.ToString
      modifiers:
        CSharp:
        - public
        - override
        VB:
        - Public
        - Overrides
  - id: WizardWrx.Core.UnmanagedLibrary
    commentId: T:WizardWrx.Core.UnmanagedLibrary
    language: CSharp
    name:
      CSharp: UnmanagedLibrary
      VB: UnmanagedLibrary
    nameWithType:
      CSharp: UnmanagedLibrary
      VB: UnmanagedLibrary
    qualifiedName:
      CSharp: WizardWrx.Core.UnmanagedLibrary
      VB: WizardWrx.Core.UnmanagedLibrary
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Core
    source:
      remote:
        path: Core/UnmanagedLibrary.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: UnmanagedLibrary
      path: ../Core/UnmanagedLibrary.cs
      startLine: 76
    summary: "\nUtility class to wrap an unmanaged DLL and be responsible for freeing it\n"
    remarks: "\nThis is a managed wrapper over the native LoadLibrary, GetProcAddress,\nand FreeLibrary calls.\n\nI didn&apos;t immediately notice the fact that this class is sealed, but not\nstatic; hence, public UnmanagedLibrary ( string fileName ) is its one\nand only public constructor. As insurance against accidentally creating\na useless, uninitialized instance, I added a default constructor, marked\nas private.\n"
    example: []
    syntax:
      content:
        CSharp: 'public sealed class UnmanagedLibrary : IDisposable'
        VB: >-
          Public NotInheritable Class UnmanagedLibrary

              Implements IDisposable
    inheritance:
    - System.Object
    implements:
    - System.IDisposable
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - sealed
      - class
      VB:
      - Public
      - NotInheritable
      - Class
    items:
    - id: WizardWrx.Core.UnmanagedLibrary.#ctor(System.String)
      commentId: M:WizardWrx.Core.UnmanagedLibrary.#ctor(System.String)
      language: CSharp
      name:
        CSharp: UnmanagedLibrary(String)
        VB: UnmanagedLibrary(String)
      nameWithType:
        CSharp: UnmanagedLibrary.UnmanagedLibrary(String)
        VB: UnmanagedLibrary.UnmanagedLibrary(String)
      qualifiedName:
        CSharp: WizardWrx.Core.UnmanagedLibrary.UnmanagedLibrary(System.String)
        VB: WizardWrx.Core.UnmanagedLibrary.UnmanagedLibrary(System.String)
      type: Constructor
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnmanagedLibrary.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: .ctor
        path: ../Core/UnmanagedLibrary.cs
        startLine: 129
      summary: "\nConstructor to load a DLL and be responsible for freeing it\n"
      remarks: "\nThrows exceptions on failure. Most common failure would be file-not-found, or\nthat the file is not a loadable image.\n"
      example: []
      syntax:
        content:
          CSharp: public UnmanagedLibrary(string fileName)
          VB: Public Sub New(fileName As String)
        parameters:
        - id: fileName
          type: System.String
          description: "\nfull path name of DLL to load\n"
      overload: WizardWrx.Core.UnmanagedLibrary.#ctor*
      exceptions:
      - type: System.IO.FileNotFoundException
        commentId: T:System.IO.FileNotFoundException
        description: "\nif fileName cannot be found\n"
      modifiers:
        CSharp:
        - public
        VB:
        - Public
      references:
        System.IO.FileNotFoundException: 
    - id: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction``1(System.String)
      commentId: M:WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction``1(System.String)
      language: CSharp
      name:
        CSharp: GetUnmanagedFunction<TDelegate>(String)
        VB: GetUnmanagedFunction(Of TDelegate)(String)
      nameWithType:
        CSharp: UnmanagedLibrary.GetUnmanagedFunction<TDelegate>(String)
        VB: UnmanagedLibrary.GetUnmanagedFunction(Of TDelegate)(String)
      qualifiedName:
        CSharp: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction<TDelegate>(System.String)
        VB: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction(Of TDelegate)(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnmanagedLibrary.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: GetUnmanagedFunction
        path: ../Core/UnmanagedLibrary.cs
        startLine: 177
      summary: "\nDynamically lookup a function via kernel32!GetProcAddress.\n"
      remarks: "\nGetProcAddress results are valid as long as the DLL is loaded. This\nis very, very dangerous to use since you need to ensure that the DLL\nis not unloaded until after you’re done with any objects implemented\nby the DLL. For example, if you get a delegate that then gets an\nIUnknown implemented by this DLL, you can not dispose this library\nuntil that IUnknown is collected. Else, you may free the library, and\nthen the CLR may call release on that IUnknown, leading to a crash.\n\nDeclare your delegate pretty much as you would in C or C++; if you\nhappen to have a working typedef, use it as the pattern for your\ndelegate declaration, which must have class cope.\n\nOnce you have your delegate declared, instantiate it by assigning it\nthe value returned by calling this method on an instance that was\nconstructed using the name of the DLL that exports the desired Win32\n(or Win64) function.\n\nSince the Win64 API generally uses the same names, signatures, and\nDLL names (e. g., it&apos;s still Kernel32.dll, and GetProcAddress is\nstill GetProcAddress), most of your existing Windows API calls work\nunchanged in Win64. The magic that makes this possible is that Win32\ncode looks in %SystemRoot%\\SysWOW64, while Win64 code looks in\n%SystemRoot%\\System32 for system libraries. The clear goal of this\ninitially confusing scheme was to make porting code to 64 bits as\npainless as possible.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            public TDelegate GetUnmanagedFunction<TDelegate>(string functionName)

                where TDelegate : class
          VB: Public Function GetUnmanagedFunction(Of TDelegate As Class)(functionName As String) As TDelegate
        parameters:
        - id: functionName
          type: System.String
          description: "\nraw name of the function in the export table\n"
        typeParameters:
        - id: TDelegate
        return:
          type: '{TDelegate}'
          description: "\nnull if function is not found, else a delegate to the unmanaged\nfunction\n"
      overload: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction*
      modifiers:
        CSharp:
        - public
        VB:
        - Public
    - id: WizardWrx.Core.UnmanagedLibrary.Dispose
      commentId: M:WizardWrx.Core.UnmanagedLibrary.Dispose
      language: CSharp
      name:
        CSharp: Dispose()
        VB: Dispose()
      nameWithType:
        CSharp: UnmanagedLibrary.Dispose()
        VB: UnmanagedLibrary.Dispose()
      qualifiedName:
        CSharp: WizardWrx.Core.UnmanagedLibrary.Dispose()
        VB: WizardWrx.Core.UnmanagedLibrary.Dispose()
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Core
      source:
        remote:
          path: Core/UnmanagedLibrary.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: Dispose
        path: ../Core/UnmanagedLibrary.cs
        startLine: 213
      summary: "\nCall FreeLibrary on the unmanaged DLL. All function pointers\nhanded out from this class become invalid after this.\n"
      remarks: "\nThis is very dangerous because it suddenly invalidate\neverything retrieved from this DLL. This includes any functions\nhanded out via GetProcAddress, and potentially any objects returned\nfrom those functions (which may have an implementation in the DLL).\n"
      example: []
      syntax:
        content:
          CSharp: public void Dispose()
          VB: Public Sub Dispose
      overload: WizardWrx.Core.UnmanagedLibrary.Dispose*
      implements:
      - System.IDisposable.Dispose
      modifiers:
        CSharp:
        - public
        VB:
        - Public
- id: WizardWrx.Cryptography
  commentId: N:WizardWrx.Cryptography
  language: CSharp
  name:
    CSharp: WizardWrx.Cryptography
    VB: WizardWrx.Cryptography
  nameWithType:
    CSharp: WizardWrx.Cryptography
    VB: WizardWrx.Cryptography
  qualifiedName:
    CSharp: WizardWrx.Cryptography
    VB: WizardWrx.Cryptography
  type: Namespace
  assemblies:
  - WizardWrx.Core
  modifiers: {}
  items:
  - id: WizardWrx.Cryptography.DigestFile
    commentId: T:WizardWrx.Cryptography.DigestFile
    language: CSharp
    name:
      CSharp: DigestFile
      VB: DigestFile
    nameWithType:
      CSharp: DigestFile
      VB: DigestFile
    qualifiedName:
      CSharp: WizardWrx.Cryptography.DigestFile
      VB: WizardWrx.Cryptography.DigestFile
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Cryptography
    source:
      remote:
        path: Core/DigestFile.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: DigestFile
      path: ../Core/DigestFile.cs
      startLine: 133
    summary: "\nStatic methods for computing message digests for files, using the most\ncommon algorithms.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
    example: []
    syntax:
      content:
        CSharp: public static class DigestFile
        VB: Public Module DigestFile
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Cryptography.DigestFile.MD5Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestFile.MD5Hash(System.String)
      language: CSharp
      name:
        CSharp: MD5Hash(String)
        VB: MD5Hash(String)
      nameWithType:
        CSharp: DigestFile.MD5Hash(String)
        VB: DigestFile.MD5Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestFile.MD5Hash(System.String)
        VB: WizardWrx.Cryptography.DigestFile.MD5Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestFile.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: MD5Hash
        path: ../Core/DigestFile.cs
        startLine: 180
      summary: "\nGiven the name of a file, return its MD5 message digest as a 32 \ncharacter string of hexadecimal digits.\n"
      remarks: "\nSince the internal hashing implementations expect byte arrays, the\ninput string must be converted. The Encoding.Default.GetBytes method\nis called upon to convert the string into a byte array.\n\nA slightly modified version of the Rivest code, written in ANSI C,\nis the engine in my MD5WIN stand-alone program and my MD5Digest\nWindows Dynamic Link Library.\n\nHowever, this function uses a MD5CryptoServiceProvider object, which\nprovides a managed interface to the Cryptographic Service Provider\nin the host&apos;s installation of Microsoft Windows. I chose this over\nthe 100% managed implementation for two reasons.\n\n1) The CSP implementation uses native machine code for the\ncomputation, and should outperform managed code on large plain-texts.\n\n2) By using the native implementation, the CLR is eliminated as a\npotential point of failure due to a weakness in the implementation\nof the algorithm.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.")]

            public static string MD5Hash(string pstrFileName)
          VB: >-
            <Obsolete("This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.")>

            Public Shared Function MD5Hash(pstrFileName As String) As String
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of the file to be digested. See Remarks\nfor important information about the internal implementation.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
        return:
          type: System.String
          description: "\nThe message digest, consisting of a string of 32 hexadecimal\ncharacters. This string is identical with the strings returned by\nthe reference implementation, published by Dr. Ronald Rivest, who is\ncredited with inventing the MD5 digest algorithm.\n"
      overload: WizardWrx.Cryptography.DigestFile.MD5Hash*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestFile.SHA1Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestFile.SHA1Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA1Hash(String)
        VB: SHA1Hash(String)
      nameWithType:
        CSharp: DigestFile.SHA1Hash(String)
        VB: DigestFile.SHA1Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestFile.SHA1Hash(System.String)
        VB: WizardWrx.Cryptography.DigestFile.SHA1Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestFile.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA1Hash
        path: ../Core/DigestFile.cs
        startLine: 225
      summary: "\nGiven the name of a file, return its SHA-1 message digest as a 32\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: >-
            [Obsolete("This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.")]

            public static string SHA1Hash(string pstrFileName)
          VB: >-
            <Obsolete("This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.")>

            Public Shared Function SHA1Hash(pstrFileName As String) As String
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of the file to be digested.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
        return:
          type: System.String
          description: "\nThe message digest, consisting of a string of 40 hexadecimal\ncharacters.\n"
      overload: WizardWrx.Cryptography.DigestFile.SHA1Hash*
      attributes:
      - type: System.ObsoleteAttribute
        ctor: System.ObsoleteAttribute.#ctor(System.String)
        arguments:
        - type: System.String
          value: This algorithm is classified as broken and unsafe. Use SHA256Hash, SHA384Hash, or SHA512Hash.
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestFile.SHA256Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestFile.SHA256Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA256Hash(String)
        VB: SHA256Hash(String)
      nameWithType:
        CSharp: DigestFile.SHA256Hash(String)
        VB: DigestFile.SHA256Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestFile.SHA256Hash(System.String)
        VB: WizardWrx.Cryptography.DigestFile.SHA256Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestFile.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA256Hash
        path: ../Core/DigestFile.cs
        startLine: 266
      summary: "\nGiven the name of a file, return its SHA-256 message digest as a 64\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA256Hash(string pstrFileName)
          VB: Public Shared Function SHA256Hash(pstrFileName As String) As String
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of the file to be digested.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
        return:
          type: System.String
          description: "\nThe message digest, consisting of a string of 64 hexadecimal\ncharacters.\n"
      overload: WizardWrx.Cryptography.DigestFile.SHA256Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestFile.SHA384Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestFile.SHA384Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA384Hash(String)
        VB: SHA384Hash(String)
      nameWithType:
        CSharp: DigestFile.SHA384Hash(String)
        VB: DigestFile.SHA384Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestFile.SHA384Hash(System.String)
        VB: WizardWrx.Cryptography.DigestFile.SHA384Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestFile.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA384Hash
        path: ../Core/DigestFile.cs
        startLine: 306
      summary: "\nGiven the name of a file, return its SHA-384 message digest as a 96\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA384Hash(string pstrFileName)
          VB: Public Shared Function SHA384Hash(pstrFileName As String) As String
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of the file to be digested.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
        return:
          type: System.String
          description: "\nThe message digest, consisting of a string of 64 hexadecimal\ncharacters.\n"
      overload: WizardWrx.Cryptography.DigestFile.SHA384Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestFile.SHA512Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestFile.SHA512Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA512Hash(String)
        VB: SHA512Hash(String)
      nameWithType:
        CSharp: DigestFile.SHA512Hash(String)
        VB: DigestFile.SHA512Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestFile.SHA512Hash(System.String)
        VB: WizardWrx.Cryptography.DigestFile.SHA512Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestFile.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA512Hash
        path: ../Core/DigestFile.cs
        startLine: 346
      summary: "\nGiven the name of a file, return its SHA-512 message digest as a 128\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA512Hash(string pstrFileName)
          VB: Public Shared Function SHA512Hash(pstrFileName As String) As String
        parameters:
        - id: pstrFileName
          type: System.String
          description: "\nString containing the name of the file to be digested.\n\niMPORTANT: Since files are read in binary, they are loaded directly\ninto the hash algorithm as byte arrays. This means that the digest\nof a file of ASCII characters and the hash of the file contents read\ninto a CLR string object, which is a string of Unicode characters,\nwill differ. The reason for this is that the string of Unicode \ncharacters yields a different byte stream than the byte stream that\ncame from reading the file in binary mode.\n"
        return:
          type: System.String
          description: "\nThe message digest, consisting of a string of 64 hexadecimal\ncharacters.\n"
      overload: WizardWrx.Cryptography.DigestFile.SHA512Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
  - id: WizardWrx.Cryptography.DigestString
    commentId: T:WizardWrx.Cryptography.DigestString
    language: CSharp
    name:
      CSharp: DigestString
      VB: DigestString
    nameWithType:
      CSharp: DigestString
      VB: DigestString
    qualifiedName:
      CSharp: WizardWrx.Cryptography.DigestString
      VB: WizardWrx.Cryptography.DigestString
    type: Class
    assemblies:
    - WizardWrx.Core
    namespace: WizardWrx.Cryptography
    source:
      remote:
        path: Core/DigestString.cs
        branch: master
        repo: https://github.com/txwizard/WizardWrx_NET_API.git
      id: DigestString
      path: ../Core/DigestString.cs
      startLine: 107
    summary: "\nStatic methods for computing message digests for strings, using the most\ncommon algorithms.\n"
    example: []
    syntax:
      content:
        CSharp: public static class DigestString
        VB: Public Module DigestString
    inheritance:
    - System.Object
    inheritedMembers:
    - System.Object.ToString
    - System.Object.Equals(System.Object)
    - System.Object.Equals(System.Object,System.Object)
    - System.Object.ReferenceEquals(System.Object,System.Object)
    - System.Object.GetHashCode
    - System.Object.GetType
    - System.Object.MemberwiseClone
    modifiers:
      CSharp:
      - public
      - static
      - class
      VB:
      - Public
      - Module
    items:
    - id: WizardWrx.Cryptography.DigestString.SHA256Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestString.SHA256Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA256Hash(String)
        VB: SHA256Hash(String)
      nameWithType:
        CSharp: DigestString.SHA256Hash(String)
        VB: DigestString.SHA256Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA256Hash(System.String)
        VB: WizardWrx.Cryptography.DigestString.SHA256Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA256Hash
        path: ../Core/DigestString.cs
        startLine: 120
      summary: "\nGiven a string, return its SHA-256 message digest as a 64\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA256Hash(string strPlaintext)
          VB: Public Shared Function SHA256Hash(strPlaintext As String) As String
        parameters:
        - id: strPlaintext
          type: System.String
          description: "\nSupply a pointer to the string to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 64\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA256Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestString.SHA256Hash(System.Byte[])
      commentId: M:WizardWrx.Cryptography.DigestString.SHA256Hash(System.Byte[])
      language: CSharp
      name:
        CSharp: SHA256Hash(Byte[])
        VB: SHA256Hash(Byte())
      nameWithType:
        CSharp: DigestString.SHA256Hash(Byte[])
        VB: DigestString.SHA256Hash(Byte())
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA256Hash(System.Byte[])
        VB: WizardWrx.Cryptography.DigestString.SHA256Hash(System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA256Hash
        path: ../Core/DigestString.cs
        startLine: 141
      summary: "\nGiven a byte array, return its SHA-256 message digest as a 64\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA256Hash(byte[] pabytPlainText)
          VB: Public Shared Function SHA256Hash(pabytPlainText As Byte()) As String
        parameters:
        - id: pabytPlainText
          type: System.Byte[]
          description: "\nSupply a pointer to the byte array to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 64\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA256Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestString.SHA384Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestString.SHA384Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA384Hash(String)
        VB: SHA384Hash(String)
      nameWithType:
        CSharp: DigestString.SHA384Hash(String)
        VB: DigestString.SHA384Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA384Hash(System.String)
        VB: WizardWrx.Cryptography.DigestString.SHA384Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA384Hash
        path: ../Core/DigestString.cs
        startLine: 161
      summary: "\nGiven a string, return its SHA-384 message digest as a 96\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA384Hash(string strPlaintext)
          VB: Public Shared Function SHA384Hash(strPlaintext As String) As String
        parameters:
        - id: strPlaintext
          type: System.String
          description: "\nSupply a pointer to the string to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 96\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA384Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestString.SHA384Hash(System.Byte[])
      commentId: M:WizardWrx.Cryptography.DigestString.SHA384Hash(System.Byte[])
      language: CSharp
      name:
        CSharp: SHA384Hash(Byte[])
        VB: SHA384Hash(Byte())
      nameWithType:
        CSharp: DigestString.SHA384Hash(Byte[])
        VB: DigestString.SHA384Hash(Byte())
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA384Hash(System.Byte[])
        VB: WizardWrx.Cryptography.DigestString.SHA384Hash(System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA384Hash
        path: ../Core/DigestString.cs
        startLine: 182
      summary: "\nGiven a byte array, return its SHA-384 message digest as a 96\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA384Hash(byte[] pabytPlainText)
          VB: Public Shared Function SHA384Hash(pabytPlainText As Byte()) As String
        parameters:
        - id: pabytPlainText
          type: System.Byte[]
          description: "\nSupply a pointer to the byte array to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 96\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA384Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestString.SHA512Hash(System.String)
      commentId: M:WizardWrx.Cryptography.DigestString.SHA512Hash(System.String)
      language: CSharp
      name:
        CSharp: SHA512Hash(String)
        VB: SHA512Hash(String)
      nameWithType:
        CSharp: DigestString.SHA512Hash(String)
        VB: DigestString.SHA512Hash(String)
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA512Hash(System.String)
        VB: WizardWrx.Cryptography.DigestString.SHA512Hash(System.String)
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA512Hash
        path: ../Core/DigestString.cs
        startLine: 202
      summary: "\nGiven a string, return its SHA-512 message digest as a 128\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA512Hash(string strPlaintext)
          VB: Public Shared Function SHA512Hash(strPlaintext As String) As String
        parameters:
        - id: strPlaintext
          type: System.String
          description: "\nSupply a pointer to the string to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 128\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA512Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
    - id: WizardWrx.Cryptography.DigestString.SHA512Hash(System.Byte[])
      commentId: M:WizardWrx.Cryptography.DigestString.SHA512Hash(System.Byte[])
      language: CSharp
      name:
        CSharp: SHA512Hash(Byte[])
        VB: SHA512Hash(Byte())
      nameWithType:
        CSharp: DigestString.SHA512Hash(Byte[])
        VB: DigestString.SHA512Hash(Byte())
      qualifiedName:
        CSharp: WizardWrx.Cryptography.DigestString.SHA512Hash(System.Byte[])
        VB: WizardWrx.Cryptography.DigestString.SHA512Hash(System.Byte())
      type: Method
      assemblies:
      - WizardWrx.Core
      namespace: WizardWrx.Cryptography
      source:
        remote:
          path: Core/DigestString.cs
          branch: master
          repo: https://github.com/txwizard/WizardWrx_NET_API.git
        id: SHA512Hash
        path: ../Core/DigestString.cs
        startLine: 223
      summary: "\nGiven a byte array, return its SHA-512 message digest as a 128\ncharacter string of hexadecimal digits.\n"
      example: []
      syntax:
        content:
          CSharp: public static string SHA512Hash(byte[] pabytPlainText)
          VB: Public Shared Function SHA512Hash(pabytPlainText As Byte()) As String
        parameters:
        - id: pabytPlainText
          type: System.Byte[]
          description: "\nSupply a pointer to the byte array to be digested.\n"
        return:
          type: System.String
          description: "\nThe return value is a message digest, consisting of a string of 128\nhexadecimal characters.\n"
      overload: WizardWrx.Cryptography.DigestString.SHA512Hash*
      modifiers:
        CSharp:
        - public
        - static
        VB:
        - Public
        - Shared
references:
  System:
    name:
      CSharp:
      - name: System
        nameWithType: System
        qualifiedName: System
        isExternal: true
      VB:
      - name: System
        nameWithType: System
        qualifiedName: System
    isDefinition: true
    commentId: N:System
  System.Object:
    name:
      CSharp:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      VB:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Object
  System.Object.ToString:
    name:
      CSharp:
      - id: System.Object.ToString
        name: ToString
        nameWithType: Object.ToString
        qualifiedName: System.Object.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.ToString
        name: ToString
        nameWithType: Object.ToString
        qualifiedName: System.Object.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.ToString
  System.Object.Equals(System.Object):
    name:
      CSharp:
      - id: System.Object.Equals(System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.Equals(System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.Equals(System.Object)
  System.Object.Equals(System.Object,System.Object):
    name:
      CSharp:
      - id: System.Object.Equals(System.Object,System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.Equals(System.Object,System.Object)
        name: Equals
        nameWithType: Object.Equals
        qualifiedName: System.Object.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.Equals(System.Object,System.Object)
  System.Object.ReferenceEquals(System.Object,System.Object):
    name:
      CSharp:
      - id: System.Object.ReferenceEquals(System.Object,System.Object)
        name: ReferenceEquals
        nameWithType: Object.ReferenceEquals
        qualifiedName: System.Object.ReferenceEquals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.ReferenceEquals(System.Object,System.Object)
        name: ReferenceEquals
        nameWithType: Object.ReferenceEquals
        qualifiedName: System.Object.ReferenceEquals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  System.Object.GetHashCode:
    name:
      CSharp:
      - id: System.Object.GetHashCode
        name: GetHashCode
        nameWithType: Object.GetHashCode
        qualifiedName: System.Object.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.GetHashCode
        name: GetHashCode
        nameWithType: Object.GetHashCode
        qualifiedName: System.Object.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.GetHashCode
  System.Object.GetType:
    name:
      CSharp:
      - id: System.Object.GetType
        name: GetType
        nameWithType: Object.GetType
        qualifiedName: System.Object.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.GetType
        name: GetType
        nameWithType: Object.GetType
        qualifiedName: System.Object.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.GetType
  System.Object.MemberwiseClone:
    name:
      CSharp:
      - id: System.Object.MemberwiseClone
        name: MemberwiseClone
        nameWithType: Object.MemberwiseClone
        qualifiedName: System.Object.MemberwiseClone
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Object.MemberwiseClone
        name: MemberwiseClone
        nameWithType: Object.MemberwiseClone
        qualifiedName: System.Object.MemberwiseClone
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Object
    commentId: M:System.Object.MemberwiseClone
  System.DateTime:
    name:
      CSharp:
      - id: System.DateTime
        name: DateTime
        nameWithType: DateTime
        qualifiedName: System.DateTime
        isExternal: true
      VB:
      - id: System.DateTime
        name: DateTime
        nameWithType: DateTime
        qualifiedName: System.DateTime
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DateTime
  System.DayOfWeek:
    name:
      CSharp:
      - id: System.DayOfWeek
        name: DayOfWeek
        nameWithType: DayOfWeek
        qualifiedName: System.DayOfWeek
        isExternal: true
      VB:
      - id: System.DayOfWeek
        name: DayOfWeek
        nameWithType: DayOfWeek
        qualifiedName: System.DayOfWeek
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DayOfWeek
  WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday*:
    name:
      CSharp:
      - id: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday*
        name: DateOfMostRecentWeekday
        nameWithType: DateTimeExtensions.DateOfMostRecentWeekday
        qualifiedName: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday
      VB:
      - id: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday*
        name: DateOfMostRecentWeekday
        nameWithType: DateTimeExtensions.DateOfMostRecentWeekday
        qualifiedName: WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday
    isDefinition: true
    commentId: Overload:WizardWrx.DateTimeExtensions.DateOfMostRecentWeekday
  System.Int32:
    name:
      CSharp:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      VB:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Int32
  WizardWrx.DateTimeExtensions:
    name:
      CSharp:
      - id: WizardWrx.DateTimeExtensions
        name: DateTimeExtensions
        nameWithType: DateTimeExtensions
        qualifiedName: WizardWrx.DateTimeExtensions
      VB:
      - id: WizardWrx.DateTimeExtensions
        name: DateTimeExtensions
        nameWithType: DateTimeExtensions
        qualifiedName: WizardWrx.DateTimeExtensions
    isDefinition: true
    commentId: T:WizardWrx.DateTimeExtensions
  System.String:
    name:
      CSharp:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      VB:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.String
  WizardWrx.FileInfoExtension.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.#ctor*
        name: FileInfoExtension
        nameWithType: FileInfoExtension.FileInfoExtension
        qualifiedName: WizardWrx.FileInfoExtension.FileInfoExtension
      VB:
      - id: WizardWrx.FileInfoExtension.#ctor*
        name: FileInfoExtension
        nameWithType: FileInfoExtension.FileInfoExtension
        qualifiedName: WizardWrx.FileInfoExtension.FileInfoExtension
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.#ctor
  System.ObsoleteAttribute:
    name:
      CSharp:
      - id: System.ObsoleteAttribute
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute
        isExternal: true
      VB:
      - id: System.ObsoleteAttribute
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ObsoleteAttribute
  System.ObsoleteAttribute.#ctor(System.String):
    name:
      CSharp:
      - id: System.ObsoleteAttribute.#ctor(System.String)
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute.ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute.ObsoleteAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ObsoleteAttribute.#ctor(System.String)
        name: ObsoleteAttribute
        nameWithType: ObsoleteAttribute.ObsoleteAttribute
        qualifiedName: System.ObsoleteAttribute.ObsoleteAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ObsoleteAttribute
    commentId: M:System.ObsoleteAttribute.#ctor(System.String)
  WizardWrx:
    name:
      CSharp:
      - name: WizardWrx
        nameWithType: WizardWrx
        qualifiedName: WizardWrx
      VB:
      - name: WizardWrx
        nameWithType: WizardWrx
        qualifiedName: WizardWrx
    isDefinition: true
    commentId: N:WizardWrx
  WizardWrx.FileInfoExtension.enmInitialStatus:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.enmInitialStatus
        name: FileInfoExtension.enmInitialStatus
        nameWithType: FileInfoExtension.enmInitialStatus
        qualifiedName: WizardWrx.FileInfoExtension.enmInitialStatus
      VB:
      - id: WizardWrx.FileInfoExtension.enmInitialStatus
        name: FileInfoExtension.enmInitialStatus
        nameWithType: FileInfoExtension.enmInitialStatus
        qualifiedName: WizardWrx.FileInfoExtension.enmInitialStatus
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.FileInfoExtension.enmInitialStatus
  WizardWrx.FileInfoExtension.ArchiveClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ArchiveClear*
        name: ArchiveClear
        nameWithType: FileInfoExtension.ArchiveClear
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveClear
      VB:
      - id: WizardWrx.FileInfoExtension.ArchiveClear*
        name: ArchiveClear
        nameWithType: FileInfoExtension.ArchiveClear
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ArchiveClear
  WizardWrx.FileInfoExtension.ArchiveReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ArchiveReinstate*
        name: ArchiveReinstate
        nameWithType: FileInfoExtension.ArchiveReinstate
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveReinstate
      VB:
      - id: WizardWrx.FileInfoExtension.ArchiveReinstate*
        name: ArchiveReinstate
        nameWithType: FileInfoExtension.ArchiveReinstate
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ArchiveReinstate
  WizardWrx.FileInfoExtension.ArchiveSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ArchiveSet*
        name: ArchiveSet
        nameWithType: FileInfoExtension.ArchiveSet
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveSet
      VB:
      - id: WizardWrx.FileInfoExtension.ArchiveSet*
        name: ArchiveSet
        nameWithType: FileInfoExtension.ArchiveSet
        qualifiedName: WizardWrx.FileInfoExtension.ArchiveSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ArchiveSet
  WizardWrx.FileInfoExtension.HiddenClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.HiddenClear*
        name: HiddenClear
        nameWithType: FileInfoExtension.HiddenClear
        qualifiedName: WizardWrx.FileInfoExtension.HiddenClear
      VB:
      - id: WizardWrx.FileInfoExtension.HiddenClear*
        name: HiddenClear
        nameWithType: FileInfoExtension.HiddenClear
        qualifiedName: WizardWrx.FileInfoExtension.HiddenClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.HiddenClear
  WizardWrx.FileInfoExtension.HiddenReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.HiddenReinstate*
        name: HiddenReinstate
        nameWithType: FileInfoExtension.HiddenReinstate
        qualifiedName: WizardWrx.FileInfoExtension.HiddenReinstate
      VB:
      - id: WizardWrx.FileInfoExtension.HiddenReinstate*
        name: HiddenReinstate
        nameWithType: FileInfoExtension.HiddenReinstate
        qualifiedName: WizardWrx.FileInfoExtension.HiddenReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.HiddenReinstate
  WizardWrx.FileInfoExtension.HiddenSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.HiddenSet*
        name: HiddenSet
        nameWithType: FileInfoExtension.HiddenSet
        qualifiedName: WizardWrx.FileInfoExtension.HiddenSet
      VB:
      - id: WizardWrx.FileInfoExtension.HiddenSet*
        name: HiddenSet
        nameWithType: FileInfoExtension.HiddenSet
        qualifiedName: WizardWrx.FileInfoExtension.HiddenSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.HiddenSet
  WizardWrx.FileInfoExtension.ReadOnlyClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ReadOnlyClear*
        name: ReadOnlyClear
        nameWithType: FileInfoExtension.ReadOnlyClear
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlyClear
      VB:
      - id: WizardWrx.FileInfoExtension.ReadOnlyClear*
        name: ReadOnlyClear
        nameWithType: FileInfoExtension.ReadOnlyClear
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlyClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ReadOnlyClear
  WizardWrx.FileInfoExtension.ReadOnlyReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ReadOnlyReinstate*
        name: ReadOnlyReinstate
        nameWithType: FileInfoExtension.ReadOnlyReinstate
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlyReinstate
      VB:
      - id: WizardWrx.FileInfoExtension.ReadOnlyReinstate*
        name: ReadOnlyReinstate
        nameWithType: FileInfoExtension.ReadOnlyReinstate
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlyReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ReadOnlyReinstate
  WizardWrx.FileInfoExtension.ReadOnlySet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ReadOnlySet*
        name: ReadOnlySet
        nameWithType: FileInfoExtension.ReadOnlySet
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlySet
      VB:
      - id: WizardWrx.FileInfoExtension.ReadOnlySet*
        name: ReadOnlySet
        nameWithType: FileInfoExtension.ReadOnlySet
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnlySet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ReadOnlySet
  WizardWrx.FileInfoExtension.SystemClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.SystemClear*
        name: SystemClear
        nameWithType: FileInfoExtension.SystemClear
        qualifiedName: WizardWrx.FileInfoExtension.SystemClear
      VB:
      - id: WizardWrx.FileInfoExtension.SystemClear*
        name: SystemClear
        nameWithType: FileInfoExtension.SystemClear
        qualifiedName: WizardWrx.FileInfoExtension.SystemClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.SystemClear
  WizardWrx.FileInfoExtension.SystemReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.SystemReinstate*
        name: SystemReinstate
        nameWithType: FileInfoExtension.SystemReinstate
        qualifiedName: WizardWrx.FileInfoExtension.SystemReinstate
      VB:
      - id: WizardWrx.FileInfoExtension.SystemReinstate*
        name: SystemReinstate
        nameWithType: FileInfoExtension.SystemReinstate
        qualifiedName: WizardWrx.FileInfoExtension.SystemReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.SystemReinstate
  WizardWrx.FileInfoExtension.SystemSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.SystemSet*
        name: SystemSet
        nameWithType: FileInfoExtension.SystemSet
        qualifiedName: WizardWrx.FileInfoExtension.SystemSet
      VB:
      - id: WizardWrx.FileInfoExtension.SystemSet*
        name: SystemSet
        nameWithType: FileInfoExtension.SystemSet
        qualifiedName: WizardWrx.FileInfoExtension.SystemSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.SystemSet
  System.IO:
    name:
      CSharp:
      - name: System.IO
        nameWithType: System.IO
        qualifiedName: System.IO
        isExternal: true
      VB:
      - name: System.IO
        nameWithType: System.IO
        qualifiedName: System.IO
    isDefinition: true
    commentId: N:System.IO
  System.IO.FileInfo:
    name:
      CSharp:
      - id: System.IO.FileInfo
        name: FileInfo
        nameWithType: FileInfo
        qualifiedName: System.IO.FileInfo
        isExternal: true
      VB:
      - id: System.IO.FileInfo
        name: FileInfo
        nameWithType: FileInfo
        qualifiedName: System.IO.FileInfo
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.FileInfo
  WizardWrx.FileInfoExtension.TheFile*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.TheFile*
        name: TheFile
        nameWithType: FileInfoExtension.TheFile
        qualifiedName: WizardWrx.FileInfoExtension.TheFile
      VB:
      - id: WizardWrx.FileInfoExtension.TheFile*
        name: TheFile
        nameWithType: FileInfoExtension.TheFile
        qualifiedName: WizardWrx.FileInfoExtension.TheFile
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.TheFile
  System.Boolean:
    name:
      CSharp:
      - id: System.Boolean
        name: Boolean
        nameWithType: Boolean
        qualifiedName: System.Boolean
        isExternal: true
      VB:
      - id: System.Boolean
        name: Boolean
        nameWithType: Boolean
        qualifiedName: System.Boolean
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Boolean
  WizardWrx.FileInfoExtension.Archive*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Archive*
        name: Archive
        nameWithType: FileInfoExtension.Archive
        qualifiedName: WizardWrx.FileInfoExtension.Archive
      VB:
      - id: WizardWrx.FileInfoExtension.Archive*
        name: Archive
        nameWithType: FileInfoExtension.Archive
        qualifiedName: WizardWrx.FileInfoExtension.Archive
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Archive
  WizardWrx.FileInfoExtension.Compressed*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Compressed*
        name: Compressed
        nameWithType: FileInfoExtension.Compressed
        qualifiedName: WizardWrx.FileInfoExtension.Compressed
      VB:
      - id: WizardWrx.FileInfoExtension.Compressed*
        name: Compressed
        nameWithType: FileInfoExtension.Compressed
        qualifiedName: WizardWrx.FileInfoExtension.Compressed
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Compressed
  WizardWrx.FileInfoExtension.Encrypted*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Encrypted*
        name: Encrypted
        nameWithType: FileInfoExtension.Encrypted
        qualifiedName: WizardWrx.FileInfoExtension.Encrypted
      VB:
      - id: WizardWrx.FileInfoExtension.Encrypted*
        name: Encrypted
        nameWithType: FileInfoExtension.Encrypted
        qualifiedName: WizardWrx.FileInfoExtension.Encrypted
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Encrypted
  WizardWrx.FileInfoExtension.Hidden*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Hidden*
        name: Hidden
        nameWithType: FileInfoExtension.Hidden
        qualifiedName: WizardWrx.FileInfoExtension.Hidden
      VB:
      - id: WizardWrx.FileInfoExtension.Hidden*
        name: Hidden
        nameWithType: FileInfoExtension.Hidden
        qualifiedName: WizardWrx.FileInfoExtension.Hidden
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Hidden
  WizardWrx.FileInfoExtension.NotContentIndexed*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.NotContentIndexed*
        name: NotContentIndexed
        nameWithType: FileInfoExtension.NotContentIndexed
        qualifiedName: WizardWrx.FileInfoExtension.NotContentIndexed
      VB:
      - id: WizardWrx.FileInfoExtension.NotContentIndexed*
        name: NotContentIndexed
        nameWithType: FileInfoExtension.NotContentIndexed
        qualifiedName: WizardWrx.FileInfoExtension.NotContentIndexed
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.NotContentIndexed
  WizardWrx.FileInfoExtension.Offline*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Offline*
        name: Offline
        nameWithType: FileInfoExtension.Offline
        qualifiedName: WizardWrx.FileInfoExtension.Offline
      VB:
      - id: WizardWrx.FileInfoExtension.Offline*
        name: Offline
        nameWithType: FileInfoExtension.Offline
        qualifiedName: WizardWrx.FileInfoExtension.Offline
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Offline
  WizardWrx.FileInfoExtension.ReadOnly*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.ReadOnly*
        name: ReadOnly
        nameWithType: FileInfoExtension.ReadOnly
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnly
      VB:
      - id: WizardWrx.FileInfoExtension.ReadOnly*
        name: ReadOnly
        nameWithType: FileInfoExtension.ReadOnly
        qualifiedName: WizardWrx.FileInfoExtension.ReadOnly
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.ReadOnly
  WizardWrx.FileInfoExtension.System*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.System*
        name: System
        nameWithType: FileInfoExtension.System
        qualifiedName: WizardWrx.FileInfoExtension.System
      VB:
      - id: WizardWrx.FileInfoExtension.System*
        name: System
        nameWithType: FileInfoExtension.System
        qualifiedName: WizardWrx.FileInfoExtension.System
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.System
  WizardWrx.FileInfoExtension.Temporary*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.Temporary*
        name: Temporary
        nameWithType: FileInfoExtension.Temporary
        qualifiedName: WizardWrx.FileInfoExtension.Temporary
      VB:
      - id: WizardWrx.FileInfoExtension.Temporary*
        name: Temporary
        nameWithType: FileInfoExtension.Temporary
        qualifiedName: WizardWrx.FileInfoExtension.Temporary
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.Temporary
  WizardWrx.FileInfoExtension.WasArchive*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.WasArchive*
        name: WasArchive
        nameWithType: FileInfoExtension.WasArchive
        qualifiedName: WizardWrx.FileInfoExtension.WasArchive
      VB:
      - id: WizardWrx.FileInfoExtension.WasArchive*
        name: WasArchive
        nameWithType: FileInfoExtension.WasArchive
        qualifiedName: WizardWrx.FileInfoExtension.WasArchive
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.WasArchive
  WizardWrx.FileInfoExtension.WasReadOnly*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.WasReadOnly*
        name: WasReadOnly
        nameWithType: FileInfoExtension.WasReadOnly
        qualifiedName: WizardWrx.FileInfoExtension.WasReadOnly
      VB:
      - id: WizardWrx.FileInfoExtension.WasReadOnly*
        name: WasReadOnly
        nameWithType: FileInfoExtension.WasReadOnly
        qualifiedName: WizardWrx.FileInfoExtension.WasReadOnly
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.WasReadOnly
  WizardWrx.FileInfoExtension.WasHidden*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.WasHidden*
        name: WasHidden
        nameWithType: FileInfoExtension.WasHidden
        qualifiedName: WizardWrx.FileInfoExtension.WasHidden
      VB:
      - id: WizardWrx.FileInfoExtension.WasHidden*
        name: WasHidden
        nameWithType: FileInfoExtension.WasHidden
        qualifiedName: WizardWrx.FileInfoExtension.WasHidden
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.WasHidden
  WizardWrx.FileInfoExtension.WasSystem*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension.WasSystem*
        name: WasSystem
        nameWithType: FileInfoExtension.WasSystem
        qualifiedName: WizardWrx.FileInfoExtension.WasSystem
      VB:
      - id: WizardWrx.FileInfoExtension.WasSystem*
        name: WasSystem
        nameWithType: FileInfoExtension.WasSystem
        qualifiedName: WizardWrx.FileInfoExtension.WasSystem
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtension.WasSystem
  WizardWrx.FileInfoExtension:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtension
        name: FileInfoExtension
        nameWithType: FileInfoExtension
        qualifiedName: WizardWrx.FileInfoExtension
      VB:
      - id: WizardWrx.FileInfoExtension
        name: FileInfoExtension
        nameWithType: FileInfoExtension
        qualifiedName: WizardWrx.FileInfoExtension
    isDefinition: true
    commentId: T:WizardWrx.FileInfoExtension
  WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider):
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<T>
        nameWithType: StringExtensions.RenderEvenWhenNull<T>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<T>
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of T)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of T)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of T)
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.StringExtensions:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions
        name: StringExtensions
        nameWithType: StringExtensions
        qualifiedName: WizardWrx.StringExtensions
      VB:
      - id: WizardWrx.StringExtensions
        name: StringExtensions
        nameWithType: StringExtensions
        qualifiedName: WizardWrx.StringExtensions
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.StringExtensions
  ? WizardWrx.FileInfoExtension.enmInitialStatus.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<FileInfoExtension.enmInitialStatus>
        nameWithType: StringExtensions.RenderEvenWhenNull<FileInfoExtension.enmInitialStatus>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.FileInfoExtension.enmInitialStatus>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of FileInfoExtension.enmInitialStatus)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of FileInfoExtension.enmInitialStatus)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.FileInfoExtension.enmInitialStatus)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear*
        name: FileAttributeArchiveClear
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear*
        name: FileAttributeArchiveClear
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveClear
  WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate*
        name: FileAttributeArchiveReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate*
        name: FileAttributeArchiveReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveReinstate
  WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet*
        name: FileAttributeArchiveSet
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet*
        name: FileAttributeArchiveSet
        nameWithType: FileInfoExtensionMethods.FileAttributeArchiveSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeArchiveSet
  WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear*
        name: FileAttributeHiddenClear
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddenClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear*
        name: FileAttributeHiddenClear
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddenClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenClear
  WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate*
        name: FileAttributeHiddeneReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddeneReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate*
        name: FileAttributeHiddeneReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddeneReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddeneReinstate
  WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet*
        name: FileAttributeHiddenSet
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddenSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet*
        name: FileAttributeHiddenSet
        nameWithType: FileInfoExtensionMethods.FileAttributeHiddenSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeHiddenSet
  WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear*
        name: FileAttributeReadOnlyClear
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlyClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear*
        name: FileAttributeReadOnlyClear
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlyClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyClear
  WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate*
        name: FileAttributeReadOnlyReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlyReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate*
        name: FileAttributeReadOnlyReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlyReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlyReinstate
  WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet*
        name: FileAttributeReadOnlySet
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlySet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet*
        name: FileAttributeReadOnlySet
        nameWithType: FileInfoExtensionMethods.FileAttributeReadOnlySet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeReadOnlySet
  WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear*
        name: FileAttributeSystemClear
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear*
        name: FileAttributeSystemClear
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemClear
  WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate*
        name: FileAttributeSystemReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate*
        name: FileAttributeSystemReinstate
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemReinstate
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemReinstate
  WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet*
        name: FileAttributeSystemSet
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet*
        name: FileAttributeSystemSet
        nameWithType: FileInfoExtensionMethods.FileAttributeSystemSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeSystemSet
  System.IO.FileAttributes:
    name:
      CSharp:
      - id: System.IO.FileAttributes
        name: FileAttributes
        nameWithType: FileAttributes
        qualifiedName: System.IO.FileAttributes
        isExternal: true
      VB:
      - id: System.IO.FileAttributes
        name: FileAttributes
        nameWithType: FileAttributes
        qualifiedName: System.IO.FileAttributes
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.FileAttributes
  WizardWrx.FileInfoExtensionMethods.FileAttributeClear*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeClear*
        name: FileAttributeClear
        nameWithType: FileInfoExtensionMethods.FileAttributeClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeClear
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeClear*
        name: FileAttributeClear
        nameWithType: FileInfoExtensionMethods.FileAttributeClear
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeClear
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeClear
  WizardWrx.FileInfoExtensionMethods.FileAttributeSet*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSet*
        name: FileAttributeSet
        nameWithType: FileInfoExtensionMethods.FileAttributeSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSet
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileAttributeSet*
        name: FileAttributeSet
        nameWithType: FileInfoExtensionMethods.FileAttributeSet
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileAttributeSet
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.FileAttributeSet
  WizardWrx.FileInfoExtensionMethods.FileDetailsToShow:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
        name: FileInfoExtensionMethods.FileDetailsToShow
        nameWithType: FileInfoExtensionMethods.FileDetailsToShow
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
        name: FileInfoExtensionMethods.FileDetailsToShow
        nameWithType: FileInfoExtensionMethods.FileDetailsToShow
        qualifiedName: WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.FileInfoExtensionMethods.FileDetailsToShow
  WizardWrx.FileInfoExtensionMethods.ShowFileDetails*:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods.ShowFileDetails*
        name: ShowFileDetails
        nameWithType: FileInfoExtensionMethods.ShowFileDetails
        qualifiedName: WizardWrx.FileInfoExtensionMethods.ShowFileDetails
      VB:
      - id: WizardWrx.FileInfoExtensionMethods.ShowFileDetails*
        name: ShowFileDetails
        nameWithType: FileInfoExtensionMethods.ShowFileDetails
        qualifiedName: WizardWrx.FileInfoExtensionMethods.ShowFileDetails
    isDefinition: true
    commentId: Overload:WizardWrx.FileInfoExtensionMethods.ShowFileDetails
  WizardWrx.FileInfoExtensionMethods:
    name:
      CSharp:
      - id: WizardWrx.FileInfoExtensionMethods
        name: FileInfoExtensionMethods
        nameWithType: FileInfoExtensionMethods
        qualifiedName: WizardWrx.FileInfoExtensionMethods
      VB:
      - id: WizardWrx.FileInfoExtensionMethods
        name: FileInfoExtensionMethods
        nameWithType: FileInfoExtensionMethods
        qualifiedName: WizardWrx.FileInfoExtensionMethods
    isDefinition: true
    commentId: T:WizardWrx.FileInfoExtensionMethods
  ? WizardWrx.FileInfoExtensionMethods.FileDetailsToShow.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<FileInfoExtensionMethods.FileDetailsToShow>
        nameWithType: StringExtensions.RenderEvenWhenNull<FileInfoExtensionMethods.FileDetailsToShow>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.FileInfoExtensionMethods.FileDetailsToShow>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of FileInfoExtensionMethods.FileDetailsToShow)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of FileInfoExtensionMethods.FileDetailsToShow)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.FileInfoExtensionMethods.FileDetailsToShow)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  System.FlagsAttribute:
    name:
      CSharp:
      - id: System.FlagsAttribute
        name: FlagsAttribute
        nameWithType: FlagsAttribute
        qualifiedName: System.FlagsAttribute
        isExternal: true
      VB:
      - id: System.FlagsAttribute
        name: FlagsAttribute
        nameWithType: FlagsAttribute
        qualifiedName: System.FlagsAttribute
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.FlagsAttribute
  System.FlagsAttribute.#ctor:
    name:
      CSharp:
      - id: System.FlagsAttribute.#ctor
        name: FlagsAttribute
        nameWithType: FlagsAttribute.FlagsAttribute
        qualifiedName: System.FlagsAttribute.FlagsAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.FlagsAttribute.#ctor
        name: FlagsAttribute
        nameWithType: FlagsAttribute.FlagsAttribute
        qualifiedName: System.FlagsAttribute.FlagsAttribute
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.FlagsAttribute
    commentId: M:System.FlagsAttribute.#ctor
  WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER:
    commentId: F:WizardWrx.FileNameTricks.OS_DRIVE_PATH_DELIMITER
  WizardWrx.FileNameTricks.UNC_SERVER_DELIM:
    commentId: F:WizardWrx.FileNameTricks.UNC_SERVER_DELIM
  WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE:
    commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_MULTIPLE
  WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE:
    commentId: F:WizardWrx.FileNameTricks.OS_WILD_CARD_SINGLE
  System.Char:
    name:
      CSharp:
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
      VB:
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Char
  WizardWrx.FileNameTricks.OS_EXTENSION_DELIM:
    commentId: F:WizardWrx.FileNameTricks.OS_EXTENSION_DELIM
  WizardWrx.FileNameTricks.EnsureHasTerminalBackslash*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash*
        name: EnsureHasTerminalBackslash
        nameWithType: FileNameTricks.EnsureHasTerminalBackslash
        qualifiedName: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash
      VB:
      - id: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash*
        name: EnsureHasTerminalBackslash
        nameWithType: FileNameTricks.EnsureHasTerminalBackslash
        qualifiedName: WizardWrx.FileNameTricks.EnsureHasTerminalBackslash
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.EnsureHasTerminalBackslash
  WizardWrx.FileNameTricks.EnsureNoTerminalBackslash*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash*
        name: EnsureNoTerminalBackslash
        nameWithType: FileNameTricks.EnsureNoTerminalBackslash
        qualifiedName: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash
      VB:
      - id: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash*
        name: EnsureNoTerminalBackslash
        nameWithType: FileNameTricks.EnsureNoTerminalBackslash
        qualifiedName: WizardWrx.FileNameTricks.EnsureNoTerminalBackslash
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.EnsureNoTerminalBackslash
  WizardWrx.FileNameTricks.PathAddBackslash*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathAddBackslash*
        name: PathAddBackslash
        nameWithType: FileNameTricks.PathAddBackslash
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslash
      VB:
      - id: WizardWrx.FileNameTricks.PathAddBackslash*
        name: PathAddBackslash
        nameWithType: FileNameTricks.PathAddBackslash
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslash
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathAddBackslash
  WizardWrx.FileNameTricks.PathAddBackslashDeprecated1*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1*
        name: PathAddBackslashDeprecated1
        nameWithType: FileNameTricks.PathAddBackslashDeprecated1
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1
      VB:
      - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1*
        name: PathAddBackslashDeprecated1
        nameWithType: FileNameTricks.PathAddBackslashDeprecated1
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslashDeprecated1
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathAddBackslashDeprecated1
  WizardWrx.FileNameTricks.PathAddBackslashDeprecated2*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2*
        name: PathAddBackslashDeprecated2
        nameWithType: FileNameTricks.PathAddBackslashDeprecated2
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2
      VB:
      - id: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2*
        name: PathAddBackslashDeprecated2
        nameWithType: FileNameTricks.PathAddBackslashDeprecated2
        qualifiedName: WizardWrx.FileNameTricks.PathAddBackslashDeprecated2
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathAddBackslashDeprecated2
  WizardWrx.FileNameTricks.PathMakeRelative*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathMakeRelative*
        name: PathMakeRelative
        nameWithType: FileNameTricks.PathMakeRelative
        qualifiedName: WizardWrx.FileNameTricks.PathMakeRelative
      VB:
      - id: WizardWrx.FileNameTricks.PathMakeRelative*
        name: PathMakeRelative
        nameWithType: FileNameTricks.PathMakeRelative
        qualifiedName: WizardWrx.FileNameTricks.PathMakeRelative
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathMakeRelative
  WizardWrx.FileNameTricks.PathRemoveBackslash*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathRemoveBackslash*
        name: PathRemoveBackslash
        nameWithType: FileNameTricks.PathRemoveBackslash
        qualifiedName: WizardWrx.FileNameTricks.PathRemoveBackslash
      VB:
      - id: WizardWrx.FileNameTricks.PathRemoveBackslash*
        name: PathRemoveBackslash
        nameWithType: FileNameTricks.PathRemoveBackslash
        qualifiedName: WizardWrx.FileNameTricks.PathRemoveBackslash
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathRemoveBackslash
  WizardWrx.FileNameTricks.TerminaBackslash:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.TerminaBackslash
        name: FileNameTricks.TerminaBackslash
        nameWithType: FileNameTricks.TerminaBackslash
        qualifiedName: WizardWrx.FileNameTricks.TerminaBackslash
      VB:
      - id: WizardWrx.FileNameTricks.TerminaBackslash
        name: FileNameTricks.TerminaBackslash
        nameWithType: FileNameTricks.TerminaBackslash
        qualifiedName: WizardWrx.FileNameTricks.TerminaBackslash
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.FileNameTricks.TerminaBackslash
  WizardWrx.FileNameTricks.FileDirName*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.FileDirName*
        name: FileDirName
        nameWithType: FileNameTricks.FileDirName
        qualifiedName: WizardWrx.FileNameTricks.FileDirName
      VB:
      - id: WizardWrx.FileNameTricks.FileDirName*
        name: FileDirName
        nameWithType: FileNameTricks.FileDirName
        qualifiedName: WizardWrx.FileNameTricks.FileDirName
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.FileDirName
  WizardWrx.FileNameTricks.FileExtn*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.FileExtn*
        name: FileExtn
        nameWithType: FileNameTricks.FileExtn
        qualifiedName: WizardWrx.FileNameTricks.FileExtn
      VB:
      - id: WizardWrx.FileNameTricks.FileExtn*
        name: FileExtn
        nameWithType: FileNameTricks.FileExtn
        qualifiedName: WizardWrx.FileNameTricks.FileExtn
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.FileExtn
  WizardWrx.FileNameTricks.FQFBasename*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.FQFBasename*
        name: FQFBasename
        nameWithType: FileNameTricks.FQFBasename
        qualifiedName: WizardWrx.FileNameTricks.FQFBasename
      VB:
      - id: WizardWrx.FileNameTricks.FQFBasename*
        name: FQFBasename
        nameWithType: FileNameTricks.FQFBasename
        qualifiedName: WizardWrx.FileNameTricks.FQFBasename
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.FQFBasename
  WizardWrx.FileNameTricks.MakeFQFN*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.MakeFQFN*
        name: MakeFQFN
        nameWithType: FileNameTricks.MakeFQFN
        qualifiedName: WizardWrx.FileNameTricks.MakeFQFN
      VB:
      - id: WizardWrx.FileNameTricks.MakeFQFN*
        name: MakeFQFN
        nameWithType: FileNameTricks.MakeFQFN
        qualifiedName: WizardWrx.FileNameTricks.MakeFQFN
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.MakeFQFN
  WizardWrx.FileNameTricks.PathFixup*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.PathFixup*
        name: PathFixup
        nameWithType: FileNameTricks.PathFixup
        qualifiedName: WizardWrx.FileNameTricks.PathFixup
      VB:
      - id: WizardWrx.FileNameTricks.PathFixup*
        name: PathFixup
        nameWithType: FileNameTricks.PathFixup
        qualifiedName: WizardWrx.FileNameTricks.PathFixup
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.PathFixup
  WizardWrx.FileNameTricks.UQFBasename*:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks.UQFBasename*
        name: UQFBasename
        nameWithType: FileNameTricks.UQFBasename
        qualifiedName: WizardWrx.FileNameTricks.UQFBasename
      VB:
      - id: WizardWrx.FileNameTricks.UQFBasename*
        name: UQFBasename
        nameWithType: FileNameTricks.UQFBasename
        qualifiedName: WizardWrx.FileNameTricks.UQFBasename
    isDefinition: true
    commentId: Overload:WizardWrx.FileNameTricks.UQFBasename
  WizardWrx.FileNameTricks:
    name:
      CSharp:
      - id: WizardWrx.FileNameTricks
        name: FileNameTricks
        nameWithType: FileNameTricks
        qualifiedName: WizardWrx.FileNameTricks
      VB:
      - id: WizardWrx.FileNameTricks
        name: FileNameTricks
        nameWithType: FileNameTricks
        qualifiedName: WizardWrx.FileNameTricks
    isDefinition: true
    commentId: T:WizardWrx.FileNameTricks
  WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash):
    commentId: M:WizardWrx.FileNameTricks.FileDirName(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
  WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash):
    commentId: M:WizardWrx.FileNameTricks.PathFixup(System.String,WizardWrx.FileNameTricks.TerminaBackslash)
  ? WizardWrx.FileNameTricks.TerminaBackslash.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<FileNameTricks.TerminaBackslash>
        nameWithType: StringExtensions.RenderEvenWhenNull<FileNameTricks.TerminaBackslash>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.FileNameTricks.TerminaBackslash>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of FileNameTricks.TerminaBackslash)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of FileNameTricks.TerminaBackslash)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.FileNameTricks.TerminaBackslash)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.GenericSingletonBase`1.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.#ctor*
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase<T>.GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase<T>.GenericSingletonBase
      VB:
      - id: WizardWrx.GenericSingletonBase`1.#ctor*
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase(Of T).GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase(Of T).GenericSingletonBase
    isDefinition: true
    commentId: Overload:WizardWrx.GenericSingletonBase`1.#ctor
  T:
    name:
      CSharp:
      - name: T
        nameWithType: T
        qualifiedName: T
      VB:
      - name: T
        nameWithType: T
        qualifiedName: T
    isDefinition: true
  '{T}':
    name:
      CSharp:
      - name: T
        nameWithType: T
        qualifiedName: T
      VB:
      - name: T
        nameWithType: T
        qualifiedName: T
    isDefinition: false
    definition: T
    commentId: '!:T'
  WizardWrx.GenericSingletonBase`1.TheOnlyInstance*:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance*
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase<T>.TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase<T>.TheOnlyInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance*
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase(Of T).TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of T).TheOnlyInstance
    isDefinition: true
    commentId: Overload:WizardWrx.GenericSingletonBase`1.TheOnlyInstance
  WizardWrx.GenericSingletonBase`1.GetTheSingleInstance*:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.GetTheSingleInstance*
        name: GetTheSingleInstance
        nameWithType: GenericSingletonBase<T>.GetTheSingleInstance
        qualifiedName: WizardWrx.GenericSingletonBase<T>.GetTheSingleInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.GetTheSingleInstance*
        name: GetTheSingleInstance
        nameWithType: GenericSingletonBase(Of T).GetTheSingleInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of T).GetTheSingleInstance
    isDefinition: true
    commentId: Overload:WizardWrx.GenericSingletonBase`1.GetTheSingleInstance
  WizardWrx.GenericSingletonBase`1:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: WizardWrx.GenericSingletonBase`1
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:WizardWrx.GenericSingletonBase`1
  System.NullReferenceException:
    commentId: T:System.NullReferenceException
  WizardWrx.ListHelpers.CompareResult:
    name:
      CSharp:
      - id: WizardWrx.ListHelpers.CompareResult
        name: ListHelpers.CompareResult
        nameWithType: ListHelpers.CompareResult
        qualifiedName: WizardWrx.ListHelpers.CompareResult
      VB:
      - id: WizardWrx.ListHelpers.CompareResult
        name: ListHelpers.CompareResult
        nameWithType: ListHelpers.CompareResult
        qualifiedName: WizardWrx.ListHelpers.CompareResult
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ListHelpers.CompareResult
  WizardWrx.ListHelpers.CompareTwoOfAKind*:
    name:
      CSharp:
      - id: WizardWrx.ListHelpers.CompareTwoOfAKind*
        name: CompareTwoOfAKind
        nameWithType: ListHelpers.CompareTwoOfAKind
        qualifiedName: WizardWrx.ListHelpers.CompareTwoOfAKind
      VB:
      - id: WizardWrx.ListHelpers.CompareTwoOfAKind*
        name: CompareTwoOfAKind
        nameWithType: ListHelpers.CompareTwoOfAKind
        qualifiedName: WizardWrx.ListHelpers.CompareTwoOfAKind
    isDefinition: true
    commentId: Overload:WizardWrx.ListHelpers.CompareTwoOfAKind
  '{T}[]':
    name:
      CSharp:
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.ListHelpers.MergeNewItemsIntoArray*:
    name:
      CSharp:
      - id: WizardWrx.ListHelpers.MergeNewItemsIntoArray*
        name: MergeNewItemsIntoArray
        nameWithType: ListHelpers.MergeNewItemsIntoArray
        qualifiedName: WizardWrx.ListHelpers.MergeNewItemsIntoArray
      VB:
      - id: WizardWrx.ListHelpers.MergeNewItemsIntoArray*
        name: MergeNewItemsIntoArray
        nameWithType: ListHelpers.MergeNewItemsIntoArray
        qualifiedName: WizardWrx.ListHelpers.MergeNewItemsIntoArray
    isDefinition: true
    commentId: Overload:WizardWrx.ListHelpers.MergeNewItemsIntoArray
  WizardWrx.ListHelpers:
    name:
      CSharp:
      - id: WizardWrx.ListHelpers
        name: ListHelpers
        nameWithType: ListHelpers
        qualifiedName: WizardWrx.ListHelpers
      VB:
      - id: WizardWrx.ListHelpers
        name: ListHelpers
        nameWithType: ListHelpers
        qualifiedName: WizardWrx.ListHelpers
    isDefinition: true
    commentId: T:WizardWrx.ListHelpers
  ? WizardWrx.ListHelpers.CompareResult.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<ListHelpers.CompareResult>
        nameWithType: StringExtensions.RenderEvenWhenNull<ListHelpers.CompareResult>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.ListHelpers.CompareResult>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of ListHelpers.CompareResult)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of ListHelpers.CompareResult)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.ListHelpers.CompareResult)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsLastForIterationEQ(System.Int32,System.Int32)
  WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsLastForIterationGE(System.Int32,System.Int32)
  WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsLastForIterationGT(System.Int32,System.Int32)
  WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsLastForIterationLE(System.Int32,System.Int32)
  WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsLastForIterationLT(System.Int32,System.Int32)
  WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsNextForIteration(System.Int32,System.Int32)
  WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.MoreForIterationsToComeEQ(System.Int32,System.Int32)
  WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.MoreForIterationsToComeGE(System.Int32,System.Int32)
  WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.MoreForIterationsToComeGT(System.Int32,System.Int32)
  WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.MoreForIterationsToComeLE(System.Int32,System.Int32)
  WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.MoreForIterationsToComeLT(System.Int32,System.Int32)
  WizardWrx.Logic.IsFirstForIteration*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsFirstForIteration*
        name: IsFirstForIteration
        nameWithType: Logic.IsFirstForIteration
        qualifiedName: WizardWrx.Logic.IsFirstForIteration
      VB:
      - id: WizardWrx.Logic.IsFirstForIteration*
        name: IsFirstForIteration
        nameWithType: Logic.IsFirstForIteration
        qualifiedName: WizardWrx.Logic.IsFirstForIteration
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsFirstForIteration
  WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32):
    commentId: M:WizardWrx.Logic.IsFirstForIteration(System.Int32,System.Int32)
  WizardWrx.Logic.IsLastForIterationEQ*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsLastForIterationEQ*
        name: IsLastForIterationEQ
        nameWithType: Logic.IsLastForIterationEQ
        qualifiedName: WizardWrx.Logic.IsLastForIterationEQ
      VB:
      - id: WizardWrx.Logic.IsLastForIterationEQ*
        name: IsLastForIterationEQ
        nameWithType: Logic.IsLastForIterationEQ
        qualifiedName: WizardWrx.Logic.IsLastForIterationEQ
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsLastForIterationEQ
  WizardWrx.Logic.IsLastForIterationGE*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsLastForIterationGE*
        name: IsLastForIterationGE
        nameWithType: Logic.IsLastForIterationGE
        qualifiedName: WizardWrx.Logic.IsLastForIterationGE
      VB:
      - id: WizardWrx.Logic.IsLastForIterationGE*
        name: IsLastForIterationGE
        nameWithType: Logic.IsLastForIterationGE
        qualifiedName: WizardWrx.Logic.IsLastForIterationGE
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsLastForIterationGE
  WizardWrx.Logic.IsLastForIterationGT*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsLastForIterationGT*
        name: IsLastForIterationGT
        nameWithType: Logic.IsLastForIterationGT
        qualifiedName: WizardWrx.Logic.IsLastForIterationGT
      VB:
      - id: WizardWrx.Logic.IsLastForIterationGT*
        name: IsLastForIterationGT
        nameWithType: Logic.IsLastForIterationGT
        qualifiedName: WizardWrx.Logic.IsLastForIterationGT
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsLastForIterationGT
  WizardWrx.Logic.IsLastForIterationLE*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsLastForIterationLE*
        name: IsLastForIterationLE
        nameWithType: Logic.IsLastForIterationLE
        qualifiedName: WizardWrx.Logic.IsLastForIterationLE
      VB:
      - id: WizardWrx.Logic.IsLastForIterationLE*
        name: IsLastForIterationLE
        nameWithType: Logic.IsLastForIterationLE
        qualifiedName: WizardWrx.Logic.IsLastForIterationLE
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsLastForIterationLE
  WizardWrx.Logic.IsLastForIterationLT*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsLastForIterationLT*
        name: IsLastForIterationLT
        nameWithType: Logic.IsLastForIterationLT
        qualifiedName: WizardWrx.Logic.IsLastForIterationLT
      VB:
      - id: WizardWrx.Logic.IsLastForIterationLT*
        name: IsLastForIterationLT
        nameWithType: Logic.IsLastForIterationLT
        qualifiedName: WizardWrx.Logic.IsLastForIterationLT
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsLastForIterationLT
  WizardWrx.Logic.IsNextForIteration*:
    name:
      CSharp:
      - id: WizardWrx.Logic.IsNextForIteration*
        name: IsNextForIteration
        nameWithType: Logic.IsNextForIteration
        qualifiedName: WizardWrx.Logic.IsNextForIteration
      VB:
      - id: WizardWrx.Logic.IsNextForIteration*
        name: IsNextForIteration
        nameWithType: Logic.IsNextForIteration
        qualifiedName: WizardWrx.Logic.IsNextForIteration
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.IsNextForIteration
  WizardWrx.Logic.MoreForIterationsToComeEQ*:
    name:
      CSharp:
      - id: WizardWrx.Logic.MoreForIterationsToComeEQ*
        name: MoreForIterationsToComeEQ
        nameWithType: Logic.MoreForIterationsToComeEQ
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeEQ
      VB:
      - id: WizardWrx.Logic.MoreForIterationsToComeEQ*
        name: MoreForIterationsToComeEQ
        nameWithType: Logic.MoreForIterationsToComeEQ
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeEQ
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.MoreForIterationsToComeEQ
  WizardWrx.Logic.MoreForIterationsToComeGE*:
    name:
      CSharp:
      - id: WizardWrx.Logic.MoreForIterationsToComeGE*
        name: MoreForIterationsToComeGE
        nameWithType: Logic.MoreForIterationsToComeGE
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeGE
      VB:
      - id: WizardWrx.Logic.MoreForIterationsToComeGE*
        name: MoreForIterationsToComeGE
        nameWithType: Logic.MoreForIterationsToComeGE
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeGE
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.MoreForIterationsToComeGE
  WizardWrx.Logic.MoreForIterationsToComeGT*:
    name:
      CSharp:
      - id: WizardWrx.Logic.MoreForIterationsToComeGT*
        name: MoreForIterationsToComeGT
        nameWithType: Logic.MoreForIterationsToComeGT
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeGT
      VB:
      - id: WizardWrx.Logic.MoreForIterationsToComeGT*
        name: MoreForIterationsToComeGT
        nameWithType: Logic.MoreForIterationsToComeGT
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeGT
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.MoreForIterationsToComeGT
  WizardWrx.Logic.MoreForIterationsToComeLE*:
    name:
      CSharp:
      - id: WizardWrx.Logic.MoreForIterationsToComeLE*
        name: MoreForIterationsToComeLE
        nameWithType: Logic.MoreForIterationsToComeLE
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeLE
      VB:
      - id: WizardWrx.Logic.MoreForIterationsToComeLE*
        name: MoreForIterationsToComeLE
        nameWithType: Logic.MoreForIterationsToComeLE
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeLE
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.MoreForIterationsToComeLE
  WizardWrx.Logic.MoreForIterationsToComeLT*:
    name:
      CSharp:
      - id: WizardWrx.Logic.MoreForIterationsToComeLT*
        name: MoreForIterationsToComeLT
        nameWithType: Logic.MoreForIterationsToComeLT
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeLT
      VB:
      - id: WizardWrx.Logic.MoreForIterationsToComeLT*
        name: MoreForIterationsToComeLT
        nameWithType: Logic.MoreForIterationsToComeLT
        qualifiedName: WizardWrx.Logic.MoreForIterationsToComeLT
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.MoreForIterationsToComeLT
  WizardWrx.Logic.Unless*:
    name:
      CSharp:
      - id: WizardWrx.Logic.Unless*
        name: Unless
        nameWithType: Logic.Unless
        qualifiedName: WizardWrx.Logic.Unless
      VB:
      - id: WizardWrx.Logic.Unless*
        name: Unless
        nameWithType: Logic.Unless
        qualifiedName: WizardWrx.Logic.Unless
    isDefinition: true
    commentId: Overload:WizardWrx.Logic.Unless
  WizardWrx.Logic:
    name:
      CSharp:
      - id: WizardWrx.Logic
        name: Logic
        nameWithType: Logic
        qualifiedName: WizardWrx.Logic
      VB:
      - id: WizardWrx.Logic
        name: Logic
        nameWithType: Logic
        qualifiedName: WizardWrx.Logic
    isDefinition: true
    commentId: T:WizardWrx.Logic
  System.Double:
    name:
      CSharp:
      - id: System.Double
        name: Double
        nameWithType: Double
        qualifiedName: System.Double
        isExternal: true
      VB:
      - id: System.Double
        name: Double
        nameWithType: Double
        qualifiedName: System.Double
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Double
  WizardWrx.NumberFormatters.DecimalNumber*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.DecimalNumber*
        name: DecimalNumber
        nameWithType: NumberFormatters.DecimalNumber
        qualifiedName: WizardWrx.NumberFormatters.DecimalNumber
      VB:
      - id: WizardWrx.NumberFormatters.DecimalNumber*
        name: DecimalNumber
        nameWithType: NumberFormatters.DecimalNumber
        qualifiedName: WizardWrx.NumberFormatters.DecimalNumber
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.DecimalNumber
  System.Single:
    name:
      CSharp:
      - id: System.Single
        name: Single
        nameWithType: Single
        qualifiedName: System.Single
        isExternal: true
      VB:
      - id: System.Single
        name: Single
        nameWithType: Single
        qualifiedName: System.Single
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Single
  WizardWrx.NumberFormatters.DollarsAndCents*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.DollarsAndCents*
        name: DollarsAndCents
        nameWithType: NumberFormatters.DollarsAndCents
        qualifiedName: WizardWrx.NumberFormatters.DollarsAndCents
      VB:
      - id: WizardWrx.NumberFormatters.DollarsAndCents*
        name: DollarsAndCents
        nameWithType: NumberFormatters.DollarsAndCents
        qualifiedName: WizardWrx.NumberFormatters.DollarsAndCents
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.DollarsAndCents
  WizardWrx.NumberFormatters.Hexadecimal2*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.Hexadecimal2*
        name: Hexadecimal2
        nameWithType: NumberFormatters.Hexadecimal2
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal2
      VB:
      - id: WizardWrx.NumberFormatters.Hexadecimal2*
        name: Hexadecimal2
        nameWithType: NumberFormatters.Hexadecimal2
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal2
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.Hexadecimal2
  WizardWrx.NumberFormatters.Hexadecimal4*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.Hexadecimal4*
        name: Hexadecimal4
        nameWithType: NumberFormatters.Hexadecimal4
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal4
      VB:
      - id: WizardWrx.NumberFormatters.Hexadecimal4*
        name: Hexadecimal4
        nameWithType: NumberFormatters.Hexadecimal4
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal4
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.Hexadecimal4
  WizardWrx.NumberFormatters.Hexadecimal8*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.Hexadecimal8*
        name: Hexadecimal8
        nameWithType: NumberFormatters.Hexadecimal8
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal8
      VB:
      - id: WizardWrx.NumberFormatters.Hexadecimal8*
        name: Hexadecimal8
        nameWithType: NumberFormatters.Hexadecimal8
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal8
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.Hexadecimal8
  System.Int64:
    name:
      CSharp:
      - id: System.Int64
        name: Int64
        nameWithType: Int64
        qualifiedName: System.Int64
        isExternal: true
      VB:
      - id: System.Int64
        name: Int64
        nameWithType: Int64
        qualifiedName: System.Int64
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Int64
  WizardWrx.NumberFormatters.Hexadecimal16*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.Hexadecimal16*
        name: Hexadecimal16
        nameWithType: NumberFormatters.Hexadecimal16
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal16
      VB:
      - id: WizardWrx.NumberFormatters.Hexadecimal16*
        name: Hexadecimal16
        nameWithType: NumberFormatters.Hexadecimal16
        qualifiedName: WizardWrx.NumberFormatters.Hexadecimal16
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.Hexadecimal16
  WizardWrx.NumberFormatters.Integer*:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters.Integer*
        name: Integer
        nameWithType: NumberFormatters.Integer
        qualifiedName: WizardWrx.NumberFormatters.Integer
      VB:
      - id: WizardWrx.NumberFormatters.Integer*
        name: Integer
        nameWithType: NumberFormatters.Integer
        qualifiedName: WizardWrx.NumberFormatters.Integer
    isDefinition: true
    commentId: Overload:WizardWrx.NumberFormatters.Integer
  WizardWrx.NumberFormatters:
    name:
      CSharp:
      - id: WizardWrx.NumberFormatters
        name: NumberFormatters
        nameWithType: NumberFormatters
        qualifiedName: WizardWrx.NumberFormatters
      VB:
      - id: WizardWrx.NumberFormatters
        name: NumberFormatters
        nameWithType: NumberFormatters
        qualifiedName: WizardWrx.NumberFormatters
    isDefinition: true
    commentId: T:WizardWrx.NumberFormatters
  System.Exception:
    name:
      CSharp:
      - id: System.Exception
        name: Exception
        nameWithType: Exception
        qualifiedName: System.Exception
        isExternal: true
      VB:
      - id: System.Exception
        name: Exception
        nameWithType: Exception
        qualifiedName: System.Exception
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Exception
  System.Exception.GetBaseException:
    name:
      CSharp:
      - id: System.Exception.GetBaseException
        name: GetBaseException
        nameWithType: Exception.GetBaseException
        qualifiedName: System.Exception.GetBaseException
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetBaseException
        name: GetBaseException
        nameWithType: Exception.GetBaseException
        qualifiedName: System.Exception.GetBaseException
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetBaseException
  System.Exception.ToString:
    name:
      CSharp:
      - id: System.Exception.ToString
        name: ToString
        nameWithType: Exception.ToString
        qualifiedName: System.Exception.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.ToString
        name: ToString
        nameWithType: Exception.ToString
        qualifiedName: System.Exception.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.ToString
  System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext):
    name:
      CSharp:
      - id: System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: Exception.GetObjectData
        qualifiedName: System.Exception.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
        name: GetObjectData
        nameWithType: Exception.GetObjectData
        qualifiedName: System.Exception.GetObjectData
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  System.Exception.GetType:
    name:
      CSharp:
      - id: System.Exception.GetType
        name: GetType
        nameWithType: Exception.GetType
        qualifiedName: System.Exception.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Exception.GetType
        name: GetType
        nameWithType: Exception.GetType
        qualifiedName: System.Exception.GetType
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.Exception
    commentId: M:System.Exception.GetType
  System.Exception.Message:
    name:
      CSharp:
      - id: System.Exception.Message
        name: Message
        nameWithType: Exception.Message
        qualifiedName: System.Exception.Message
        isExternal: true
      VB:
      - id: System.Exception.Message
        name: Message
        nameWithType: Exception.Message
        qualifiedName: System.Exception.Message
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Message
  System.Exception.Data:
    name:
      CSharp:
      - id: System.Exception.Data
        name: Data
        nameWithType: Exception.Data
        qualifiedName: System.Exception.Data
        isExternal: true
      VB:
      - id: System.Exception.Data
        name: Data
        nameWithType: Exception.Data
        qualifiedName: System.Exception.Data
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Data
  System.Exception.InnerException:
    name:
      CSharp:
      - id: System.Exception.InnerException
        name: InnerException
        nameWithType: Exception.InnerException
        qualifiedName: System.Exception.InnerException
        isExternal: true
      VB:
      - id: System.Exception.InnerException
        name: InnerException
        nameWithType: Exception.InnerException
        qualifiedName: System.Exception.InnerException
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.InnerException
  System.Exception.HelpLink:
    name:
      CSharp:
      - id: System.Exception.HelpLink
        name: HelpLink
        nameWithType: Exception.HelpLink
        qualifiedName: System.Exception.HelpLink
        isExternal: true
      VB:
      - id: System.Exception.HelpLink
        name: HelpLink
        nameWithType: Exception.HelpLink
        qualifiedName: System.Exception.HelpLink
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.HelpLink
  System.Exception.HResult:
    name:
      CSharp:
      - id: System.Exception.HResult
        name: HResult
        nameWithType: Exception.HResult
        qualifiedName: System.Exception.HResult
        isExternal: true
      VB:
      - id: System.Exception.HResult
        name: HResult
        nameWithType: Exception.HResult
        qualifiedName: System.Exception.HResult
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.HResult
  System.Runtime.Serialization:
    name:
      CSharp:
      - name: System.Runtime.Serialization
        nameWithType: System.Runtime.Serialization
        qualifiedName: System.Runtime.Serialization
        isExternal: true
      VB:
      - name: System.Runtime.Serialization
        nameWithType: System.Runtime.Serialization
        qualifiedName: System.Runtime.Serialization
    isDefinition: true
    commentId: N:System.Runtime.Serialization
  System.Runtime.Serialization.ISerializable:
    name:
      CSharp:
      - id: System.Runtime.Serialization.ISerializable
        name: ISerializable
        nameWithType: ISerializable
        qualifiedName: System.Runtime.Serialization.ISerializable
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.ISerializable
        name: ISerializable
        nameWithType: ISerializable
        qualifiedName: System.Runtime.Serialization.ISerializable
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.ISerializable
  System.Runtime.InteropServices:
    name:
      CSharp:
      - name: System.Runtime.InteropServices
        nameWithType: System.Runtime.InteropServices
        qualifiedName: System.Runtime.InteropServices
        isExternal: true
      VB:
      - name: System.Runtime.InteropServices
        nameWithType: System.Runtime.InteropServices
        qualifiedName: System.Runtime.InteropServices
    isDefinition: true
    commentId: N:System.Runtime.InteropServices
  System.Runtime.InteropServices._Exception:
    name:
      CSharp:
      - id: System.Runtime.InteropServices._Exception
        name: _Exception
        nameWithType: _Exception
        qualifiedName: System.Runtime.InteropServices._Exception
        isExternal: true
      VB:
      - id: System.Runtime.InteropServices._Exception
        name: _Exception
        nameWithType: _Exception
        qualifiedName: System.Runtime.InteropServices._Exception
        isExternal: true
    isDefinition: true
    parent: System.Runtime.InteropServices
    commentId: T:System.Runtime.InteropServices._Exception
  WizardWrx.RecoveredException.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.RecoveredException.#ctor*
        name: RecoveredException
        nameWithType: RecoveredException.RecoveredException
        qualifiedName: WizardWrx.RecoveredException.RecoveredException
      VB:
      - id: WizardWrx.RecoveredException.#ctor*
        name: RecoveredException
        nameWithType: RecoveredException.RecoveredException
        qualifiedName: WizardWrx.RecoveredException.RecoveredException
    isDefinition: true
    commentId: Overload:WizardWrx.RecoveredException.#ctor
  System.Runtime.Serialization.SerializationInfo:
    name:
      CSharp:
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.SerializationInfo
        name: SerializationInfo
        nameWithType: SerializationInfo
        qualifiedName: System.Runtime.Serialization.SerializationInfo
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.SerializationInfo
  System.Runtime.Serialization.StreamingContext:
    name:
      CSharp:
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
      VB:
      - id: System.Runtime.Serialization.StreamingContext
        name: StreamingContext
        nameWithType: StreamingContext
        qualifiedName: System.Runtime.Serialization.StreamingContext
        isExternal: true
    isDefinition: true
    parent: System.Runtime.Serialization
    commentId: T:System.Runtime.Serialization.StreamingContext
  System.Exception.Source:
    name:
      CSharp:
      - id: System.Exception.Source
        name: Source
        nameWithType: Exception.Source
        qualifiedName: System.Exception.Source
        isExternal: true
      VB:
      - id: System.Exception.Source
        name: Source
        nameWithType: Exception.Source
        qualifiedName: System.Exception.Source
        isExternal: true
    isDefinition: true
    parent: System.Exception
    commentId: P:System.Exception.Source
  WizardWrx.RecoveredException.Source*:
    name:
      CSharp:
      - id: WizardWrx.RecoveredException.Source*
        name: Source
        nameWithType: RecoveredException.Source
        qualifiedName: WizardWrx.RecoveredException.Source
      VB:
      - id: WizardWrx.RecoveredException.Source*
        name: Source
        nameWithType: RecoveredException.Source
        qualifiedName: WizardWrx.RecoveredException.Source
    isDefinition: true
    commentId: Overload:WizardWrx.RecoveredException.Source
  WizardWrx.RecoveredException.StackTrace*:
    name:
      CSharp:
      - id: WizardWrx.RecoveredException.StackTrace*
        name: StackTrace
        nameWithType: RecoveredException.StackTrace
        qualifiedName: WizardWrx.RecoveredException.StackTrace
      VB:
      - id: WizardWrx.RecoveredException.StackTrace*
        name: StackTrace
        nameWithType: RecoveredException.StackTrace
        qualifiedName: WizardWrx.RecoveredException.StackTrace
    isDefinition: true
    commentId: Overload:WizardWrx.RecoveredException.StackTrace
  WizardWrx.RecoveredException.TargetSite*:
    name:
      CSharp:
      - id: WizardWrx.RecoveredException.TargetSite*
        name: TargetSite
        nameWithType: RecoveredException.TargetSite
        qualifiedName: WizardWrx.RecoveredException.TargetSite
      VB:
      - id: WizardWrx.RecoveredException.TargetSite*
        name: TargetSite
        nameWithType: RecoveredException.TargetSite
        qualifiedName: WizardWrx.RecoveredException.TargetSite
    isDefinition: true
    commentId: Overload:WizardWrx.RecoveredException.TargetSite
  WizardWrx.RecoveredException:
    name:
      CSharp:
      - id: WizardWrx.RecoveredException
        name: RecoveredException
        nameWithType: RecoveredException
        qualifiedName: WizardWrx.RecoveredException
      VB:
      - id: WizardWrx.RecoveredException
        name: RecoveredException
        nameWithType: RecoveredException
        qualifiedName: WizardWrx.RecoveredException
    isDefinition: true
    commentId: T:WizardWrx.RecoveredException
  System.IComparable:
    name:
      CSharp:
      - id: System.IComparable
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      VB:
      - id: System.IComparable
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IComparable
  WizardWrx.ReportDetail.ThrowOnInvalidState*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.ThrowOnInvalidState*
        name: ThrowOnInvalidState
        nameWithType: ReportDetail.ThrowOnInvalidState
        qualifiedName: WizardWrx.ReportDetail.ThrowOnInvalidState
      VB:
      - id: WizardWrx.ReportDetail.ThrowOnInvalidState*
        name: ThrowOnInvalidState
        nameWithType: ReportDetail.ThrowOnInvalidState
        qualifiedName: WizardWrx.ReportDetail.ThrowOnInvalidState
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.ThrowOnInvalidState
  System.EventHandler:
    name:
      CSharp:
      - id: System.EventHandler
        name: EventHandler
        nameWithType: EventHandler
        qualifiedName: System.EventHandler
        isExternal: true
      VB:
      - id: System.EventHandler
        name: EventHandler
        nameWithType: EventHandler
        qualifiedName: System.EventHandler
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.EventHandler
  WizardWrx.ReportDetail.LabelChangedEventArgs:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs
        name: ReportDetail.LabelChangedEventArgs
        nameWithType: ReportDetail.LabelChangedEventArgs
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs
      VB:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs
        name: ReportDetail.LabelChangedEventArgs
        nameWithType: ReportDetail.LabelChangedEventArgs
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ReportDetail.LabelChangedEventArgs
  WizardWrx.ReportDetail.OnLabelChanged*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.OnLabelChanged*
        name: OnLabelChanged
        nameWithType: ReportDetail.OnLabelChanged
        qualifiedName: WizardWrx.ReportDetail.OnLabelChanged
      VB:
      - id: WizardWrx.ReportDetail.OnLabelChanged*
        name: OnLabelChanged
        nameWithType: ReportDetail.OnLabelChanged
        qualifiedName: WizardWrx.ReportDetail.OnLabelChanged
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.OnLabelChanged
  WizardWrx.ReportDetail.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.#ctor*
        name: ReportDetail
        nameWithType: ReportDetail.ReportDetail
        qualifiedName: WizardWrx.ReportDetail.ReportDetail
      VB:
      - id: WizardWrx.ReportDetail.#ctor*
        name: ReportDetail
        nameWithType: ReportDetail.ReportDetail
        qualifiedName: WizardWrx.ReportDetail.ReportDetail
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.#ctor
  WizardWrx.ReportDetail.ItemDisplayOrder:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder
        name: ReportDetail.ItemDisplayOrder
        nameWithType: ReportDetail.ItemDisplayOrder
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder
      VB:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder
        name: ReportDetail.ItemDisplayOrder
        nameWithType: ReportDetail.ItemDisplayOrder
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ReportDetail.ItemDisplayOrder
  System.Object[]:
    name:
      CSharp:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.ReportDetail.State:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.State
        name: ReportDetail.State
        nameWithType: ReportDetail.State
        qualifiedName: WizardWrx.ReportDetail.State
      VB:
      - id: WizardWrx.ReportDetail.State
        name: ReportDetail.State
        nameWithType: ReportDetail.State
        qualifiedName: WizardWrx.ReportDetail.State
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ReportDetail.State
  WizardWrx.ReportDetail.DetailState*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DetailState*
        name: DetailState
        nameWithType: ReportDetail.DetailState
        qualifiedName: WizardWrx.ReportDetail.DetailState
      VB:
      - id: WizardWrx.ReportDetail.DetailState*
        name: DetailState
        nameWithType: ReportDetail.DetailState
        qualifiedName: WizardWrx.ReportDetail.DetailState
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DetailState
  WizardWrx.ReportDetail.DisplayFormat*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DisplayFormat*
        name: DisplayFormat
        nameWithType: ReportDetail.DisplayFormat
        qualifiedName: WizardWrx.ReportDetail.DisplayFormat
      VB:
      - id: WizardWrx.ReportDetail.DisplayFormat*
        name: DisplayFormat
        nameWithType: ReportDetail.DisplayFormat
        qualifiedName: WizardWrx.ReportDetail.DisplayFormat
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DisplayFormat
  WizardWrx.ReportDetail.DisplayFormat:
    commentId: P:WizardWrx.ReportDetail.DisplayFormat
  WizardWrx.ReportDetail.SupplementaryDetails*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.SupplementaryDetails*
        name: SupplementaryDetails
        nameWithType: ReportDetail.SupplementaryDetails
        qualifiedName: WizardWrx.ReportDetail.SupplementaryDetails
      VB:
      - id: WizardWrx.ReportDetail.SupplementaryDetails*
        name: SupplementaryDetails
        nameWithType: ReportDetail.SupplementaryDetails
        qualifiedName: WizardWrx.ReportDetail.SupplementaryDetails
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.SupplementaryDetails
  WizardWrx.ReportDetail.DisplayOrder*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DisplayOrder*
        name: DisplayOrder
        nameWithType: ReportDetail.DisplayOrder
        qualifiedName: WizardWrx.ReportDetail.DisplayOrder
      VB:
      - id: WizardWrx.ReportDetail.DisplayOrder*
        name: DisplayOrder
        nameWithType: ReportDetail.DisplayOrder
        qualifiedName: WizardWrx.ReportDetail.DisplayOrder
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DisplayOrder
  WizardWrx.ReportDetail.DisplayValue*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DisplayValue*
        name: DisplayValue
        nameWithType: ReportDetail.DisplayValue
        qualifiedName: WizardWrx.ReportDetail.DisplayValue
      VB:
      - id: WizardWrx.ReportDetail.DisplayValue*
        name: DisplayValue
        nameWithType: ReportDetail.DisplayValue
        qualifiedName: WizardWrx.ReportDetail.DisplayValue
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DisplayValue
  WizardWrx.ReportDetail.Label*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.Label*
        name: Label
        nameWithType: ReportDetail.Label
        qualifiedName: WizardWrx.ReportDetail.Label
      VB:
      - id: WizardWrx.ReportDetail.Label*
        name: Label
        nameWithType: ReportDetail.Label
        qualifiedName: WizardWrx.ReportDetail.Label
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.Label
  WizardWrx.ReportDetail.Value*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.Value*
        name: Value
        nameWithType: ReportDetail.Value
        qualifiedName: WizardWrx.ReportDetail.Value
      VB:
      - id: WizardWrx.ReportDetail.Value*
        name: Value
        nameWithType: ReportDetail.Value
        qualifiedName: WizardWrx.ReportDetail.Value
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.Value
  WizardWrx.ReportDetail.FormatDetail*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.FormatDetail*
        name: FormatDetail
        nameWithType: ReportDetail.FormatDetail
        qualifiedName: WizardWrx.ReportDetail.FormatDetail
      VB:
      - id: WizardWrx.ReportDetail.FormatDetail*
        name: FormatDetail
        nameWithType: ReportDetail.FormatDetail
        qualifiedName: WizardWrx.ReportDetail.FormatDetail
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.FormatDetail
  System.UInt32:
    name:
      CSharp:
      - id: System.UInt32
        name: UInt32
        nameWithType: UInt32
        qualifiedName: System.UInt32
        isExternal: true
      VB:
      - id: System.UInt32
        name: UInt32
        nameWithType: UInt32
        qualifiedName: System.UInt32
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.UInt32
  WizardWrx.ReportDetail.GetPaddedLabel*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.GetPaddedLabel*
        name: GetPaddedLabel
        nameWithType: ReportDetail.GetPaddedLabel
        qualifiedName: WizardWrx.ReportDetail.GetPaddedLabel
      VB:
      - id: WizardWrx.ReportDetail.GetPaddedLabel*
        name: GetPaddedLabel
        nameWithType: ReportDetail.GetPaddedLabel
        qualifiedName: WizardWrx.ReportDetail.GetPaddedLabel
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.GetPaddedLabel
  WizardWrx.FormatStringEngine:
    name:
      CSharp:
      - name: WizardWrx.FormatStringEngine
        nameWithType: WizardWrx.FormatStringEngine
        qualifiedName: WizardWrx.FormatStringEngine
      VB:
      - name: WizardWrx.FormatStringEngine
        nameWithType: WizardWrx.FormatStringEngine
        qualifiedName: WizardWrx.FormatStringEngine
    isDefinition: true
    commentId: N:WizardWrx.FormatStringEngine
  WizardWrx.FormatStringEngine.FormatItem.Alignment:
    name:
      CSharp:
      - id: WizardWrx.FormatStringEngine.FormatItem.Alignment
        name: FormatItem.Alignment
        nameWithType: FormatItem.Alignment
        qualifiedName: WizardWrx.FormatStringEngine.FormatItem.Alignment
      VB:
      - id: WizardWrx.FormatStringEngine.FormatItem.Alignment
        name: FormatItem.Alignment
        nameWithType: FormatItem.Alignment
        qualifiedName: WizardWrx.FormatStringEngine.FormatItem.Alignment
    isDefinition: true
    parent: WizardWrx.FormatStringEngine
    commentId: T:WizardWrx.FormatStringEngine.FormatItem.Alignment
  WizardWrx.ReportDetail.GetPaddedValue*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.GetPaddedValue*
        name: GetPaddedValue
        nameWithType: ReportDetail.GetPaddedValue
        qualifiedName: WizardWrx.ReportDetail.GetPaddedValue
      VB:
      - id: WizardWrx.ReportDetail.GetPaddedValue*
        name: GetPaddedValue
        nameWithType: ReportDetail.GetPaddedValue
        qualifiedName: WizardWrx.ReportDetail.GetPaddedValue
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.GetPaddedValue
  WizardWrx.ReportDetail.TestState*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.TestState*
        name: TestState
        nameWithType: ReportDetail.TestState
        qualifiedName: WizardWrx.ReportDetail.TestState
      VB:
      - id: WizardWrx.ReportDetail.TestState*
        name: TestState
        nameWithType: ReportDetail.TestState
        qualifiedName: WizardWrx.ReportDetail.TestState
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.TestState
  WizardWrx.ReportDetail.DetailFormat*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DetailFormat*
        name: DetailFormat
        nameWithType: ReportDetail.DetailFormat
        qualifiedName: WizardWrx.ReportDetail.DetailFormat
      VB:
      - id: WizardWrx.ReportDetail.DetailFormat*
        name: DetailFormat
        nameWithType: ReportDetail.DetailFormat
        qualifiedName: WizardWrx.ReportDetail.DetailFormat
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DetailFormat
  WizardWrx.ReportDetail.DetailFormatItems*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.DetailFormatItems*
        name: DetailFormatItems
        nameWithType: ReportDetail.DetailFormatItems
        qualifiedName: WizardWrx.ReportDetail.DetailFormatItems
      VB:
      - id: WizardWrx.ReportDetail.DetailFormatItems*
        name: DetailFormatItems
        nameWithType: ReportDetail.DetailFormatItems
        qualifiedName: WizardWrx.ReportDetail.DetailFormatItems
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.DetailFormatItems
  WizardWrx.ReportDetail.System#IComparable#CompareTo*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.System#IComparable#CompareTo*
        name: IComparable.CompareTo
        nameWithType: ReportDetail.IComparable.CompareTo
        qualifiedName: WizardWrx.ReportDetail.System.IComparable.CompareTo
      VB:
      - id: WizardWrx.ReportDetail.System#IComparable#CompareTo*
        name: System.IComparable.CompareTo
        nameWithType: ReportDetail.System.IComparable.CompareTo
        qualifiedName: WizardWrx.ReportDetail.System.IComparable.CompareTo
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.System#IComparable#CompareTo
  System.IComparable.CompareTo(System.Object):
    name:
      CSharp:
      - id: System.IComparable.CompareTo(System.Object)
        name: CompareTo
        nameWithType: IComparable.CompareTo
        qualifiedName: System.IComparable.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable.CompareTo(System.Object)
        name: CompareTo
        nameWithType: IComparable.CompareTo
        qualifiedName: System.IComparable.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.IComparable
    commentId: M:System.IComparable.CompareTo(System.Object)
  WizardWrx.ReportDetail:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      VB:
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ReportDetail
  System.ValueType:
    name:
      CSharp:
      - id: System.ValueType
        name: ValueType
        nameWithType: ValueType
        qualifiedName: System.ValueType
        isExternal: true
      VB:
      - id: System.ValueType
        name: ValueType
        nameWithType: ValueType
        qualifiedName: System.ValueType
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.ValueType
  System.ValueType.Equals(System.Object):
    name:
      CSharp:
      - id: System.ValueType.Equals(System.Object)
        name: Equals
        nameWithType: ValueType.Equals
        qualifiedName: System.ValueType.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.Equals(System.Object)
        name: Equals
        nameWithType: ValueType.Equals
        qualifiedName: System.ValueType.Equals
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.Equals(System.Object)
  System.ValueType.GetHashCode:
    name:
      CSharp:
      - id: System.ValueType.GetHashCode
        name: GetHashCode
        nameWithType: ValueType.GetHashCode
        qualifiedName: System.ValueType.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.GetHashCode
        name: GetHashCode
        nameWithType: ValueType.GetHashCode
        qualifiedName: System.ValueType.GetHashCode
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.GetHashCode
  System.ValueType.ToString:
    name:
      CSharp:
      - id: System.ValueType.ToString
        name: ToString
        nameWithType: ValueType.ToString
        qualifiedName: System.ValueType.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.ValueType.ToString
        name: ToString
        nameWithType: ValueType.ToString
        qualifiedName: System.ValueType.ToString
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.ValueType
    commentId: M:System.ValueType.ToString
  WizardWrx.ReportDetail.ItemDisplayOrder.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.#ctor*
        name: ItemDisplayOrder
        nameWithType: ReportDetail.ItemDisplayOrder.ItemDisplayOrder
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.ItemDisplayOrder
      VB:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.#ctor*
        name: ItemDisplayOrder
        nameWithType: ReportDetail.ItemDisplayOrder.ItemDisplayOrder
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.ItemDisplayOrder
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.ItemDisplayOrder.#ctor
  WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit*
        name: Implicit
        nameWithType: ReportDetail.ItemDisplayOrder.Implicit
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.Implicit
      VB:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit*
        name: Widening
        nameWithType: ReportDetail.ItemDisplayOrder.Widening
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.Widening
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.ItemDisplayOrder.op_Implicit
  WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit*
        name: Explicit
        nameWithType: ReportDetail.ItemDisplayOrder.Explicit
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.Explicit
      VB:
      - id: WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit*
        name: Narrowing
        nameWithType: ReportDetail.ItemDisplayOrder.Narrowing
        qualifiedName: WizardWrx.ReportDetail.ItemDisplayOrder.Narrowing
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.ItemDisplayOrder.op_Explicit
  ? WizardWrx.ReportDetail.State.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<ReportDetail.State>
        nameWithType: StringExtensions.RenderEvenWhenNull<ReportDetail.State>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.ReportDetail.State>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of ReportDetail.State)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of ReportDetail.State)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.ReportDetail.State)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  System.EventArgs:
    name:
      CSharp:
      - id: System.EventArgs
        name: EventArgs
        nameWithType: EventArgs
        qualifiedName: System.EventArgs
        isExternal: true
      VB:
      - id: System.EventArgs
        name: EventArgs
        nameWithType: EventArgs
        qualifiedName: System.EventArgs
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.EventArgs
  System.EventArgs.Empty:
    name:
      CSharp:
      - id: System.EventArgs.Empty
        name: Empty
        nameWithType: EventArgs.Empty
        qualifiedName: System.EventArgs.Empty
        isExternal: true
      VB:
      - id: System.EventArgs.Empty
        name: Empty
        nameWithType: EventArgs.Empty
        qualifiedName: System.EventArgs.Empty
        isExternal: true
    isDefinition: true
    parent: System.EventArgs
    commentId: F:System.EventArgs.Empty
  WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor*
        name: LabelChangedEventArgs
        nameWithType: ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs
      VB:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor*
        name: LabelChangedEventArgs
        nameWithType: ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.LabelChangedEventArgs
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.LabelChangedEventArgs.#ctor
  WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength*
        name: NewLength
        nameWithType: ReportDetail.LabelChangedEventArgs.NewLength
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
      VB:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength*
        name: NewLength
        nameWithType: ReportDetail.LabelChangedEventArgs.NewLength
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.LabelChangedEventArgs.NewLength
  WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength*
        name: OldLength
        nameWithType: ReportDetail.LabelChangedEventArgs.OldLength
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
      VB:
      - id: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength*
        name: OldLength
        nameWithType: ReportDetail.LabelChangedEventArgs.OldLength
        qualifiedName: WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetail.LabelChangedEventArgs.OldLength
  System.Collections.Generic.List`1:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.List`1
  System.Collections.Generic:
    name:
      CSharp:
      - name: System.Collections.Generic
        nameWithType: System.Collections.Generic
        qualifiedName: System.Collections.Generic
        isExternal: true
      VB:
      - name: System.Collections.Generic
        nameWithType: System.Collections.Generic
        qualifiedName: System.Collections.Generic
    isDefinition: true
    commentId: N:System.Collections.Generic
  System.Collections.Generic.List{WizardWrx.ReportDetail}:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.List{WizardWrx.ReportDetail}
  System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
        name: IList.get_Item
        nameWithType: List<T>.IList.get_Item
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.get_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
        name: System.Collections.IList.get_Item
        nameWithType: List(Of T).System.Collections.IList.get_Item
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.get_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#get_Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
        name: IList.get_Item
        nameWithType: List<ReportDetail>.IList.get_Item
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.get_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
        name: System.Collections.IList.get_Item
        nameWithType: List(Of ReportDetail).System.Collections.IList.get_Item
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.get_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#get_Item(System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#get_Item(System.Int32)
  System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
        name: IList.set_Item
        nameWithType: List<T>.IList.set_Item
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.set_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
        name: System.Collections.IList.set_Item
        nameWithType: List(Of T).System.Collections.IList.set_Item
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.set_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#set_Item(System.Int32,System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
        name: IList.set_Item
        nameWithType: List<ReportDetail>.IList.set_Item
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.set_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
        name: System.Collections.IList.set_Item
        nameWithType: List(Of ReportDetail).System.Collections.IList.set_Item
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.set_Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#set_Item(System.Int32,System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#set_Item(System.Int32,System.Object)
  System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
        name: IList.Add
        nameWithType: List<T>.IList.Add
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.Add
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
        name: System.Collections.IList.Add
        nameWithType: List(Of T).System.Collections.IList.Add
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.Add
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Add(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
        name: IList.Add
        nameWithType: List<ReportDetail>.IList.Add
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.Add
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
        name: System.Collections.IList.Add
        nameWithType: List(Of ReportDetail).System.Collections.IList.Add
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.Add
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Add(System.Object)
  System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
        name: AddRange
        nameWithType: List<T>.AddRange
        qualifiedName: System.Collections.Generic.List<T>.AddRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
        name: AddRange
        nameWithType: List(Of T).AddRange
        qualifiedName: System.Collections.Generic.List(Of T).AddRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.AddRange(System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
        name: AddRange
        nameWithType: List<ReportDetail>.AddRange
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.AddRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
        name: AddRange
        nameWithType: List(Of ReportDetail).AddRange
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).AddRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.AddRange(System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.AsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.AsReadOnly
        name: AsReadOnly
        nameWithType: List<T>.AsReadOnly
        qualifiedName: System.Collections.Generic.List<T>.AsReadOnly
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.AsReadOnly
        name: AsReadOnly
        nameWithType: List(Of T).AsReadOnly
        qualifiedName: System.Collections.Generic.List(Of T).AsReadOnly
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.AsReadOnly
  System.Collections.Generic.List{WizardWrx.ReportDetail}.AsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.AsReadOnly
        name: AsReadOnly
        nameWithType: List<ReportDetail>.AsReadOnly
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.AsReadOnly
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.AsReadOnly
        name: AsReadOnly
        nameWithType: List(Of ReportDetail).AsReadOnly
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).AsReadOnly
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.AsReadOnly
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.AsReadOnly
  System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List<T>.BinarySearch
        qualifiedName: System.Collections.Generic.List<T>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List(Of T).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of T).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(System.Int32,System.Int32,WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List<ReportDetail>.BinarySearch
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List(Of ReportDetail).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(System.Int32,System.Int32,WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.BinarySearch(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(`0)
        name: BinarySearch
        nameWithType: List<T>.BinarySearch
        qualifiedName: System.Collections.Generic.List<T>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(`0)
        name: BinarySearch
        nameWithType: List(Of T).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of T).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.BinarySearch(`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(`0)
        name: BinarySearch
        nameWithType: List<ReportDetail>.BinarySearch
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(`0)
        name: BinarySearch
        nameWithType: List(Of ReportDetail).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.BinarySearch(`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List<T>.BinarySearch
        qualifiedName: System.Collections.Generic.List<T>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List(Of T).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of T).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List<ReportDetail>.BinarySearch
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
        name: BinarySearch
        nameWithType: List(Of ReportDetail).BinarySearch
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).BinarySearch
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.BinarySearch(WizardWrx.ReportDetail,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.Clear:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Clear
        name: Clear
        nameWithType: List<T>.Clear
        qualifiedName: System.Collections.Generic.List<T>.Clear
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Clear
        name: Clear
        nameWithType: List(Of T).Clear
        qualifiedName: System.Collections.Generic.List(Of T).Clear
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Clear
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Clear:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Clear
        name: Clear
        nameWithType: List<ReportDetail>.Clear
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Clear
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Clear
        name: Clear
        nameWithType: List(Of ReportDetail).Clear
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Clear
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Clear
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Clear
  System.Collections.Generic.List`1.Contains(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Contains(`0)
        name: Contains
        nameWithType: List<T>.Contains
        qualifiedName: System.Collections.Generic.List<T>.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Contains(`0)
        name: Contains
        nameWithType: List(Of T).Contains
        qualifiedName: System.Collections.Generic.List(Of T).Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Contains(`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Contains(WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Contains(`0)
        name: Contains
        nameWithType: List<ReportDetail>.Contains
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Contains(`0)
        name: Contains
        nameWithType: List(Of ReportDetail).Contains
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Contains(`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Contains(WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
        name: IList.Contains
        nameWithType: List<T>.IList.Contains
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
        name: System.Collections.IList.Contains
        nameWithType: List(Of T).System.Collections.IList.Contains
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Contains(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
        name: IList.Contains
        nameWithType: List<ReportDetail>.IList.Contains
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
        name: System.Collections.IList.Contains
        nameWithType: List(Of ReportDetail).System.Collections.IList.Contains
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.Contains
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Contains(System.Object)
  System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
        name: ConvertAll<TOutput>
        nameWithType: List<T>.ConvertAll<TOutput>
        qualifiedName: System.Collections.Generic.List<T>.ConvertAll<TOutput>
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Converter`2
        name: Converter
        nameWithType: Converter
        qualifiedName: System.Converter
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TOutput
        nameWithType: TOutput
        qualifiedName: TOutput
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
        name: ConvertAll(Of TOutput)
        nameWithType: List(Of T).ConvertAll(Of TOutput)
        qualifiedName: System.Collections.Generic.List(Of T).ConvertAll(Of TOutput)
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Converter`2
        name: Converter
        nameWithType: Converter
        qualifiedName: System.Converter
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TOutput
        nameWithType: TOutput
        qualifiedName: TOutput
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.ConvertAll``1(System.Converter{WizardWrx.ReportDetail,{TOutput}}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
        name: ConvertAll<TOutput>
        nameWithType: List<ReportDetail>.ConvertAll<TOutput>
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.ConvertAll<TOutput>
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Converter`2
        name: Converter
        nameWithType: Converter
        qualifiedName: System.Converter
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TOutput
        nameWithType: TOutput
        qualifiedName: TOutput
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
        name: ConvertAll(Of TOutput)
        nameWithType: List(Of ReportDetail).ConvertAll(Of TOutput)
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).ConvertAll(Of TOutput)
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Converter`2
        name: Converter
        nameWithType: Converter
        qualifiedName: System.Converter
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TOutput
        nameWithType: TOutput
        qualifiedName: TOutput
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.ConvertAll``1(System.Converter{WizardWrx.ReportDetail,``0})
  System.Collections.Generic.List`1.CopyTo(`0[]):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(`0[])
        name: CopyTo
        nameWithType: List<T>.CopyTo
        qualifiedName: System.Collections.Generic.List<T>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(`0[])
        name: CopyTo
        nameWithType: List(Of T).CopyTo
        qualifiedName: System.Collections.Generic.List(Of T).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.CopyTo(`0[])
  System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[]):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(`0[])
        name: CopyTo
        nameWithType: List<ReportDetail>.CopyTo
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(`0[])
        name: CopyTo
        nameWithType: List(Of ReportDetail).CopyTo
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.CopyTo(`0[])
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[])
  System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
        name: ICollection.CopyTo
        nameWithType: List<T>.ICollection.CopyTo
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.ICollection.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Array
        name: Array
        nameWithType: Array
        qualifiedName: System.Array
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
        name: System.Collections.ICollection.CopyTo
        nameWithType: List(Of T).System.Collections.ICollection.CopyTo
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.ICollection.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Array
        name: Array
        nameWithType: Array
        qualifiedName: System.Array
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#CopyTo(System.Array,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
        name: ICollection.CopyTo
        nameWithType: List<ReportDetail>.ICollection.CopyTo
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.ICollection.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Array
        name: Array
        nameWithType: Array
        qualifiedName: System.Array
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
        name: System.Collections.ICollection.CopyTo
        nameWithType: List(Of ReportDetail).System.Collections.ICollection.CopyTo
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.ICollection.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Array
        name: Array
        nameWithType: Array
        qualifiedName: System.Array
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
        name: CopyTo
        nameWithType: List<T>.CopyTo
        qualifiedName: System.Collections.Generic.List<T>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
        name: CopyTo
        nameWithType: List(Of T).CopyTo
        qualifiedName: System.Collections.Generic.List(Of T).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(System.Int32,WizardWrx.ReportDetail[],System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
        name: CopyTo
        nameWithType: List<ReportDetail>.CopyTo
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
        name: CopyTo
        nameWithType: List(Of ReportDetail).CopyTo
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(System.Int32,WizardWrx.ReportDetail[],System.Int32,System.Int32)
  System.Collections.Generic.List`1.CopyTo(`0[],System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
        name: CopyTo
        nameWithType: List<T>.CopyTo
        qualifiedName: System.Collections.Generic.List<T>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
        name: CopyTo
        nameWithType: List(Of T).CopyTo
        qualifiedName: System.Collections.Generic.List(Of T).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[],System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
        name: CopyTo
        nameWithType: List<ReportDetail>.CopyTo
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
        name: CopyTo
        nameWithType: List(Of ReportDetail).CopyTo
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).CopyTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ()
        nameWithType: ()
        qualifiedName: ()
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.CopyTo(WizardWrx.ReportDetail[],System.Int32)
  System.Collections.Generic.List`1.Exists(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Exists(System.Predicate{`0})
        name: Exists
        nameWithType: List<T>.Exists
        qualifiedName: System.Collections.Generic.List<T>.Exists
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Exists(System.Predicate{`0})
        name: Exists
        nameWithType: List(Of T).Exists
        qualifiedName: System.Collections.Generic.List(Of T).Exists
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Exists(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Exists(System.Predicate{`0})
        name: Exists
        nameWithType: List<ReportDetail>.Exists
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Exists
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Exists(System.Predicate{`0})
        name: Exists
        nameWithType: List(Of ReportDetail).Exists
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Exists
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Exists(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Exists(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.Find(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Find(System.Predicate{`0})
        name: Find
        nameWithType: List<T>.Find
        qualifiedName: System.Collections.Generic.List<T>.Find
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Find(System.Predicate{`0})
        name: Find
        nameWithType: List(Of T).Find
        qualifiedName: System.Collections.Generic.List(Of T).Find
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Find(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Find(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Find(System.Predicate{`0})
        name: Find
        nameWithType: List<ReportDetail>.Find
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Find
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Find(System.Predicate{`0})
        name: Find
        nameWithType: List(Of ReportDetail).Find
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Find
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Find(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Find(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindAll(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
        name: FindAll
        nameWithType: List<T>.FindAll
        qualifiedName: System.Collections.Generic.List<T>.FindAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
        name: FindAll
        nameWithType: List(Of T).FindAll
        qualifiedName: System.Collections.Generic.List(Of T).FindAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindAll(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
        name: FindAll
        nameWithType: List<ReportDetail>.FindAll
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
        name: FindAll
        nameWithType: List(Of ReportDetail).FindAll
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindAll(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindAll(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindIndex(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
        name: FindIndex
        nameWithType: List<T>.FindIndex
        qualifiedName: System.Collections.Generic.List<T>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of T).FindIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
        name: FindIndex
        nameWithType: List<ReportDetail>.FindIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of ReportDetail).FindIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List<T>.FindIndex
        qualifiedName: System.Collections.Generic.List<T>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of T).FindIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List<ReportDetail>.FindIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of ReportDetail).FindIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List<T>.FindIndex
        qualifiedName: System.Collections.Generic.List<T>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of T).FindIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List<ReportDetail>.FindIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindIndex
        nameWithType: List(Of ReportDetail).FindIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindLast(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
        name: FindLast
        nameWithType: List<T>.FindLast
        qualifiedName: System.Collections.Generic.List<T>.FindLast
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
        name: FindLast
        nameWithType: List(Of T).FindLast
        qualifiedName: System.Collections.Generic.List(Of T).FindLast
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLast(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
        name: FindLast
        nameWithType: List<ReportDetail>.FindLast
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindLast
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
        name: FindLast
        nameWithType: List(Of ReportDetail).FindLast
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindLast
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindLast(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLast(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<T>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<T>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of T).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<ReportDetail>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of ReportDetail).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<T>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<T>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of T).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<ReportDetail>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of ReportDetail).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<T>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<T>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of T).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of T).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List<ReportDetail>.FindLastIndex
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
        name: FindLastIndex
        nameWithType: List(Of ReportDetail).FindLastIndex
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).FindLastIndex
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.FindLastIndex(System.Int32,System.Int32,System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.ForEach(System.Action{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ForEach(System.Action{`0})
        name: ForEach
        nameWithType: List<T>.ForEach
        qualifiedName: System.Collections.Generic.List<T>.ForEach
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Action`1
        name: Action
        nameWithType: Action
        qualifiedName: System.Action
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ForEach(System.Action{`0})
        name: ForEach
        nameWithType: List(Of T).ForEach
        qualifiedName: System.Collections.Generic.List(Of T).ForEach
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Action`1
        name: Action
        nameWithType: Action
        qualifiedName: System.Action
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.ForEach(System.Action{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.ForEach(System.Action{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ForEach(System.Action{`0})
        name: ForEach
        nameWithType: List<ReportDetail>.ForEach
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.ForEach
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Action`1
        name: Action
        nameWithType: Action
        qualifiedName: System.Action
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ForEach(System.Action{`0})
        name: ForEach
        nameWithType: List(Of ReportDetail).ForEach
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).ForEach
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Action`1
        name: Action
        nameWithType: Action
        qualifiedName: System.Action
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.ForEach(System.Action{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.ForEach(System.Action{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.GetEnumerator
        name: GetEnumerator
        nameWithType: List<T>.GetEnumerator
        qualifiedName: System.Collections.Generic.List<T>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.GetEnumerator
        name: GetEnumerator
        nameWithType: List(Of T).GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of T).GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.GetEnumerator
  System.Collections.Generic.List{WizardWrx.ReportDetail}.GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.GetEnumerator
        name: GetEnumerator
        nameWithType: List<ReportDetail>.GetEnumerator
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.GetEnumerator
        name: GetEnumerator
        nameWithType: List(Of ReportDetail).GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.GetEnumerator
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.GetEnumerator
  System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
        name: IEnumerable<T>.GetEnumerator
        nameWithType: List<T>.IEnumerable<T>.GetEnumerator
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.Generic.IEnumerable<T>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
        name: System.Collections.Generic.IEnumerable<T>.GetEnumerator
        nameWithType: List(Of T).System.Collections.Generic.IEnumerable<T>.GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.Generic.IEnumerable<T>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#IEnumerable{T}#GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
        name: IEnumerable<ReportDetail>.GetEnumerator
        nameWithType: List<ReportDetail>.IEnumerable<ReportDetail>.GetEnumerator
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.Generic.IEnumerable<WizardWrx.ReportDetail>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
        name: System.Collections.Generic.IEnumerable<T>.GetEnumerator
        nameWithType: List(Of ReportDetail).System.Collections.Generic.IEnumerable<T>.GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.Generic.IEnumerable<T>.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#IEnumerable{T}#GetEnumerator
  System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
        name: IEnumerable.GetEnumerator
        nameWithType: List<T>.IEnumerable.GetEnumerator
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IEnumerable.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
        name: System.Collections.IEnumerable.GetEnumerator
        nameWithType: List(Of T).System.Collections.IEnumerable.GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IEnumerable.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IEnumerable#GetEnumerator:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
        name: IEnumerable.GetEnumerator
        nameWithType: List<ReportDetail>.IEnumerable.GetEnumerator
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IEnumerable.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
        name: System.Collections.IEnumerable.GetEnumerator
        nameWithType: List(Of ReportDetail).System.Collections.IEnumerable.GetEnumerator
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IEnumerable.GetEnumerator
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IEnumerable#GetEnumerator
  System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
        name: GetRange
        nameWithType: List<T>.GetRange
        qualifiedName: System.Collections.Generic.List<T>.GetRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
        name: GetRange
        nameWithType: List(Of T).GetRange
        qualifiedName: System.Collections.Generic.List(Of T).GetRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.GetRange(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
        name: GetRange
        nameWithType: List<ReportDetail>.GetRange
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.GetRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
        name: GetRange
        nameWithType: List(Of ReportDetail).GetRange
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).GetRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.GetRange(System.Int32,System.Int32)
  System.Collections.Generic.List`1.IndexOf(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0)
        name: IndexOf
        nameWithType: List<T>.IndexOf
        qualifiedName: System.Collections.Generic.List<T>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0)
        name: IndexOf
        nameWithType: List(Of T).IndexOf
        qualifiedName: System.Collections.Generic.List(Of T).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.IndexOf(`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0)
        name: IndexOf
        nameWithType: List<ReportDetail>.IndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0)
        name: IndexOf
        nameWithType: List(Of ReportDetail).IndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.IndexOf(`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
        name: IList.IndexOf
        nameWithType: List<T>.IList.IndexOf
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
        name: System.Collections.IList.IndexOf
        nameWithType: List(Of T).System.Collections.IList.IndexOf
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IndexOf(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
        name: IList.IndexOf
        nameWithType: List<ReportDetail>.IList.IndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
        name: System.Collections.IList.IndexOf
        nameWithType: List(Of ReportDetail).System.Collections.IList.IndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IndexOf(System.Object)
  System.Collections.Generic.List`1.IndexOf(`0,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
        name: IndexOf
        nameWithType: List<T>.IndexOf
        qualifiedName: System.Collections.Generic.List<T>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
        name: IndexOf
        nameWithType: List(Of T).IndexOf
        qualifiedName: System.Collections.Generic.List(Of T).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
        name: IndexOf
        nameWithType: List<ReportDetail>.IndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
        name: IndexOf
        nameWithType: List(Of ReportDetail).IndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.IndexOf(`0,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32)
  System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
        name: IndexOf
        nameWithType: List<T>.IndexOf
        qualifiedName: System.Collections.Generic.List<T>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
        name: IndexOf
        nameWithType: List(Of T).IndexOf
        qualifiedName: System.Collections.Generic.List(Of T).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
        name: IndexOf
        nameWithType: List<ReportDetail>.IndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
        name: IndexOf
        nameWithType: List(Of ReportDetail).IndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).IndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.IndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32)
  System.Collections.Generic.List`1.Insert(System.Int32,`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Insert(System.Int32,`0)
        name: Insert
        nameWithType: List<T>.Insert
        qualifiedName: System.Collections.Generic.List<T>.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Insert(System.Int32,`0)
        name: Insert
        nameWithType: List(Of T).Insert
        qualifiedName: System.Collections.Generic.List(Of T).Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Insert(System.Int32,`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Insert(System.Int32,WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Insert(System.Int32,`0)
        name: Insert
        nameWithType: List<ReportDetail>.Insert
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Insert(System.Int32,`0)
        name: Insert
        nameWithType: List(Of ReportDetail).Insert
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Insert(System.Int32,`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Insert(System.Int32,WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
        name: IList.Insert
        nameWithType: List<T>.IList.Insert
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
        name: System.Collections.IList.Insert
        nameWithType: List(Of T).System.Collections.IList.Insert
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Insert(System.Int32,System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
        name: IList.Insert
        nameWithType: List<ReportDetail>.IList.Insert
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
        name: System.Collections.IList.Insert
        nameWithType: List(Of ReportDetail).System.Collections.IList.Insert
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.Insert
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Insert(System.Int32,System.Object)
  System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
        name: InsertRange
        nameWithType: List<T>.InsertRange
        qualifiedName: System.Collections.Generic.List<T>.InsertRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
        name: InsertRange
        nameWithType: List(Of T).InsertRange
        qualifiedName: System.Collections.Generic.List(Of T).InsertRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
        name: InsertRange
        nameWithType: List<ReportDetail>.InsertRange
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.InsertRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
        name: InsertRange
        nameWithType: List(Of ReportDetail).InsertRange
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).InsertRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.LastIndexOf(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0)
        name: LastIndexOf
        nameWithType: List<T>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<T>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0)
        name: LastIndexOf
        nameWithType: List(Of T).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of T).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.LastIndexOf(`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0)
        name: LastIndexOf
        nameWithType: List<ReportDetail>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0)
        name: LastIndexOf
        nameWithType: List(Of ReportDetail).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.LastIndexOf(`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
        name: LastIndexOf
        nameWithType: List<T>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<T>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
        name: LastIndexOf
        nameWithType: List(Of T).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of T).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
        name: LastIndexOf
        nameWithType: List<ReportDetail>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
        name: LastIndexOf
        nameWithType: List(Of ReportDetail).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32)
  System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
        name: LastIndexOf
        nameWithType: List<T>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<T>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
        name: LastIndexOf
        nameWithType: List(Of T).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of T).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
        name: LastIndexOf
        nameWithType: List<ReportDetail>.LastIndexOf
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
        name: LastIndexOf
        nameWithType: List(Of ReportDetail).LastIndexOf
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).LastIndexOf
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.LastIndexOf(WizardWrx.ReportDetail,System.Int32,System.Int32)
  System.Collections.Generic.List`1.Remove(`0):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Remove(`0)
        name: Remove
        nameWithType: List<T>.Remove
        qualifiedName: System.Collections.Generic.List<T>.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Remove(`0)
        name: Remove
        nameWithType: List(Of T).Remove
        qualifiedName: System.Collections.Generic.List(Of T).Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Remove(`0)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Remove(WizardWrx.ReportDetail):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Remove(`0)
        name: Remove
        nameWithType: List<ReportDetail>.Remove
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Remove(`0)
        name: Remove
        nameWithType: List(Of ReportDetail).Remove
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Remove(`0)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Remove(WizardWrx.ReportDetail)
  System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
        name: IList.Remove
        nameWithType: List<T>.IList.Remove
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
        name: System.Collections.IList.Remove
        nameWithType: List(Of T).System.Collections.IList.Remove
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Remove(System.Object):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
        name: IList.Remove
        nameWithType: List<ReportDetail>.IList.Remove
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
        name: System.Collections.IList.Remove
        nameWithType: List(Of ReportDetail).System.Collections.IList.Remove
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.Remove
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Remove(System.Object)
  System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
        name: RemoveAll
        nameWithType: List<T>.RemoveAll
        qualifiedName: System.Collections.Generic.List<T>.RemoveAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
        name: RemoveAll
        nameWithType: List(Of T).RemoveAll
        qualifiedName: System.Collections.Generic.List(Of T).RemoveAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAll(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
        name: RemoveAll
        nameWithType: List<ReportDetail>.RemoveAll
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.RemoveAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
        name: RemoveAll
        nameWithType: List(Of ReportDetail).RemoveAll
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).RemoveAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAll(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.RemoveAt(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveAt(System.Int32)
        name: RemoveAt
        nameWithType: List<T>.RemoveAt
        qualifiedName: System.Collections.Generic.List<T>.RemoveAt
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveAt(System.Int32)
        name: RemoveAt
        nameWithType: List(Of T).RemoveAt
        qualifiedName: System.Collections.Generic.List(Of T).RemoveAt
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.RemoveAt(System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAt(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveAt(System.Int32)
        name: RemoveAt
        nameWithType: List<ReportDetail>.RemoveAt
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.RemoveAt
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveAt(System.Int32)
        name: RemoveAt
        nameWithType: List(Of ReportDetail).RemoveAt
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).RemoveAt
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.RemoveAt(System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveAt(System.Int32)
  System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
        name: RemoveRange
        nameWithType: List<T>.RemoveRange
        qualifiedName: System.Collections.Generic.List<T>.RemoveRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
        name: RemoveRange
        nameWithType: List(Of T).RemoveRange
        qualifiedName: System.Collections.Generic.List(Of T).RemoveRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveRange(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
        name: RemoveRange
        nameWithType: List<ReportDetail>.RemoveRange
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.RemoveRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
        name: RemoveRange
        nameWithType: List(Of ReportDetail).RemoveRange
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).RemoveRange
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.RemoveRange(System.Int32,System.Int32)
  System.Collections.Generic.List`1.Reverse:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Reverse
        name: Reverse
        nameWithType: List<T>.Reverse
        qualifiedName: System.Collections.Generic.List<T>.Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Reverse
        name: Reverse
        nameWithType: List(Of T).Reverse
        qualifiedName: System.Collections.Generic.List(Of T).Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Reverse
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Reverse
        name: Reverse
        nameWithType: List<ReportDetail>.Reverse
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Reverse
        name: Reverse
        nameWithType: List(Of ReportDetail).Reverse
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Reverse
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse
  System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
        name: Reverse
        nameWithType: List<T>.Reverse
        qualifiedName: System.Collections.Generic.List<T>.Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
        name: Reverse
        nameWithType: List(Of T).Reverse
        qualifiedName: System.Collections.Generic.List(Of T).Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse(System.Int32,System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
        name: Reverse
        nameWithType: List<ReportDetail>.Reverse
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
        name: Reverse
        nameWithType: List(Of ReportDetail).Reverse
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Reverse
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Reverse(System.Int32,System.Int32)
  System.Collections.Generic.List`1.Sort:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort
        name: Sort
        nameWithType: List<T>.Sort
        qualifiedName: System.Collections.Generic.List<T>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort
        name: Sort
        nameWithType: List(Of T).Sort
        qualifiedName: System.Collections.Generic.List(Of T).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Sort
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort
        name: Sort
        nameWithType: List<ReportDetail>.Sort
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort
        name: Sort
        nameWithType: List(Of ReportDetail).Sort
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Sort
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort
  System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List<T>.Sort
        qualifiedName: System.Collections.Generic.List<T>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List(Of T).Sort
        qualifiedName: System.Collections.Generic.List(Of T).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Collections.Generic.IComparer{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List<ReportDetail>.Sort
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List(Of ReportDetail).Sort
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List<T>.Sort
        qualifiedName: System.Collections.Generic.List<T>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List(Of T).Sort
        qualifiedName: System.Collections.Generic.List(Of T).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
  ? System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  : name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List<ReportDetail>.Sort
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
        name: Sort
        nameWithType: List(Of ReportDetail).Sort
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Collections.Generic.IComparer`1
        name: IComparer
        nameWithType: IComparer
        qualifiedName: System.Collections.Generic.IComparer
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.Sort(System.Comparison{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Comparison{`0})
        name: Sort
        nameWithType: List<T>.Sort
        qualifiedName: System.Collections.Generic.List<T>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Comparison`1
        name: Comparison
        nameWithType: Comparison
        qualifiedName: System.Comparison
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Comparison{`0})
        name: Sort
        nameWithType: List(Of T).Sort
        qualifiedName: System.Collections.Generic.List(Of T).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Comparison`1
        name: Comparison
        nameWithType: Comparison
        qualifiedName: System.Comparison
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Comparison{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Sort(System.Comparison{`0})
        name: Sort
        nameWithType: List<ReportDetail>.Sort
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Comparison`1
        name: Comparison
        nameWithType: Comparison
        qualifiedName: System.Comparison
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.Sort(System.Comparison{`0})
        name: Sort
        nameWithType: List(Of ReportDetail).Sort
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Sort
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Comparison`1
        name: Comparison
        nameWithType: Comparison
        qualifiedName: System.Comparison
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Sort(System.Comparison{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.Sort(System.Comparison{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.ToArray:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ToArray
        name: ToArray
        nameWithType: List<T>.ToArray
        qualifiedName: System.Collections.Generic.List<T>.ToArray
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ToArray
        name: ToArray
        nameWithType: List(Of T).ToArray
        qualifiedName: System.Collections.Generic.List(Of T).ToArray
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.ToArray
  System.Collections.Generic.List{WizardWrx.ReportDetail}.ToArray:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.ToArray
        name: ToArray
        nameWithType: List<ReportDetail>.ToArray
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.ToArray
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.ToArray
        name: ToArray
        nameWithType: List(Of ReportDetail).ToArray
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).ToArray
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.ToArray
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.ToArray
  System.Collections.Generic.List`1.TrimExcess:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.TrimExcess
        name: TrimExcess
        nameWithType: List<T>.TrimExcess
        qualifiedName: System.Collections.Generic.List<T>.TrimExcess
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.TrimExcess
        name: TrimExcess
        nameWithType: List(Of T).TrimExcess
        qualifiedName: System.Collections.Generic.List(Of T).TrimExcess
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.TrimExcess
  System.Collections.Generic.List{WizardWrx.ReportDetail}.TrimExcess:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.TrimExcess
        name: TrimExcess
        nameWithType: List<ReportDetail>.TrimExcess
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.TrimExcess
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.TrimExcess
        name: TrimExcess
        nameWithType: List(Of ReportDetail).TrimExcess
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).TrimExcess
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.TrimExcess
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.TrimExcess
  System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
        name: TrueForAll
        nameWithType: List<T>.TrueForAll
        qualifiedName: System.Collections.Generic.List<T>.TrueForAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
        name: TrueForAll
        nameWithType: List(Of T).TrueForAll
        qualifiedName: System.Collections.Generic.List(Of T).TrueForAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
  System.Collections.Generic.List{WizardWrx.ReportDetail}.TrueForAll(System.Predicate{WizardWrx.ReportDetail}):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
        name: TrueForAll
        nameWithType: List<ReportDetail>.TrueForAll
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.TrueForAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
        name: TrueForAll
        nameWithType: List(Of ReportDetail).TrueForAll
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).TrueForAll
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Predicate`1
        name: Predicate
        nameWithType: Predicate
        qualifiedName: System.Predicate
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: M:System.Collections.Generic.List{WizardWrx.ReportDetail}.TrueForAll(System.Predicate{WizardWrx.ReportDetail})
  System.Collections.Generic.List`1.Capacity:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Capacity
        name: Capacity
        nameWithType: List<T>.Capacity
        qualifiedName: System.Collections.Generic.List<T>.Capacity
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.Capacity
        name: Capacity
        nameWithType: List(Of T).Capacity
        qualifiedName: System.Collections.Generic.List(Of T).Capacity
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.Capacity
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Capacity:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Capacity
        name: Capacity
        nameWithType: List<ReportDetail>.Capacity
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Capacity
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.Capacity
        name: Capacity
        nameWithType: List(Of ReportDetail).Capacity
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Capacity
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.Capacity
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.Capacity
  System.Collections.Generic.List`1.Count:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Count
        name: Count
        nameWithType: List<T>.Count
        qualifiedName: System.Collections.Generic.List<T>.Count
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.Count
        name: Count
        nameWithType: List(Of T).Count
        qualifiedName: System.Collections.Generic.List(Of T).Count
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.Count
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Count:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Count
        name: Count
        nameWithType: List<ReportDetail>.Count
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Count
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.Count
        name: Count
        nameWithType: List(Of ReportDetail).Count
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Count
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.Count
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.Count
  System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
        name: IList.IsFixedSize
        nameWithType: List<T>.IList.IsFixedSize
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.IsFixedSize
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
        name: System.Collections.IList.IsFixedSize
        nameWithType: List(Of T).System.Collections.IList.IsFixedSize
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.IsFixedSize
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsFixedSize:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
        name: IList.IsFixedSize
        nameWithType: List<ReportDetail>.IList.IsFixedSize
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.IsFixedSize
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
        name: System.Collections.IList.IsFixedSize
        nameWithType: List(Of ReportDetail).System.Collections.IList.IsFixedSize
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.IsFixedSize
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsFixedSize
  System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
        name: ICollection<T>.IsReadOnly
        nameWithType: List<T>.ICollection<T>.IsReadOnly
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.Generic.ICollection<T>.IsReadOnly
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
        name: System.Collections.Generic.ICollection<T>.IsReadOnly
        nameWithType: List(Of T).System.Collections.Generic.ICollection<T>.IsReadOnly
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.Generic.ICollection<T>.IsReadOnly
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#ICollection{T}#IsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
        name: ICollection<ReportDetail>.IsReadOnly
        nameWithType: List<ReportDetail>.ICollection<ReportDetail>.IsReadOnly
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.Generic.ICollection<WizardWrx.ReportDetail>.IsReadOnly
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
        name: System.Collections.Generic.ICollection<T>.IsReadOnly
        nameWithType: List(Of ReportDetail).System.Collections.Generic.ICollection<T>.IsReadOnly
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.Generic.ICollection<T>.IsReadOnly
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#Generic#ICollection{T}#IsReadOnly
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#Generic#ICollection{T}#IsReadOnly
  System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
        name: IList.IsReadOnly
        nameWithType: List<T>.IList.IsReadOnly
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.IsReadOnly
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
        name: System.Collections.IList.IsReadOnly
        nameWithType: List(Of T).System.Collections.IList.IsReadOnly
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.IsReadOnly
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsReadOnly:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
        name: IList.IsReadOnly
        nameWithType: List<ReportDetail>.IList.IsReadOnly
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.IsReadOnly
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
        name: System.Collections.IList.IsReadOnly
        nameWithType: List(Of ReportDetail).System.Collections.IList.IsReadOnly
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.IsReadOnly
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#IsReadOnly
  System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
        name: ICollection.IsSynchronized
        nameWithType: List<T>.ICollection.IsSynchronized
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.ICollection.IsSynchronized
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
        name: System.Collections.ICollection.IsSynchronized
        nameWithType: List(Of T).System.Collections.ICollection.IsSynchronized
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.ICollection.IsSynchronized
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#IsSynchronized:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
        name: ICollection.IsSynchronized
        nameWithType: List<ReportDetail>.ICollection.IsSynchronized
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.ICollection.IsSynchronized
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
        name: System.Collections.ICollection.IsSynchronized
        nameWithType: List(Of ReportDetail).System.Collections.ICollection.IsSynchronized
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.ICollection.IsSynchronized
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#IsSynchronized
  System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
        name: ICollection.SyncRoot
        nameWithType: List<T>.ICollection.SyncRoot
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.ICollection.SyncRoot
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
        name: System.Collections.ICollection.SyncRoot
        nameWithType: List(Of T).System.Collections.ICollection.SyncRoot
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.ICollection.SyncRoot
        isExternal: true
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#SyncRoot:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
        name: ICollection.SyncRoot
        nameWithType: List<ReportDetail>.ICollection.SyncRoot
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.ICollection.SyncRoot
        isExternal: true
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
        name: System.Collections.ICollection.SyncRoot
        nameWithType: List(Of ReportDetail).System.Collections.ICollection.SyncRoot
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.ICollection.SyncRoot
        isExternal: true
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#ICollection#SyncRoot
  System.Collections.Generic.List`1.Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Item(System.Int32)
        name: Item
        nameWithType: List<T>.Item
        qualifiedName: System.Collections.Generic.List<T>.Item
        isExternal: true
      - name: '['
        nameWithType: '['
        qualifiedName: '['
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ']'
        nameWithType: ']'
        qualifiedName: ']'
      VB:
      - id: System.Collections.Generic.List`1.Item(System.Int32)
        name: Item
        nameWithType: List(Of T).Item
        qualifiedName: System.Collections.Generic.List(Of T).Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.Item(System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.Item(System.Int32)
        name: Item
        nameWithType: List<ReportDetail>.Item
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.Item
        isExternal: true
      - name: '['
        nameWithType: '['
        qualifiedName: '['
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ']'
        nameWithType: ']'
        qualifiedName: ']'
      VB:
      - id: System.Collections.Generic.List`1.Item(System.Int32)
        name: Item
        nameWithType: List(Of ReportDetail).Item
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.Item(System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.Item(System.Int32)
  System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
        name: IList.Item
        nameWithType: List<T>.IList.Item
        qualifiedName: System.Collections.Generic.List<T>.System.Collections.IList.Item
        isExternal: true
      - name: '['
        nameWithType: '['
        qualifiedName: '['
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ']'
        nameWithType: ']'
        qualifiedName: ']'
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
        name: System.Collections.IList.Item
        nameWithType: List(Of T).System.Collections.IList.Item
        qualifiedName: System.Collections.Generic.List(Of T).System.Collections.IList.Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
  System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Item(System.Int32):
    name:
      CSharp:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
        name: IList.Item
        nameWithType: List<ReportDetail>.IList.Item
        qualifiedName: System.Collections.Generic.List<WizardWrx.ReportDetail>.System.Collections.IList.Item
        isExternal: true
      - name: '['
        nameWithType: '['
        qualifiedName: '['
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ']'
        nameWithType: ']'
        qualifiedName: ']'
      VB:
      - id: System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
        name: System.Collections.IList.Item
        nameWithType: List(Of ReportDetail).System.Collections.IList.Item
        qualifiedName: System.Collections.Generic.List(Of WizardWrx.ReportDetail).System.Collections.IList.Item
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)
    parent: System.Collections.Generic.List{WizardWrx.ReportDetail}
    commentId: P:System.Collections.Generic.List{WizardWrx.ReportDetail}.System#Collections#IList#Item(System.Int32)
  System.Collections.Generic.IList`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IList`1
  System.Collections.Generic.IList{WizardWrx.ReportDetail}:
    name:
      CSharp:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IList`1
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.Generic.IList
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IList`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IList{WizardWrx.ReportDetail}
  System.Collections.Generic.ICollection`1:
    name:
      CSharp:
      - id: System.Collections.Generic.ICollection`1
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.Generic.ICollection
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.ICollection`1
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.Generic.ICollection
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.ICollection`1
  System.Collections.Generic.ICollection{WizardWrx.ReportDetail}:
    name:
      CSharp:
      - id: System.Collections.Generic.ICollection`1
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.Generic.ICollection
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.ICollection`1
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.Generic.ICollection
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.ICollection`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.ICollection{WizardWrx.ReportDetail}
  System.Collections.Generic.IEnumerable`1:
    name:
      CSharp:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.IEnumerable`1
  System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail}:
    name:
      CSharp:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.IEnumerable`1
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.Generic.IEnumerable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.ReportDetail
        name: ReportDetail
        nameWithType: ReportDetail
        qualifiedName: WizardWrx.ReportDetail
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.IEnumerable`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.IEnumerable{WizardWrx.ReportDetail}
  System.Collections:
    name:
      CSharp:
      - name: System.Collections
        nameWithType: System.Collections
        qualifiedName: System.Collections
        isExternal: true
      VB:
      - name: System.Collections
        nameWithType: System.Collections
        qualifiedName: System.Collections
    isDefinition: true
    commentId: N:System.Collections
  System.Collections.IList:
    name:
      CSharp:
      - id: System.Collections.IList
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.IList
        isExternal: true
      VB:
      - id: System.Collections.IList
        name: IList
        nameWithType: IList
        qualifiedName: System.Collections.IList
        isExternal: true
    isDefinition: true
    parent: System.Collections
    commentId: T:System.Collections.IList
  System.Collections.ICollection:
    name:
      CSharp:
      - id: System.Collections.ICollection
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.ICollection
        isExternal: true
      VB:
      - id: System.Collections.ICollection
        name: ICollection
        nameWithType: ICollection
        qualifiedName: System.Collections.ICollection
        isExternal: true
    isDefinition: true
    parent: System.Collections
    commentId: T:System.Collections.ICollection
  System.Collections.IEnumerable:
    name:
      CSharp:
      - id: System.Collections.IEnumerable
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.IEnumerable
        isExternal: true
      VB:
      - id: System.Collections.IEnumerable
        name: IEnumerable
        nameWithType: IEnumerable
        qualifiedName: System.Collections.IEnumerable
        isExternal: true
    isDefinition: true
    parent: System.Collections
    commentId: T:System.Collections.IEnumerable
  WizardWrx.ReportDetails.Add*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.Add*
        name: Add
        nameWithType: ReportDetails.Add
        qualifiedName: WizardWrx.ReportDetails.Add
      VB:
      - id: WizardWrx.ReportDetails.Add*
        name: Add
        nameWithType: ReportDetails.Add
        qualifiedName: WizardWrx.ReportDetails.Add
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.Add
  WizardWrx.ReportDetails.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.#ctor*
        name: ReportDetails
        nameWithType: ReportDetails.ReportDetails
        qualifiedName: WizardWrx.ReportDetails.ReportDetails
      VB:
      - id: WizardWrx.ReportDetails.#ctor*
        name: ReportDetails
        nameWithType: ReportDetails.ReportDetails
        qualifiedName: WizardWrx.ReportDetails.ReportDetails
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.#ctor
  WizardWrx.ReportDetails.GroupDetails*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.GroupDetails*
        name: GroupDetails
        nameWithType: ReportDetails.GroupDetails
        qualifiedName: WizardWrx.ReportDetails.GroupDetails
      VB:
      - id: WizardWrx.ReportDetails.GroupDetails*
        name: GroupDetails
        nameWithType: ReportDetails.GroupDetails
        qualifiedName: WizardWrx.ReportDetails.GroupDetails
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.GroupDetails
  WizardWrx.ReportDetails.Increment*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.Increment*
        name: Increment
        nameWithType: ReportDetails.Increment
        qualifiedName: WizardWrx.ReportDetails.Increment
      VB:
      - id: WizardWrx.ReportDetails.Increment*
        name: Increment
        nameWithType: ReportDetails.Increment
        qualifiedName: WizardWrx.ReportDetails.Increment
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.Increment
  WizardWrx.ReportDetails.WidthOfWidestLabel*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.WidthOfWidestLabel*
        name: WidthOfWidestLabel
        nameWithType: ReportDetails.WidthOfWidestLabel
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestLabel
      VB:
      - id: WizardWrx.ReportDetails.WidthOfWidestLabel*
        name: WidthOfWidestLabel
        nameWithType: ReportDetails.WidthOfWidestLabel
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestLabel
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.WidthOfWidestLabel
  WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned*
        name: WidthOfWidestLabelUnsigned
        nameWithType: ReportDetails.WidthOfWidestLabelUnsigned
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
      VB:
      - id: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned*
        name: WidthOfWidestLabelUnsigned
        nameWithType: ReportDetails.WidthOfWidestLabelUnsigned
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.WidthOfWidestLabelUnsigned
  WizardWrx.ReportDetails.WidthOfWidestValue*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.WidthOfWidestValue*
        name: WidthOfWidestValue
        nameWithType: ReportDetails.WidthOfWidestValue
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestValue
      VB:
      - id: WizardWrx.ReportDetails.WidthOfWidestValue*
        name: WidthOfWidestValue
        nameWithType: ReportDetails.WidthOfWidestValue
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestValue
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.WidthOfWidestValue
  WizardWrx.ReportDetails.WidthOfWidestValueUnsigned*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned*
        name: WidthOfWidestValueUnsigned
        nameWithType: ReportDetails.WidthOfWidestValueUnsigned
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
      VB:
      - id: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned*
        name: WidthOfWidestValueUnsigned
        nameWithType: ReportDetails.WidthOfWidestValueUnsigned
        qualifiedName: WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.WidthOfWidestValueUnsigned
  WizardWrx.ReportDetails.ListAllItems*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.ListAllItems*
        name: ListAllItems
        nameWithType: ReportDetails.ListAllItems
        qualifiedName: WizardWrx.ReportDetails.ListAllItems
      VB:
      - id: WizardWrx.ReportDetails.ListAllItems*
        name: ListAllItems
        nameWithType: ReportDetails.ListAllItems
        qualifiedName: WizardWrx.ReportDetails.ListAllItems
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.ListAllItems
  System.IO.TextWriter:
    name:
      CSharp:
      - id: System.IO.TextWriter
        name: TextWriter
        nameWithType: TextWriter
        qualifiedName: System.IO.TextWriter
        isExternal: true
      VB:
      - id: System.IO.TextWriter
        name: TextWriter
        nameWithType: TextWriter
        qualifiedName: System.IO.TextWriter
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.TextWriter
  System.String[]:
    name:
      CSharp:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.ReportDetails.ListAllItemsInArray*:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails.ListAllItemsInArray*
        name: ListAllItemsInArray
        nameWithType: ReportDetails.ListAllItemsInArray
        qualifiedName: WizardWrx.ReportDetails.ListAllItemsInArray
      VB:
      - id: WizardWrx.ReportDetails.ListAllItemsInArray*
        name: ListAllItemsInArray
        nameWithType: ReportDetails.ListAllItemsInArray
        qualifiedName: WizardWrx.ReportDetails.ListAllItemsInArray
    isDefinition: true
    commentId: Overload:WizardWrx.ReportDetails.ListAllItemsInArray
  WizardWrx.ReportDetails:
    name:
      CSharp:
      - id: WizardWrx.ReportDetails
        name: ReportDetails
        nameWithType: ReportDetails
        qualifiedName: WizardWrx.ReportDetails
      VB:
      - id: WizardWrx.ReportDetails
        name: ReportDetails
        nameWithType: ReportDetails
        qualifiedName: WizardWrx.ReportDetails
    isDefinition: true
    commentId: T:WizardWrx.ReportDetails
  WizardWrx.ReportHelpers.DetailTemplateFromLabels*:
    name:
      CSharp:
      - id: WizardWrx.ReportHelpers.DetailTemplateFromLabels*
        name: DetailTemplateFromLabels
        nameWithType: ReportHelpers.DetailTemplateFromLabels
        qualifiedName: WizardWrx.ReportHelpers.DetailTemplateFromLabels
      VB:
      - id: WizardWrx.ReportHelpers.DetailTemplateFromLabels*
        name: DetailTemplateFromLabels
        nameWithType: ReportHelpers.DetailTemplateFromLabels
        qualifiedName: WizardWrx.ReportHelpers.DetailTemplateFromLabels
    isDefinition: true
    commentId: Overload:WizardWrx.ReportHelpers.DetailTemplateFromLabels
  System.Collections.Generic.List{{T}}:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.List{``0}
  WizardWrx.ReportHelpers.MaxStringLength*:
    name:
      CSharp:
      - id: WizardWrx.ReportHelpers.MaxStringLength*
        name: MaxStringLength
        nameWithType: ReportHelpers.MaxStringLength
        qualifiedName: WizardWrx.ReportHelpers.MaxStringLength
      VB:
      - id: WizardWrx.ReportHelpers.MaxStringLength*
        name: MaxStringLength
        nameWithType: ReportHelpers.MaxStringLength
        qualifiedName: WizardWrx.ReportHelpers.MaxStringLength
    isDefinition: true
    commentId: Overload:WizardWrx.ReportHelpers.MaxStringLength
  WizardWrx.ReportHelpers:
    name:
      CSharp:
      - id: WizardWrx.ReportHelpers
        name: ReportHelpers
        nameWithType: ReportHelpers
        qualifiedName: WizardWrx.ReportHelpers
      VB:
      - id: WizardWrx.ReportHelpers
        name: ReportHelpers
        nameWithType: ReportHelpers
        qualifiedName: WizardWrx.ReportHelpers
    isDefinition: true
    commentId: T:WizardWrx.ReportHelpers
  ? WizardWrx.ReportHelpers.Alignment.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<ReportHelpers.Alignment>
        nameWithType: StringExtensions.RenderEvenWhenNull<ReportHelpers.Alignment>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.ReportHelpers.Alignment>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of ReportHelpers.Alignment)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of ReportHelpers.Alignment)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.ReportHelpers.Alignment)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.ReportHelpers.Alignment:
    name:
      CSharp:
      - id: WizardWrx.ReportHelpers.Alignment
        name: ReportHelpers.Alignment
        nameWithType: ReportHelpers.Alignment
        qualifiedName: WizardWrx.ReportHelpers.Alignment
      VB:
      - id: WizardWrx.ReportHelpers.Alignment
        name: ReportHelpers.Alignment
        nameWithType: ReportHelpers.Alignment
        qualifiedName: WizardWrx.ReportHelpers.Alignment
    isDefinition: true
    parent: WizardWrx
    commentId: T:WizardWrx.ReportHelpers.Alignment
  WizardWrx.Core.StringFixups.StringFixup[]:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.StringFixup
        name: StringFixups.StringFixup
        nameWithType: StringFixups.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: WizardWrx.Core.StringFixups.StringFixup
        name: StringFixups.StringFixup
        nameWithType: StringFixups.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.StringExtensions.ApplyFixups*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ApplyFixups*
        name: ApplyFixups
        nameWithType: StringExtensions.ApplyFixups
        qualifiedName: WizardWrx.StringExtensions.ApplyFixups
      VB:
      - id: WizardWrx.StringExtensions.ApplyFixups*
        name: ApplyFixups
        nameWithType: StringExtensions.ApplyFixups
        qualifiedName: WizardWrx.StringExtensions.ApplyFixups
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ApplyFixups
  WizardWrx.StringExtensions.AppendFullStopIfMissing*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.AppendFullStopIfMissing*
        name: AppendFullStopIfMissing
        nameWithType: StringExtensions.AppendFullStopIfMissing
        qualifiedName: WizardWrx.StringExtensions.AppendFullStopIfMissing
      VB:
      - id: WizardWrx.StringExtensions.AppendFullStopIfMissing*
        name: AppendFullStopIfMissing
        nameWithType: StringExtensions.AppendFullStopIfMissing
        qualifiedName: WizardWrx.StringExtensions.AppendFullStopIfMissing
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.AppendFullStopIfMissing
  System.Char[]:
    name:
      CSharp:
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.StringExtensions.ArrayOfOne*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ArrayOfOne*
        name: ArrayOfOne
        nameWithType: StringExtensions.ArrayOfOne
        qualifiedName: WizardWrx.StringExtensions.ArrayOfOne
      VB:
      - id: WizardWrx.StringExtensions.ArrayOfOne*
        name: ArrayOfOne
        nameWithType: StringExtensions.ArrayOfOne
        qualifiedName: WizardWrx.StringExtensions.ArrayOfOne
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ArrayOfOne
  WizardWrx.StringExtensions.CapitalizeWords*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.CapitalizeWords*
        name: CapitalizeWords
        nameWithType: StringExtensions.CapitalizeWords
        qualifiedName: WizardWrx.StringExtensions.CapitalizeWords
      VB:
      - id: WizardWrx.StringExtensions.CapitalizeWords*
        name: CapitalizeWords
        nameWithType: StringExtensions.CapitalizeWords
        qualifiedName: WizardWrx.StringExtensions.CapitalizeWords
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.CapitalizeWords
  WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN:
    commentId: F:WizardWrx.SpecialStrings.STRING_SPLIT_CARRIAGE_RETURN
  WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED:
    commentId: F:WizardWrx.SpecialStrings.STRING_SPLIT_LINEFEED
  System.Environment.NewLine:
    commentId: P:System.Environment.NewLine
  WizardWrx.StringExtensions.Chop*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.Chop*
        name: Chop
        nameWithType: StringExtensions.Chop
        qualifiedName: WizardWrx.StringExtensions.Chop
      VB:
      - id: WizardWrx.StringExtensions.Chop*
        name: Chop
        nameWithType: StringExtensions.Chop
        qualifiedName: WizardWrx.StringExtensions.Chop
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.Chop
  WizardWrx.StringExtensions.ChopNBSP*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ChopNBSP*
        name: ChopNBSP
        nameWithType: StringExtensions.ChopNBSP
        qualifiedName: WizardWrx.StringExtensions.ChopNBSP
      VB:
      - id: WizardWrx.StringExtensions.ChopNBSP*
        name: ChopNBSP
        nameWithType: StringExtensions.ChopNBSP
        qualifiedName: WizardWrx.StringExtensions.ChopNBSP
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ChopNBSP
  WizardWrx.StringExtensions.CountCharacterOccurrences*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.CountCharacterOccurrences*
        name: CountCharacterOccurrences
        nameWithType: StringExtensions.CountCharacterOccurrences
        qualifiedName: WizardWrx.StringExtensions.CountCharacterOccurrences
      VB:
      - id: WizardWrx.StringExtensions.CountCharacterOccurrences*
        name: CountCharacterOccurrences
        nameWithType: StringExtensions.CountCharacterOccurrences
        qualifiedName: WizardWrx.StringExtensions.CountCharacterOccurrences
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.CountCharacterOccurrences
  WizardWrx.StringExtensions.CountSubstrings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.CountSubstrings*
        name: CountSubstrings
        nameWithType: StringExtensions.CountSubstrings
        qualifiedName: WizardWrx.StringExtensions.CountSubstrings
      VB:
      - id: WizardWrx.StringExtensions.CountSubstrings*
        name: CountSubstrings
        nameWithType: StringExtensions.CountSubstrings
        qualifiedName: WizardWrx.StringExtensions.CountSubstrings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.CountSubstrings
  System.StringComparison:
    name:
      CSharp:
      - id: System.StringComparison
        name: StringComparison
        nameWithType: StringComparison
        qualifiedName: System.StringComparison
        isExternal: true
      VB:
      - id: System.StringComparison
        name: StringComparison
        nameWithType: StringComparison
        qualifiedName: System.StringComparison
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.StringComparison
  System.Int32[]:
    name:
      CSharp:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: System.Int32
        name: Int32
        nameWithType: Int32
        qualifiedName: System.Int32
        isExternal: true
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.StringExtensions.EnumerateSubstringPositions*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.EnumerateSubstringPositions*
        name: EnumerateSubstringPositions
        nameWithType: StringExtensions.EnumerateSubstringPositions
        qualifiedName: WizardWrx.StringExtensions.EnumerateSubstringPositions
      VB:
      - id: WizardWrx.StringExtensions.EnumerateSubstringPositions*
        name: EnumerateSubstringPositions
        nameWithType: StringExtensions.EnumerateSubstringPositions
        qualifiedName: WizardWrx.StringExtensions.EnumerateSubstringPositions
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.EnumerateSubstringPositions
  WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32):
    commentId: M:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings(System.String,System.UInt32,System.UInt32)
  WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings*
        name: CountUnresolvedEnvironmentStrings
        nameWithType: StringExtensions.CountUnresolvedEnvironmentStrings
        qualifiedName: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings
      VB:
      - id: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings*
        name: CountUnresolvedEnvironmentStrings
        nameWithType: StringExtensions.CountUnresolvedEnvironmentStrings
        qualifiedName: WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings
  WizardWrx.StringExtensions.EncloseInChar*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.EncloseInChar*
        name: EncloseInChar
        nameWithType: StringExtensions.EncloseInChar
        qualifiedName: WizardWrx.StringExtensions.EncloseInChar
      VB:
      - id: WizardWrx.StringExtensions.EncloseInChar*
        name: EncloseInChar
        nameWithType: StringExtensions.EncloseInChar
        qualifiedName: WizardWrx.StringExtensions.EncloseInChar
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.EncloseInChar
  WizardWrx.StringExtensions.EnsureFirstCharIs*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.EnsureFirstCharIs*
        name: EnsureFirstCharIs
        nameWithType: StringExtensions.EnsureFirstCharIs
        qualifiedName: WizardWrx.StringExtensions.EnsureFirstCharIs
      VB:
      - id: WizardWrx.StringExtensions.EnsureFirstCharIs*
        name: EnsureFirstCharIs
        nameWithType: StringExtensions.EnsureFirstCharIs
        qualifiedName: WizardWrx.StringExtensions.EnsureFirstCharIs
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.EnsureFirstCharIs
  WizardWrx.StringExtensions.EnsureLastCharIs*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.EnsureLastCharIs*
        name: EnsureLastCharIs
        nameWithType: StringExtensions.EnsureLastCharIs
        qualifiedName: WizardWrx.StringExtensions.EnsureLastCharIs
      VB:
      - id: WizardWrx.StringExtensions.EnsureLastCharIs*
        name: EnsureLastCharIs
        nameWithType: StringExtensions.EnsureLastCharIs
        qualifiedName: WizardWrx.StringExtensions.EnsureLastCharIs
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.EnsureLastCharIs
  System.InvalidOperationException:
    commentId: T:System.InvalidOperationException
  WizardWrx.StringExtensions.EnumFromString*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.EnumFromString*
        name: EnumFromString
        nameWithType: StringExtensions.EnumFromString
        qualifiedName: WizardWrx.StringExtensions.EnumFromString
      VB:
      - id: WizardWrx.StringExtensions.EnumFromString*
        name: EnumFromString
        nameWithType: StringExtensions.EnumFromString
        qualifiedName: WizardWrx.StringExtensions.EnumFromString
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.EnumFromString
  WizardWrx.StringExtensions.ExtractBetweenIndexOfs*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ExtractBetweenIndexOfs*
        name: ExtractBetweenIndexOfs
        nameWithType: StringExtensions.ExtractBetweenIndexOfs
        qualifiedName: WizardWrx.StringExtensions.ExtractBetweenIndexOfs
      VB:
      - id: WizardWrx.StringExtensions.ExtractBetweenIndexOfs*
        name: ExtractBetweenIndexOfs
        nameWithType: StringExtensions.ExtractBetweenIndexOfs
        qualifiedName: WizardWrx.StringExtensions.ExtractBetweenIndexOfs
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ExtractBetweenIndexOfs
  WizardWrx.StringExtensions.ExtractBoundedSubstrings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ExtractBoundedSubstrings*
        name: ExtractBoundedSubstrings
        nameWithType: StringExtensions.ExtractBoundedSubstrings
        qualifiedName: WizardWrx.StringExtensions.ExtractBoundedSubstrings
      VB:
      - id: WizardWrx.StringExtensions.ExtractBoundedSubstrings*
        name: ExtractBoundedSubstrings
        nameWithType: StringExtensions.ExtractBoundedSubstrings
        qualifiedName: WizardWrx.StringExtensions.ExtractBoundedSubstrings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ExtractBoundedSubstrings
  WizardWrx.StringExtensions.GuardStringIfNeeded*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.GuardStringIfNeeded*
        name: GuardStringIfNeeded
        nameWithType: StringExtensions.GuardStringIfNeeded
        qualifiedName: WizardWrx.StringExtensions.GuardStringIfNeeded
      VB:
      - id: WizardWrx.StringExtensions.GuardStringIfNeeded*
        name: GuardStringIfNeeded
        nameWithType: StringExtensions.GuardStringIfNeeded
        qualifiedName: WizardWrx.StringExtensions.GuardStringIfNeeded
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.GuardStringIfNeeded
  WizardWrx.StringExtensions.LeftPadNChars*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.LeftPadNChars*
        name: LeftPadNChars
        nameWithType: StringExtensions.LeftPadNChars
        qualifiedName: WizardWrx.StringExtensions.LeftPadNChars
      VB:
      - id: WizardWrx.StringExtensions.LeftPadNChars*
        name: LeftPadNChars
        nameWithType: StringExtensions.LeftPadNChars
        qualifiedName: WizardWrx.StringExtensions.LeftPadNChars
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.LeftPadNChars
  WizardWrx.StringExtensions.MakeToken*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.MakeToken*
        name: MakeToken
        nameWithType: StringExtensions.MakeToken
        qualifiedName: WizardWrx.StringExtensions.MakeToken
      VB:
      - id: WizardWrx.StringExtensions.MakeToken*
        name: MakeToken
        nameWithType: StringExtensions.MakeToken
        qualifiedName: WizardWrx.StringExtensions.MakeToken
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.MakeToken
  WizardWrx.StringExtensions.OldMacLineEndings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.OldMacLineEndings*
        name: OldMacLineEndings
        nameWithType: StringExtensions.OldMacLineEndings
        qualifiedName: WizardWrx.StringExtensions.OldMacLineEndings
      VB:
      - id: WizardWrx.StringExtensions.OldMacLineEndings*
        name: OldMacLineEndings
        nameWithType: StringExtensions.OldMacLineEndings
        qualifiedName: WizardWrx.StringExtensions.OldMacLineEndings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.OldMacLineEndings
  System.Collections.Specialized:
    name:
      CSharp:
      - name: System.Collections.Specialized
        nameWithType: System.Collections.Specialized
        qualifiedName: System.Collections.Specialized
        isExternal: true
      VB:
      - name: System.Collections.Specialized
        nameWithType: System.Collections.Specialized
        qualifiedName: System.Collections.Specialized
    isDefinition: true
    commentId: N:System.Collections.Specialized
  System.Collections.Specialized.NameValueCollection:
    name:
      CSharp:
      - id: System.Collections.Specialized.NameValueCollection
        name: NameValueCollection
        nameWithType: NameValueCollection
        qualifiedName: System.Collections.Specialized.NameValueCollection
        isExternal: true
      VB:
      - id: System.Collections.Specialized.NameValueCollection
        name: NameValueCollection
        nameWithType: NameValueCollection
        qualifiedName: System.Collections.Specialized.NameValueCollection
        isExternal: true
    isDefinition: true
    parent: System.Collections.Specialized
    commentId: T:System.Collections.Specialized.NameValueCollection
  WizardWrx.StringExtensions.ParseCommentInHTMLComment*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ParseCommentInHTMLComment*
        name: ParseCommentInHTMLComment
        nameWithType: StringExtensions.ParseCommentInHTMLComment
        qualifiedName: WizardWrx.StringExtensions.ParseCommentInHTMLComment
      VB:
      - id: WizardWrx.StringExtensions.ParseCommentInHTMLComment*
        name: ParseCommentInHTMLComment
        nameWithType: StringExtensions.ParseCommentInHTMLComment
        qualifiedName: WizardWrx.StringExtensions.ParseCommentInHTMLComment
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ParseCommentInHTMLComment
  WizardWrx.StringExtensions.QuoteString*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.QuoteString*
        name: QuoteString
        nameWithType: StringExtensions.QuoteString
        qualifiedName: WizardWrx.StringExtensions.QuoteString
      VB:
      - id: WizardWrx.StringExtensions.QuoteString*
        name: QuoteString
        nameWithType: StringExtensions.QuoteString
        qualifiedName: WizardWrx.StringExtensions.QuoteString
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.QuoteString
  WizardWrx.StringExtensions.RemoveEndChars*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.RemoveEndChars*
        name: RemoveEndChars
        nameWithType: StringExtensions.RemoveEndChars
        qualifiedName: WizardWrx.StringExtensions.RemoveEndChars
      VB:
      - id: WizardWrx.StringExtensions.RemoveEndChars*
        name: RemoveEndChars
        nameWithType: StringExtensions.RemoveEndChars
        qualifiedName: WizardWrx.StringExtensions.RemoveEndChars
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.RemoveEndChars
  WizardWrx.StringExtensions.RemoveEndQuotes*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.RemoveEndQuotes*
        name: RemoveEndQuotes
        nameWithType: StringExtensions.RemoveEndQuotes
        qualifiedName: WizardWrx.StringExtensions.RemoveEndQuotes
      VB:
      - id: WizardWrx.StringExtensions.RemoveEndQuotes*
        name: RemoveEndQuotes
        nameWithType: StringExtensions.RemoveEndQuotes
        qualifiedName: WizardWrx.StringExtensions.RemoveEndQuotes
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.RemoveEndQuotes
  System.IFormatProvider:
    name:
      CSharp:
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      VB:
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IFormatProvider
  WizardWrx.StringExtensions.RenderEvenWhenNull*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull*
        name: RenderEvenWhenNull
        nameWithType: StringExtensions.RenderEvenWhenNull
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull*
        name: RenderEvenWhenNull
        nameWithType: StringExtensions.RenderEvenWhenNull
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.RenderEvenWhenNull
  WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX*
        name: ReplaceEscapedTabsInStringFromResX
        nameWithType: StringExtensions.ReplaceEscapedTabsInStringFromResX
        qualifiedName: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX
      VB:
      - id: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX*
        name: ReplaceEscapedTabsInStringFromResX
        nameWithType: StringExtensions.ReplaceEscapedTabsInStringFromResX
        qualifiedName: WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ReplaceEscapedTabsInStringFromResX
  WizardWrx.StringExtensions.ReplaceTokensFromList*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ReplaceTokensFromList*
        name: ReplaceTokensFromList
        nameWithType: StringExtensions.ReplaceTokensFromList
        qualifiedName: WizardWrx.StringExtensions.ReplaceTokensFromList
      VB:
      - id: WizardWrx.StringExtensions.ReplaceTokensFromList*
        name: ReplaceTokensFromList
        nameWithType: StringExtensions.ReplaceTokensFromList
        qualifiedName: WizardWrx.StringExtensions.ReplaceTokensFromList
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ReplaceTokensFromList
  System.Collections.Generic.Dictionary`2:
    name:
      CSharp:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TValue
        nameWithType: TValue
        qualifiedName: TValue
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: TKey
        nameWithType: TKey
        qualifiedName: TKey
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - name: TValue
        nameWithType: TValue
        qualifiedName: TValue
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.Collections.Generic.Dictionary`2
  System.Collections.Generic.Dictionary{System.String,System.Object}:
    name:
      CSharp:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.Object
        name: Object
        nameWithType: Object
        qualifiedName: System.Object
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.Dictionary`2
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.Dictionary{System.String,System.Object}
  WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String):
    commentId: M:WizardWrx.StringExtensions.CountUnresolvedEnvironmentStrings(System.String)
  WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings*
        name: ReportUnresolvedEnvironmentStrings
        nameWithType: StringExtensions.ReportUnresolvedEnvironmentStrings
        qualifiedName: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings
      VB:
      - id: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings*
        name: ReportUnresolvedEnvironmentStrings
        nameWithType: StringExtensions.ReportUnresolvedEnvironmentStrings
        qualifiedName: WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.ReportUnresolvedEnvironmentStrings
  WizardWrx.StringExtensions.RightPadNChars*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.RightPadNChars*
        name: RightPadNChars
        nameWithType: StringExtensions.RightPadNChars
        qualifiedName: WizardWrx.StringExtensions.RightPadNChars
      VB:
      - id: WizardWrx.StringExtensions.RightPadNChars*
        name: RightPadNChars
        nameWithType: StringExtensions.RightPadNChars
        qualifiedName: WizardWrx.StringExtensions.RightPadNChars
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.RightPadNChars
  WizardWrx.StringExtensions.Truncate*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.Truncate*
        name: Truncate
        nameWithType: StringExtensions.Truncate
        qualifiedName: WizardWrx.StringExtensions.Truncate
      VB:
      - id: WizardWrx.StringExtensions.Truncate*
        name: Truncate
        nameWithType: StringExtensions.Truncate
        qualifiedName: WizardWrx.StringExtensions.Truncate
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.Truncate
  WizardWrx.StringExtensions.UnixLineEndings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.UnixLineEndings*
        name: UnixLineEndings
        nameWithType: StringExtensions.UnixLineEndings
        qualifiedName: WizardWrx.StringExtensions.UnixLineEndings
      VB:
      - id: WizardWrx.StringExtensions.UnixLineEndings*
        name: UnixLineEndings
        nameWithType: StringExtensions.UnixLineEndings
        qualifiedName: WizardWrx.StringExtensions.UnixLineEndings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.UnixLineEndings
  WizardWrx.StringExtensions.WindowsLineEndings*:
    name:
      CSharp:
      - id: WizardWrx.StringExtensions.WindowsLineEndings*
        name: WindowsLineEndings
        nameWithType: StringExtensions.WindowsLineEndings
        qualifiedName: WizardWrx.StringExtensions.WindowsLineEndings
      VB:
      - id: WizardWrx.StringExtensions.WindowsLineEndings*
        name: WindowsLineEndings
        nameWithType: StringExtensions.WindowsLineEndings
        qualifiedName: WizardWrx.StringExtensions.WindowsLineEndings
    isDefinition: true
    commentId: Overload:WizardWrx.StringExtensions.WindowsLineEndings
  WizardWrx.SyncRoot.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.SyncRoot.#ctor*
        name: SyncRoot
        nameWithType: SyncRoot.SyncRoot
        qualifiedName: WizardWrx.SyncRoot.SyncRoot
      VB:
      - id: WizardWrx.SyncRoot.#ctor*
        name: SyncRoot
        nameWithType: SyncRoot.SyncRoot
        qualifiedName: WizardWrx.SyncRoot.SyncRoot
    isDefinition: true
    commentId: Overload:WizardWrx.SyncRoot.#ctor
  WizardWrx.SyncRoot.Label*:
    name:
      CSharp:
      - id: WizardWrx.SyncRoot.Label*
        name: Label
        nameWithType: SyncRoot.Label
        qualifiedName: WizardWrx.SyncRoot.Label
      VB:
      - id: WizardWrx.SyncRoot.Label*
        name: Label
        nameWithType: SyncRoot.Label
        qualifiedName: WizardWrx.SyncRoot.Label
    isDefinition: true
    commentId: Overload:WizardWrx.SyncRoot.Label
  WizardWrx.SyncRoot.ToString*:
    name:
      CSharp:
      - id: WizardWrx.SyncRoot.ToString*
        name: ToString
        nameWithType: SyncRoot.ToString
        qualifiedName: WizardWrx.SyncRoot.ToString
      VB:
      - id: WizardWrx.SyncRoot.ToString*
        name: ToString
        nameWithType: SyncRoot.ToString
        qualifiedName: WizardWrx.SyncRoot.ToString
    isDefinition: true
    commentId: Overload:WizardWrx.SyncRoot.ToString
  WizardWrx.SyncRoot:
    name:
      CSharp:
      - id: WizardWrx.SyncRoot
        name: SyncRoot
        nameWithType: SyncRoot
        qualifiedName: WizardWrx.SyncRoot
      VB:
      - id: WizardWrx.SyncRoot
        name: SyncRoot
        nameWithType: SyncRoot
        qualifiedName: WizardWrx.SyncRoot
    isDefinition: true
    commentId: T:WizardWrx.SyncRoot
  WizardWrx.DisplayFormats:
    commentId: T:WizardWrx.DisplayFormats
  WizardWrx.Core.TimeDisplayFormatter:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter
        name: TimeDisplayFormatter
        nameWithType: TimeDisplayFormatter
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter
        name: TimeDisplayFormatter
        nameWithType: TimeDisplayFormatter
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter
    isDefinition: true
    commentId: T:WizardWrx.Core.TimeDisplayFormatter
  WizardWrx.SysDateFormatters.FormatDateForShow*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.FormatDateForShow*
        name: FormatDateForShow
        nameWithType: SysDateFormatters.FormatDateForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatDateForShow
      VB:
      - id: WizardWrx.SysDateFormatters.FormatDateForShow*
        name: FormatDateForShow
        nameWithType: SysDateFormatters.FormatDateForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatDateForShow
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.FormatDateForShow
  WizardWrx.SysDateFormatters.FormatDateTimeForShow*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.FormatDateTimeForShow*
        name: FormatDateTimeForShow
        nameWithType: SysDateFormatters.FormatDateTimeForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatDateTimeForShow
      VB:
      - id: WizardWrx.SysDateFormatters.FormatDateTimeForShow*
        name: FormatDateTimeForShow
        nameWithType: SysDateFormatters.FormatDateTimeForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatDateTimeForShow
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.FormatDateTimeForShow
  WizardWrx.SysDateFormatters.FormatTimeForShow*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.FormatTimeForShow*
        name: FormatTimeForShow
        nameWithType: SysDateFormatters.FormatTimeForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatTimeForShow
      VB:
      - id: WizardWrx.SysDateFormatters.FormatTimeForShow*
        name: FormatTimeForShow
        nameWithType: SysDateFormatters.FormatTimeForShow
        qualifiedName: WizardWrx.SysDateFormatters.FormatTimeForShow
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.FormatTimeForShow
  WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String):
    commentId: M:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo(System.String)
  WizardWrx.SysDateFormatters.GetDisplayTimeZone*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.GetDisplayTimeZone*
        name: GetDisplayTimeZone
        nameWithType: SysDateFormatters.GetDisplayTimeZone
        qualifiedName: WizardWrx.SysDateFormatters.GetDisplayTimeZone
      VB:
      - id: WizardWrx.SysDateFormatters.GetDisplayTimeZone*
        name: GetDisplayTimeZone
        nameWithType: SysDateFormatters.GetDisplayTimeZone
        qualifiedName: WizardWrx.SysDateFormatters.GetDisplayTimeZone
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.GetDisplayTimeZone
  System.OutOfMemoryException:
    commentId: T:System.OutOfMemoryException
  System.ArgumentNullException:
    commentId: T:System.ArgumentNullException
  System.TimeZoneNotFoundException:
    commentId: T:System.TimeZoneNotFoundException
  System.Security.SecurityException:
    commentId: T:System.Security.SecurityException
  System.InvalidTimeZoneException:
    commentId: T:System.InvalidTimeZoneException
  System.TimeZoneInfo:
    name:
      CSharp:
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
      VB:
      - id: System.TimeZoneInfo
        name: TimeZoneInfo
        nameWithType: TimeZoneInfo
        qualifiedName: System.TimeZoneInfo
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.TimeZoneInfo
  WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo*
        name: GetSystemTimeZoneInfo
        nameWithType: SysDateFormatters.GetSystemTimeZoneInfo
        qualifiedName: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo
      VB:
      - id: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo*
        name: GetSystemTimeZoneInfo
        nameWithType: SysDateFormatters.GetSystemTimeZoneInfo
        qualifiedName: WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.GetSystemTimeZoneInfo
  WizardWrx.SysDateFormatters.ReformatNow*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.ReformatNow*
        name: ReformatNow
        nameWithType: SysDateFormatters.ReformatNow
        qualifiedName: WizardWrx.SysDateFormatters.ReformatNow
      VB:
      - id: WizardWrx.SysDateFormatters.ReformatNow*
        name: ReformatNow
        nameWithType: SysDateFormatters.ReformatNow
        qualifiedName: WizardWrx.SysDateFormatters.ReformatNow
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.ReformatNow
  WizardWrx.SysDateFormatters.ReformatUtcNow*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.ReformatUtcNow*
        name: ReformatUtcNow
        nameWithType: SysDateFormatters.ReformatUtcNow
        qualifiedName: WizardWrx.SysDateFormatters.ReformatUtcNow
      VB:
      - id: WizardWrx.SysDateFormatters.ReformatUtcNow*
        name: ReformatUtcNow
        nameWithType: SysDateFormatters.ReformatUtcNow
        qualifiedName: WizardWrx.SysDateFormatters.ReformatUtcNow
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.ReformatUtcNow
  WizardWrx.SysDateFormatters.ReformatSysDate*:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters.ReformatSysDate*
        name: ReformatSysDate
        nameWithType: SysDateFormatters.ReformatSysDate
        qualifiedName: WizardWrx.SysDateFormatters.ReformatSysDate
      VB:
      - id: WizardWrx.SysDateFormatters.ReformatSysDate*
        name: ReformatSysDate
        nameWithType: SysDateFormatters.ReformatSysDate
        qualifiedName: WizardWrx.SysDateFormatters.ReformatSysDate
    isDefinition: true
    commentId: Overload:WizardWrx.SysDateFormatters.ReformatSysDate
  WizardWrx.SysDateFormatters:
    name:
      CSharp:
      - id: WizardWrx.SysDateFormatters
        name: SysDateFormatters
        nameWithType: SysDateFormatters
        qualifiedName: WizardWrx.SysDateFormatters
      VB:
      - id: WizardWrx.SysDateFormatters
        name: SysDateFormatters
        nameWithType: SysDateFormatters
        qualifiedName: WizardWrx.SysDateFormatters
    isDefinition: true
    commentId: T:WizardWrx.SysDateFormatters
  WizardWrx.TextBlocks.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.#ctor*
        name: TextBlocks
        nameWithType: TextBlocks.TextBlocks
        qualifiedName: WizardWrx.TextBlocks.TextBlocks
      VB:
      - id: WizardWrx.TextBlocks.#ctor*
        name: TextBlocks
        nameWithType: TextBlocks.TextBlocks
        qualifiedName: WizardWrx.TextBlocks.TextBlocks
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.#ctor
  WizardWrx.TextBlocks.InputData*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.InputData*
        name: InputData
        nameWithType: TextBlocks.InputData
        qualifiedName: WizardWrx.TextBlocks.InputData
      VB:
      - id: WizardWrx.TextBlocks.InputData*
        name: InputData
        nameWithType: TextBlocks.InputData
        qualifiedName: WizardWrx.TextBlocks.InputData
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.InputData
  WizardWrx.TextBlocks.MarkerText*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.MarkerText*
        name: MarkerText
        nameWithType: TextBlocks.MarkerText
        qualifiedName: WizardWrx.TextBlocks.MarkerText
      VB:
      - id: WizardWrx.TextBlocks.MarkerText*
        name: MarkerText
        nameWithType: TextBlocks.MarkerText
        qualifiedName: WizardWrx.TextBlocks.MarkerText
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.MarkerText
  WizardWrx.TextBlocks.Prefix*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.Prefix*
        name: Prefix
        nameWithType: TextBlocks.Prefix
        qualifiedName: WizardWrx.TextBlocks.Prefix
      VB:
      - id: WizardWrx.TextBlocks.Prefix*
        name: Prefix
        nameWithType: TextBlocks.Prefix
        qualifiedName: WizardWrx.TextBlocks.Prefix
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.Prefix
  WizardWrx.TextBlocks.Suffix*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.Suffix*
        name: Suffix
        nameWithType: TextBlocks.Suffix
        qualifiedName: WizardWrx.TextBlocks.Suffix
      VB:
      - id: WizardWrx.TextBlocks.Suffix*
        name: Suffix
        nameWithType: TextBlocks.Suffix
        qualifiedName: WizardWrx.TextBlocks.Suffix
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.Suffix
  WizardWrx.TextBlocks.ExtractBlock*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.ExtractBlock*
        name: ExtractBlock
        nameWithType: TextBlocks.ExtractBlock
        qualifiedName: WizardWrx.TextBlocks.ExtractBlock
      VB:
      - id: WizardWrx.TextBlocks.ExtractBlock*
        name: ExtractBlock
        nameWithType: TextBlocks.ExtractBlock
        qualifiedName: WizardWrx.TextBlocks.ExtractBlock
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.ExtractBlock
  WizardWrx.TextBlocks.ExtractBlockToArray*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.ExtractBlockToArray*
        name: ExtractBlockToArray
        nameWithType: TextBlocks.ExtractBlockToArray
        qualifiedName: WizardWrx.TextBlocks.ExtractBlockToArray
      VB:
      - id: WizardWrx.TextBlocks.ExtractBlockToArray*
        name: ExtractBlockToArray
        nameWithType: TextBlocks.ExtractBlockToArray
        qualifiedName: WizardWrx.TextBlocks.ExtractBlockToArray
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.ExtractBlockToArray
  WizardWrx.TextBlocks.CharToArray*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.CharToArray*
        name: CharToArray
        nameWithType: TextBlocks.CharToArray
        qualifiedName: WizardWrx.TextBlocks.CharToArray
      VB:
      - id: WizardWrx.TextBlocks.CharToArray*
        name: CharToArray
        nameWithType: TextBlocks.CharToArray
        qualifiedName: WizardWrx.TextBlocks.CharToArray
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.CharToArray
  WizardWrx.TextBlocks.StringOfLinesToArray*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.StringOfLinesToArray*
        name: StringOfLinesToArray
        nameWithType: TextBlocks.StringOfLinesToArray
        qualifiedName: WizardWrx.TextBlocks.StringOfLinesToArray
      VB:
      - id: WizardWrx.TextBlocks.StringOfLinesToArray*
        name: StringOfLinesToArray
        nameWithType: TextBlocks.StringOfLinesToArray
        qualifiedName: WizardWrx.TextBlocks.StringOfLinesToArray
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.StringOfLinesToArray
  System.StringSplitOptions:
    name:
      CSharp:
      - id: System.StringSplitOptions
        name: StringSplitOptions
        nameWithType: StringSplitOptions
        qualifiedName: System.StringSplitOptions
        isExternal: true
      VB:
      - id: System.StringSplitOptions
        name: StringSplitOptions
        nameWithType: StringSplitOptions
        qualifiedName: System.StringSplitOptions
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.StringSplitOptions
  WizardWrx.TextBlocks.StringToArray*:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks.StringToArray*
        name: StringToArray
        nameWithType: TextBlocks.StringToArray
        qualifiedName: WizardWrx.TextBlocks.StringToArray
      VB:
      - id: WizardWrx.TextBlocks.StringToArray*
        name: StringToArray
        nameWithType: TextBlocks.StringToArray
        qualifiedName: WizardWrx.TextBlocks.StringToArray
    isDefinition: true
    commentId: Overload:WizardWrx.TextBlocks.StringToArray
  WizardWrx.TextBlocks:
    name:
      CSharp:
      - id: WizardWrx.TextBlocks
        name: TextBlocks
        nameWithType: TextBlocks
        qualifiedName: WizardWrx.TextBlocks
      VB:
      - id: WizardWrx.TextBlocks
        name: TextBlocks
        nameWithType: TextBlocks
        qualifiedName: WizardWrx.TextBlocks
    isDefinition: true
    commentId: T:WizardWrx.TextBlocks
  WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName*:
    name:
      CSharp:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName*
        name: AbbreviateDaylightName
        nameWithType: TimeZoneInfoExtensions.AbbreviateDaylightName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName
      VB:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName*
        name: AbbreviateDaylightName
        nameWithType: TimeZoneInfoExtensions.AbbreviateDaylightName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName
    isDefinition: true
    commentId: Overload:WizardWrx.TimeZoneInfoExtensions.AbbreviateDaylightName
  WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName*:
    name:
      CSharp:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName*
        name: AbbreviateDisplayName
        nameWithType: TimeZoneInfoExtensions.AbbreviateDisplayName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName
      VB:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName*
        name: AbbreviateDisplayName
        nameWithType: TimeZoneInfoExtensions.AbbreviateDisplayName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName
    isDefinition: true
    commentId: Overload:WizardWrx.TimeZoneInfoExtensions.AbbreviateDisplayName
  WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName*:
    name:
      CSharp:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName*
        name: AbbreviatedStandardName
        nameWithType: TimeZoneInfoExtensions.AbbreviatedStandardName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName
      VB:
      - id: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName*
        name: AbbreviatedStandardName
        nameWithType: TimeZoneInfoExtensions.AbbreviatedStandardName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName
    isDefinition: true
    commentId: Overload:WizardWrx.TimeZoneInfoExtensions.AbbreviatedStandardName
  WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName*:
    name:
      CSharp:
      - id: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName*
        name: GetCurrentTimeZoneName
        nameWithType: TimeZoneInfoExtensions.GetCurrentTimeZoneName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName
      VB:
      - id: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName*
        name: GetCurrentTimeZoneName
        nameWithType: TimeZoneInfoExtensions.GetCurrentTimeZoneName
        qualifiedName: WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName
    isDefinition: true
    commentId: Overload:WizardWrx.TimeZoneInfoExtensions.GetCurrentTimeZoneName
  WizardWrx.TimeZoneInfoExtensions:
    name:
      CSharp:
      - id: WizardWrx.TimeZoneInfoExtensions
        name: TimeZoneInfoExtensions
        nameWithType: TimeZoneInfoExtensions
        qualifiedName: WizardWrx.TimeZoneInfoExtensions
      VB:
      - id: WizardWrx.TimeZoneInfoExtensions
        name: TimeZoneInfoExtensions
        nameWithType: TimeZoneInfoExtensions
        qualifiedName: WizardWrx.TimeZoneInfoExtensions
    isDefinition: true
    commentId: T:WizardWrx.TimeZoneInfoExtensions
  WizardWrx.Core.AgedFileInfoCollection:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfoCollection
        name: AgedFileInfoCollection
        nameWithType: AgedFileInfoCollection
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection
      VB:
      - id: WizardWrx.Core.AgedFileInfoCollection
        name: AgedFileInfoCollection
        nameWithType: AgedFileInfoCollection
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection
    isDefinition: true
    commentId: T:WizardWrx.Core.AgedFileInfoCollection
  System.IComparable`1:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: T:System.IComparable`1
  System.IComparable{WizardWrx.Core.AgedFileInfo}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{WizardWrx.Core.AgedFileInfo}
  WizardWrx.Core.AgedFileInfo.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.#ctor*
        name: AgedFileInfo
        nameWithType: AgedFileInfo.AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo.AgedFileInfo
      VB:
      - id: WizardWrx.Core.AgedFileInfo.#ctor*
        name: AgedFileInfo
        nameWithType: AgedFileInfo.AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo.AgedFileInfo
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.#ctor
  WizardWrx.Core.AgedFileInfo.Details*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.Details*
        name: Details
        nameWithType: AgedFileInfo.Details
        qualifiedName: WizardWrx.Core.AgedFileInfo.Details
      VB:
      - id: WizardWrx.Core.AgedFileInfo.Details*
        name: Details
        nameWithType: AgedFileInfo.Details
        qualifiedName: WizardWrx.Core.AgedFileInfo.Details
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.Details
  WizardWrx.Core.AgedFileInfo.ToString*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.ToString*
        name: ToString
        nameWithType: AgedFileInfo.ToString
        qualifiedName: WizardWrx.Core.AgedFileInfo.ToString
      VB:
      - id: WizardWrx.Core.AgedFileInfo.ToString*
        name: ToString
        nameWithType: AgedFileInfo.ToString
        qualifiedName: WizardWrx.Core.AgedFileInfo.ToString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.ToString
  WizardWrx.Core.AgedFileInfo.Equals*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.Equals*
        name: Equals
        nameWithType: AgedFileInfo.Equals
        qualifiedName: WizardWrx.Core.AgedFileInfo.Equals
      VB:
      - id: WizardWrx.Core.AgedFileInfo.Equals*
        name: Equals
        nameWithType: AgedFileInfo.Equals
        qualifiedName: WizardWrx.Core.AgedFileInfo.Equals
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.Equals
  WizardWrx.Core.AgedFileInfo.GetHashCode*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.GetHashCode*
        name: GetHashCode
        nameWithType: AgedFileInfo.GetHashCode
        qualifiedName: WizardWrx.Core.AgedFileInfo.GetHashCode
      VB:
      - id: WizardWrx.Core.AgedFileInfo.GetHashCode*
        name: GetHashCode
        nameWithType: AgedFileInfo.GetHashCode
        qualifiedName: WizardWrx.Core.AgedFileInfo.GetHashCode
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.GetHashCode
  WizardWrx.Core:
    name:
      CSharp:
      - name: WizardWrx.Core
        nameWithType: WizardWrx.Core
        qualifiedName: WizardWrx.Core
      VB:
      - name: WizardWrx.Core
        nameWithType: WizardWrx.Core
        qualifiedName: WizardWrx.Core
    isDefinition: true
    commentId: N:WizardWrx.Core
  WizardWrx.Core.AgedFileInfo:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
      VB:
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.AgedFileInfo
  WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo*
        name: IComparable<AgedFileInfo>.CompareTo
        nameWithType: AgedFileInfo.IComparable<AgedFileInfo>.CompareTo
        qualifiedName: WizardWrx.Core.AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
      VB:
      - id: WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo*
        name: System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
        nameWithType: AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
        qualifiedName: WizardWrx.Core.AgedFileInfo.System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfo.System#IComparable{WizardWrx#Core#AgedFileInfo}#CompareTo
  System.IComparable`1.CompareTo(`0):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<T>.CompareTo
        qualifiedName: System.IComparable<T>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of T).CompareTo
        qualifiedName: System.IComparable(Of T).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: T
        nameWithType: T
        qualifiedName: T
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    commentId: M:System.IComparable`1.CompareTo(`0)
  System.IComparable{WizardWrx.Core.AgedFileInfo}.CompareTo(WizardWrx.Core.AgedFileInfo):
    name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<AgedFileInfo>.CompareTo
        qualifiedName: System.IComparable<WizardWrx.Core.AgedFileInfo>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of AgedFileInfo).CompareTo
        qualifiedName: System.IComparable(Of WizardWrx.Core.AgedFileInfo).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.Core.AgedFileInfo
        name: AgedFileInfo
        nameWithType: AgedFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfo
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{WizardWrx.Core.AgedFileInfo}
    commentId: M:System.IComparable{WizardWrx.Core.AgedFileInfo}.CompareTo(WizardWrx.Core.AgedFileInfo)
  System.IO.DirectoryInfo:
    name:
      CSharp:
      - id: System.IO.DirectoryInfo
        name: DirectoryInfo
        nameWithType: DirectoryInfo
        qualifiedName: System.IO.DirectoryInfo
        isExternal: true
      VB:
      - id: System.IO.DirectoryInfo
        name: DirectoryInfo
        nameWithType: DirectoryInfo
        qualifiedName: System.IO.DirectoryInfo
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.DirectoryInfo
  WizardWrx.Core.AgedFileInfoCollection.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfoCollection.#ctor*
        name: AgedFileInfoCollection
        nameWithType: AgedFileInfoCollection.AgedFileInfoCollection
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection
      VB:
      - id: WizardWrx.Core.AgedFileInfoCollection.#ctor*
        name: AgedFileInfoCollection
        nameWithType: AgedFileInfoCollection.AgedFileInfoCollection
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.AgedFileInfoCollection
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfoCollection.#ctor
  System.IO.SearchOption:
    name:
      CSharp:
      - id: System.IO.SearchOption
        name: SearchOption
        nameWithType: SearchOption
        qualifiedName: System.IO.SearchOption
        isExternal: true
      VB:
      - id: System.IO.SearchOption
        name: SearchOption
        nameWithType: SearchOption
        qualifiedName: System.IO.SearchOption
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.SearchOption
  WizardWrx.Core.AgedFileInfoCollection.Count*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfoCollection.Count*
        name: Count
        nameWithType: AgedFileInfoCollection.Count
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.Count
      VB:
      - id: WizardWrx.Core.AgedFileInfoCollection.Count*
        name: Count
        nameWithType: AgedFileInfoCollection.Count
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.Count
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfoCollection.Count
  WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo*
        name: GetFirstFileInfo
        nameWithType: AgedFileInfoCollection.GetFirstFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo
      VB:
      - id: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo*
        name: GetFirstFileInfo
        nameWithType: AgedFileInfoCollection.GetFirstFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfoCollection.GetFirstFileInfo
  WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo*:
    name:
      CSharp:
      - id: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo*
        name: GetLastFileInfo
        nameWithType: AgedFileInfoCollection.GetLastFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo
      VB:
      - id: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo*
        name: GetLastFileInfo
        nameWithType: AgedFileInfoCollection.GetLastFileInfo
        qualifiedName: WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AgedFileInfoCollection.GetLastFileInfo
  WizardWrx.Core.PropertyDefaults:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults
        name: PropertyDefaults
        nameWithType: PropertyDefaults
        qualifiedName: WizardWrx.Core.PropertyDefaults
      VB:
      - id: WizardWrx.Core.PropertyDefaults
        name: PropertyDefaults
        nameWithType: PropertyDefaults
        qualifiedName: WizardWrx.Core.PropertyDefaults
    isDefinition: true
    commentId: T:WizardWrx.Core.PropertyDefaults
  WizardWrx.Core.AssemblyLocatorBase.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.#ctor*
        name: AssemblyLocatorBase
        nameWithType: AssemblyLocatorBase.AssemblyLocatorBase
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.#ctor*
        name: AssemblyLocatorBase
        nameWithType: AssemblyLocatorBase.AssemblyLocatorBase
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocatorBase
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.#ctor
  System.Reflection:
    name:
      CSharp:
      - name: System.Reflection
        nameWithType: System.Reflection
        qualifiedName: System.Reflection
        isExternal: true
      VB:
      - name: System.Reflection
        nameWithType: System.Reflection
        qualifiedName: System.Reflection
    isDefinition: true
    commentId: N:System.Reflection
  System.Reflection.Assembly:
    name:
      CSharp:
      - id: System.Reflection.Assembly
        name: Assembly
        nameWithType: Assembly
        qualifiedName: System.Reflection.Assembly
        isExternal: true
      VB:
      - id: System.Reflection.Assembly
        name: Assembly
        nameWithType: Assembly
        qualifiedName: System.Reflection.Assembly
        isExternal: true
    isDefinition: true
    parent: System.Reflection
    commentId: T:System.Reflection.Assembly
  WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath*
        name: AssemblyDataPath
        nameWithType: AssemblyLocatorBase.AssemblyDataPath
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath*
        name: AssemblyDataPath
        nameWithType: AssemblyLocatorBase.AssemblyDataPath
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
  WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation*
        name: AssemblyLocation
        nameWithType: AssemblyLocatorBase.AssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation*
        name: AssemblyLocation
        nameWithType: AssemblyLocatorBase.AssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
  System.Collections.Generic.List{WizardWrx.RecoveredException}:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.RecoveredException
        name: RecoveredException
        nameWithType: RecoveredException
        qualifiedName: WizardWrx.RecoveredException
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.RecoveredException
        name: RecoveredException
        nameWithType: RecoveredException
        qualifiedName: WizardWrx.RecoveredException
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.List{WizardWrx.RecoveredException}
  WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions*
        name: RecoveredConfigurationExceptions
        nameWithType: AssemblyLocatorBase.RecoveredConfigurationExceptions
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions*
        name: RecoveredConfigurationExceptions
        nameWithType: AssemblyLocatorBase.RecoveredConfigurationExceptions
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
  WizardWrx.Core.UnconfiguredDLLSettings:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings
        name: UnconfiguredDLLSettings
        nameWithType: UnconfiguredDLLSettings
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings
        name: UnconfiguredDLLSettings
        nameWithType: UnconfiguredDLLSettings
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.UnconfiguredDLLSettings
  WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings*
        name: MissingConfigSettings
        nameWithType: AssemblyLocatorBase.MissingConfigSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings*
        name: MissingConfigSettings
        nameWithType: AssemblyLocatorBase.MissingConfigSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
  System.Configuration:
    name:
      CSharp:
      - name: System.Configuration
        nameWithType: System.Configuration
        qualifiedName: System.Configuration
        isExternal: true
      VB:
      - name: System.Configuration
        nameWithType: System.Configuration
        qualifiedName: System.Configuration
    isDefinition: true
    commentId: N:System.Configuration
  System.Configuration.Configuration:
    name:
      CSharp:
      - id: System.Configuration.Configuration
        name: Configuration
        nameWithType: Configuration
        qualifiedName: System.Configuration.Configuration
        isExternal: true
      VB:
      - id: System.Configuration.Configuration
        name: Configuration
        nameWithType: Configuration
        qualifiedName: System.Configuration.Configuration
        isExternal: true
    isDefinition: true
    parent: System.Configuration
    commentId: T:System.Configuration.Configuration
  WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration*
        name: DLLConfiguration
        nameWithType: AssemblyLocatorBase.DLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration*
        name: DLLConfiguration
        nameWithType: AssemblyLocatorBase.DLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
  System.Configuration.AppSettingsSection:
    name:
      CSharp:
      - id: System.Configuration.AppSettingsSection
        name: AppSettingsSection
        nameWithType: AppSettingsSection
        qualifiedName: System.Configuration.AppSettingsSection
        isExternal: true
      VB:
      - id: System.Configuration.AppSettingsSection
        name: AppSettingsSection
        nameWithType: AppSettingsSection
        qualifiedName: System.Configuration.AppSettingsSection
        isExternal: true
    isDefinition: true
    parent: System.Configuration
    commentId: T:System.Configuration.AppSettingsSection
  WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection*
        name: DLLSettingsSection
        nameWithType: AssemblyLocatorBase.DLLSettingsSection
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection*
        name: DLLSettingsSection
        nameWithType: AssemblyLocatorBase.DLLSettingsSection
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
  System.Configuration.KeyValueConfigurationCollection:
    name:
      CSharp:
      - id: System.Configuration.KeyValueConfigurationCollection
        name: KeyValueConfigurationCollection
        nameWithType: KeyValueConfigurationCollection
        qualifiedName: System.Configuration.KeyValueConfigurationCollection
        isExternal: true
      VB:
      - id: System.Configuration.KeyValueConfigurationCollection
        name: KeyValueConfigurationCollection
        nameWithType: KeyValueConfigurationCollection
        qualifiedName: System.Configuration.KeyValueConfigurationCollection
        isExternal: true
    isDefinition: true
    parent: System.Configuration
    commentId: T:System.Configuration.KeyValueConfigurationCollection
  WizardWrx.Core.AssemblyLocatorBase.DLLSettings*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettings*
        name: DLLSettings
        nameWithType: AssemblyLocatorBase.DLLSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettings*
        name: DLLSettings
        nameWithType: AssemblyLocatorBase.DLLSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.DLLSettings
  System.DateTimeKind:
    name:
      CSharp:
      - id: System.DateTimeKind
        name: DateTimeKind
        nameWithType: DateTimeKind
        qualifiedName: System.DateTimeKind
        isExternal: true
      VB:
      - id: System.DateTimeKind
        name: DateTimeKind
        nameWithType: DateTimeKind
        qualifiedName: System.DateTimeKind
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.DateTimeKind
  WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate*
        name: GetAssemblyBuildDate
        nameWithType: AssemblyLocatorBase.GetAssemblyBuildDate
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate*
        name: GetAssemblyBuildDate
        nameWithType: AssemblyLocatorBase.GetAssemblyBuildDate
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyBuildDate
  System.Version:
    name:
      CSharp:
      - id: System.Version
        name: Version
        nameWithType: Version
        qualifiedName: System.Version
        isExternal: true
      VB:
      - id: System.Version
        name: Version
        nameWithType: Version
        qualifiedName: System.Version
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Version
  WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion*
        name: GetAssemblyVersion
        nameWithType: AssemblyLocatorBase.GetAssemblyVersion
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion*
        name: GetAssemblyVersion
        nameWithType: AssemblyLocatorBase.GetAssemblyVersion
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
  WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString*
        name: GetAssemblyVersionString
        nameWithType: AssemblyLocatorBase.GetAssemblyVersionString
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString*
        name: GetAssemblyVersionString
        nameWithType: AssemblyLocatorBase.GetAssemblyVersionString
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersionString
  WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting*
        name: GetDLLSetting
        nameWithType: AssemblyLocatorBase.GetDLLSetting
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting*
        name: GetDLLSetting
        nameWithType: AssemblyLocatorBase.GetDLLSetting
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting
  WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
        name: AssemblyLocatorBase.PropertySourceCounts
        nameWithType: AssemblyLocatorBase.PropertySourceCounts
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
        name: AssemblyLocatorBase.PropertySourceCounts
        nameWithType: AssemblyLocatorBase.PropertySourceCounts
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.AssemblyLocatorBase.PropertySourceCounts
  System.Type:
    name:
      CSharp:
      - id: System.Type
        name: Type
        nameWithType: Type
        qualifiedName: System.Type
        isExternal: true
      VB:
      - id: System.Type
        name: Type
        nameWithType: Type
        qualifiedName: System.Type
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.Type
  WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration*:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration*
        name: SetPropertiesFromDLLConfiguration
        nameWithType: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration*
        name: SetPropertiesFromDLLConfiguration
        nameWithType: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
    isDefinition: true
    commentId: Overload:WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
  WizardWrx.Core.AssemblyLocatorBase:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase
        name: AssemblyLocatorBase
        nameWithType: AssemblyLocatorBase
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase
        name: AssemblyLocatorBase
        nameWithType: AssemblyLocatorBase
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.AssemblyLocatorBase
  System.Reflection.ProcessorArchitecture:
    name:
      CSharp:
      - id: System.Reflection.ProcessorArchitecture
        name: ProcessorArchitecture
        nameWithType: ProcessorArchitecture
        qualifiedName: System.Reflection.ProcessorArchitecture
        isExternal: true
      VB:
      - id: System.Reflection.ProcessorArchitecture
        name: ProcessorArchitecture
        nameWithType: ProcessorArchitecture
        qualifiedName: System.Reflection.ProcessorArchitecture
        isExternal: true
    isDefinition: true
    parent: System.Reflection
    commentId: T:System.Reflection.ProcessorArchitecture
  WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture*
        name: GetProcessorArchitecture
        nameWithType: BasicSystemInfoDisplayMessages.GetProcessorArchitecture
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture*
        name: GetProcessorArchitecture
        nameWithType: BasicSystemInfoDisplayMessages.GetProcessorArchitecture
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.GetProcessorArchitecture
  WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture*
        name: DisplayProcessorArchitecture
        nameWithType: BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture*
        name: DisplayProcessorArchitecture
        nameWithType: BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.DisplayProcessorArchitecture
  WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer*
        name: WWKW_OSIsVistaOrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer*
        name: WWKW_OSIsVistaOrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsVistaOrNewer
  WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer*
        name: WWKW_OSIsWindowsXPOrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer*
        name: WWKW_OSIsWindowsXPOrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindowsXPOrNewer
  WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer*
        name: WWKW_OSIsWindows7OrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer*
        name: WWKW_OSIsWindows7OrNewer
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsWindows7OrNewer
  WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj*
        name: WWKW_OSIsMinimumVersionMaj
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj*
        name: WWKW_OSIsMinimumVersionMaj
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMaj
  WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin*:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin*
        name: WWKW_OSIsMinimumVersionMin
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin*
        name: WWKW_OSIsMinimumVersionMin
        nameWithType: BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin
    isDefinition: true
    commentId: Overload:WizardWrx.Core.BasicSystemInfoDisplayMessages.WWKW_OSIsMinimumVersionMin
  WizardWrx.Core.BasicSystemInfoDisplayMessages:
    name:
      CSharp:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages
        name: BasicSystemInfoDisplayMessages
        nameWithType: BasicSystemInfoDisplayMessages
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages
      VB:
      - id: WizardWrx.Core.BasicSystemInfoDisplayMessages
        name: BasicSystemInfoDisplayMessages
        nameWithType: BasicSystemInfoDisplayMessages
        qualifiedName: WizardWrx.Core.BasicSystemInfoDisplayMessages
    isDefinition: true
    commentId: T:WizardWrx.Core.BasicSystemInfoDisplayMessages
  System.Byte[]:
    name:
      CSharp:
      - id: System.Byte
        name: Byte
        nameWithType: Byte
        qualifiedName: System.Byte
        isExternal: true
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: System.Byte
        name: Byte
        nameWithType: Byte
        qualifiedName: System.Byte
        isExternal: true
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile*:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile*
        name: Base64EncodeBinaryFile
        nameWithType: ByteArrayBase64Converters.Base64EncodeBinaryFile
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile
      VB:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile*
        name: Base64EncodeBinaryFile
        nameWithType: ByteArrayBase64Converters.Base64EncodeBinaryFile
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile
    isDefinition: true
    commentId: Overload:WizardWrx.Core.ByteArrayBase64Converters.Base64EncodeBinaryFile
  WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File*:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File*
        name: Base64DecodeByteArray2File
        nameWithType: ByteArrayBase64Converters.Base64DecodeByteArray2File
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File
      VB:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File*
        name: Base64DecodeByteArray2File
        nameWithType: ByteArrayBase64Converters.Base64DecodeByteArray2File
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File
    isDefinition: true
    commentId: Overload:WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray2File
  WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray*:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray*
        name: Base64DecodeByteArray
        nameWithType: ByteArrayBase64Converters.Base64DecodeByteArray
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray
      VB:
      - id: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray*
        name: Base64DecodeByteArray
        nameWithType: ByteArrayBase64Converters.Base64DecodeByteArray
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray
    isDefinition: true
    commentId: Overload:WizardWrx.Core.ByteArrayBase64Converters.Base64DecodeByteArray
  WizardWrx.Core.ByteArrayBase64Converters:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayBase64Converters
        name: ByteArrayBase64Converters
        nameWithType: ByteArrayBase64Converters
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters
      VB:
      - id: WizardWrx.Core.ByteArrayBase64Converters
        name: ByteArrayBase64Converters
        nameWithType: ByteArrayBase64Converters
        qualifiedName: WizardWrx.Core.ByteArrayBase64Converters
    isDefinition: true
    commentId: T:WizardWrx.Core.ByteArrayBase64Converters
  WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString*:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString*
        name: ByteArrayToHexDigitString
        nameWithType: ByteArrayFormatters.ByteArrayToHexDigitString
        qualifiedName: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString
      VB:
      - id: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString*
        name: ByteArrayToHexDigitString
        nameWithType: ByteArrayFormatters.ByteArrayToHexDigitString
        qualifiedName: WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.ByteArrayFormatters.ByteArrayToHexDigitString
  WizardWrx.Core.ByteArrayFormatters:
    name:
      CSharp:
      - id: WizardWrx.Core.ByteArrayFormatters
        name: ByteArrayFormatters
        nameWithType: ByteArrayFormatters
        qualifiedName: WizardWrx.Core.ByteArrayFormatters
      VB:
      - id: WizardWrx.Core.ByteArrayFormatters
        name: ByteArrayFormatters
        nameWithType: ByteArrayFormatters
        qualifiedName: WizardWrx.Core.ByteArrayFormatters
    isDefinition: true
    commentId: T:WizardWrx.Core.ByteArrayFormatters
  WizardWrx.Core.CmdLneArgsBasic.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.#ctor*
        name: CmdLneArgsBasic
        nameWithType: CmdLneArgsBasic.CmdLneArgsBasic
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.#ctor*
        name: CmdLneArgsBasic
        nameWithType: CmdLneArgsBasic.CmdLneArgsBasic
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.CmdLneArgsBasic
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.#ctor
  System.Collections.Generic.Dictionary{System.Char,System.String}:
    name:
      CSharp:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.Char
        name: Char
        nameWithType: Char
        qualifiedName: System.Char
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.Dictionary`2
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.Dictionary{System.Char,System.String}
  System.Collections.Generic.Dictionary{System.String,System.String}:
    name:
      CSharp:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.Dictionary`2
        name: Dictionary
        nameWithType: Dictionary
        qualifiedName: System.Collections.Generic.Dictionary
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.Dictionary`2
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.Dictionary{System.String,System.String}
  WizardWrx.Core.CmdLneArgsBasic.ArgMatching:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
        name: CmdLneArgsBasic.ArgMatching
        nameWithType: CmdLneArgsBasic.ArgMatching
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
        name: CmdLneArgsBasic.ArgMatching
        nameWithType: CmdLneArgsBasic.ArgMatching
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgMatching
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.CmdLneArgsBasic.ArgMatching
  WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases*
        name: GetArgByMultipleAliases
        nameWithType: CmdLneArgsBasic.GetArgByMultipleAliases
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases*
        name: GetArgByMultipleAliases
        nameWithType: CmdLneArgsBasic.GetArgByMultipleAliases
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByMultipleAliases
  WizardWrx.Core.CmdLneArgsBasic.GetArgByName*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByName*
        name: GetArgByName
        nameWithType: CmdLneArgsBasic.GetArgByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByName
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByName*
        name: GetArgByName
        nameWithType: CmdLneArgsBasic.GetArgByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByName
  WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*
        name: GetArgByNameAsChar
        nameWithType: CmdLneArgsBasic.GetArgByNameAsChar
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar*
        name: GetArgByNameAsChar
        nameWithType: CmdLneArgsBasic.GetArgByNameAsChar
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsChar
  WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*
        name: GetArgByNameAsInt
        nameWithType: CmdLneArgsBasic.GetArgByNameAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt*
        name: GetArgByNameAsInt
        nameWithType: CmdLneArgsBasic.GetArgByNameAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByNameAsInt
  WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition*
        name: GetArgByPosition
        nameWithType: CmdLneArgsBasic.GetArgByPosition
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition*
        name: GetArgByPosition
        nameWithType: CmdLneArgsBasic.GetArgByPosition
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByPosition
  WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt*
        name: GetArgByPositionAsInt
        nameWithType: CmdLneArgsBasic.GetArgByPositionAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt*
        name: GetArgByPositionAsInt
        nameWithType: CmdLneArgsBasic.GetArgByPositionAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetArgByPositionAsInt
  WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName*
        name: GetBooleanSwitchByName
        nameWithType: CmdLneArgsBasic.GetBooleanSwitchByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName*
        name: GetBooleanSwitchByName
        nameWithType: CmdLneArgsBasic.GetBooleanSwitchByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetBooleanSwitchByName
  WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*
        name: GetSwitchByName
        nameWithType: CmdLneArgsBasic.GetSwitchByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName*
        name: GetSwitchByName
        nameWithType: CmdLneArgsBasic.GetSwitchByName
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByName
  WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*
        name: GetSwitchByNameAsInt
        nameWithType: CmdLneArgsBasic.GetSwitchByNameAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt*
        name: GetSwitchByNameAsInt
        nameWithType: CmdLneArgsBasic.GetSwitchByNameAsInt
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.GetSwitchByNameAsInt
  WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue*
        name: ArgNameFromKeyValue
        nameWithType: CmdLneArgsBasic.ArgNameFromKeyValue
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue*
        name: ArgNameFromKeyValue
        nameWithType: CmdLneArgsBasic.ArgNameFromKeyValue
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ArgNameFromKeyValue
  System.ArgumentException:
    commentId: T:System.ArgumentException
  WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString*
        name: FirstCharFromString
        nameWithType: CmdLneArgsBasic.FirstCharFromString
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString*
        name: FirstCharFromString
        nameWithType: CmdLneArgsBasic.FirstCharFromString
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.FirstCharFromString
  WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty*
        name: ArgListIsEmpty
        nameWithType: CmdLneArgsBasic.ArgListIsEmpty
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty*
        name: ArgListIsEmpty
        nameWithType: CmdLneArgsBasic.ArgListIsEmpty
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ArgListIsEmpty
  WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault*
        name: AllowEmptyStringAsDefault
        nameWithType: CmdLneArgsBasic.AllowEmptyStringAsDefault
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault*
        name: AllowEmptyStringAsDefault
        nameWithType: CmdLneArgsBasic.AllowEmptyStringAsDefault
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.AllowEmptyStringAsDefault
  WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching*
        name: ArgumentMatching
        nameWithType: CmdLneArgsBasic.ArgumentMatching
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching*
        name: ArgumentMatching
        nameWithType: CmdLneArgsBasic.ArgumentMatching
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ArgumentMatching
  WizardWrx.Core.CmdLneArgsBasic.ArgType[]:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgType
        name: CmdLneArgsBasic.ArgType
        nameWithType: CmdLneArgsBasic.ArgType
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgType
      - name: '[]'
        nameWithType: '[]'
        qualifiedName: '[]'
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgType
        name: CmdLneArgsBasic.ArgType
        nameWithType: CmdLneArgsBasic.ArgType
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgType
      - name: ()
        nameWithType: ()
        qualifiedName: ()
    isDefinition: false
  WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray*
        name: ArgumentTypeArray
        nameWithType: CmdLneArgsBasic.ArgumentTypeArray
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray*
        name: ArgumentTypeArray
        nameWithType: CmdLneArgsBasic.ArgumentTypeArray
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ArgumentTypeArray
  WizardWrx.Core.CmdLneArgsBasic.Count*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.Count*
        name: Count
        nameWithType: CmdLneArgsBasic.Count
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.Count
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.Count*
        name: Count
        nameWithType: CmdLneArgsBasic.Count
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.Count
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.Count
  WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs*
        name: DefinedNamedArgs
        nameWithType: CmdLneArgsBasic.DefinedNamedArgs
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs*
        name: DefinedNamedArgs
        nameWithType: CmdLneArgsBasic.DefinedNamedArgs
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.DefinedNamedArgs
  WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches*
        name: DefinedSwitches
        nameWithType: CmdLneArgsBasic.DefinedSwitches
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches*
        name: DefinedSwitches
        nameWithType: CmdLneArgsBasic.DefinedSwitches
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.DefinedSwitches
  WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount*
        name: InvalidArgsCount
        nameWithType: CmdLneArgsBasic.InvalidArgsCount
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount*
        name: InvalidArgsCount
        nameWithType: CmdLneArgsBasic.InvalidArgsCount
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.InvalidArgsCount
  WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd*
        name: InvalidNamedArgsInCmd
        nameWithType: CmdLneArgsBasic.InvalidNamedArgsInCmd
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd*
        name: InvalidNamedArgsInCmd
        nameWithType: CmdLneArgsBasic.InvalidNamedArgsInCmd
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.InvalidNamedArgsInCmd
  WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd*
        name: InvalidSwitchesInCmd
        nameWithType: CmdLneArgsBasic.InvalidSwitchesInCmd
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd*
        name: InvalidSwitchesInCmd
        nameWithType: CmdLneArgsBasic.InvalidSwitchesInCmd
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.InvalidSwitchesInCmd
  WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine*
        name: PositionalArgsInCmdLine
        nameWithType: CmdLneArgsBasic.PositionalArgsInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine*
        name: PositionalArgsInCmdLine
        nameWithType: CmdLneArgsBasic.PositionalArgsInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.PositionalArgsInCmdLine
  WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF*
        name: SWITCH_IS_OFF
        nameWithType: CmdLneArgsBasic.SWITCH_IS_OFF
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF*
        name: SWITCH_IS_OFF
        nameWithType: CmdLneArgsBasic.SWITCH_IS_OFF
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_OFF
  WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON*
        name: SWITCH_IS_ON
        nameWithType: CmdLneArgsBasic.SWITCH_IS_ON
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON*
        name: SWITCH_IS_ON
        nameWithType: CmdLneArgsBasic.SWITCH_IS_ON
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.SWITCH_IS_ON
  WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine*
        name: ValidNamedArgsInCmdLine
        nameWithType: CmdLneArgsBasic.ValidNamedArgsInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine*
        name: ValidNamedArgsInCmdLine
        nameWithType: CmdLneArgsBasic.ValidNamedArgsInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ValidNamedArgsInCmdLine
  WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine*:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine*
        name: ValidSwitchesInCmdLine
        nameWithType: CmdLneArgsBasic.ValidSwitchesInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine*
        name: ValidSwitchesInCmdLine
        nameWithType: CmdLneArgsBasic.ValidSwitchesInCmdLine
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
    isDefinition: true
    commentId: Overload:WizardWrx.Core.CmdLneArgsBasic.ValidSwitchesInCmdLine
  WizardWrx.Core.CmdLneArgsBasic:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic
        name: CmdLneArgsBasic
        nameWithType: CmdLneArgsBasic
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic
        name: CmdLneArgsBasic
        nameWithType: CmdLneArgsBasic
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic
    isDefinition: true
    commentId: T:WizardWrx.Core.CmdLneArgsBasic
  ? WizardWrx.Core.CmdLneArgsBasic.ArgMatching.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<CmdLneArgsBasic.ArgMatching>
        nameWithType: StringExtensions.RenderEvenWhenNull<CmdLneArgsBasic.ArgMatching>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.Core.CmdLneArgsBasic.ArgMatching>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of CmdLneArgsBasic.ArgMatching)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of CmdLneArgsBasic.ArgMatching)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.Core.CmdLneArgsBasic.ArgMatching)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  ? WizardWrx.Core.CmdLneArgsBasic.ArgType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<CmdLneArgsBasic.ArgType>
        nameWithType: StringExtensions.RenderEvenWhenNull<CmdLneArgsBasic.ArgType>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.Core.CmdLneArgsBasic.ArgType>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of CmdLneArgsBasic.ArgType)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of CmdLneArgsBasic.ArgType)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.Core.CmdLneArgsBasic.ArgType)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  WizardWrx.Core.CmdLneArgsBasic.ArgType:
    name:
      CSharp:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgType
        name: CmdLneArgsBasic.ArgType
        nameWithType: CmdLneArgsBasic.ArgType
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgType
      VB:
      - id: WizardWrx.Core.CmdLneArgsBasic.ArgType
        name: CmdLneArgsBasic.ArgType
        nameWithType: CmdLneArgsBasic.ArgType
        qualifiedName: WizardWrx.Core.CmdLneArgsBasic.ArgType
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.CmdLneArgsBasic.ArgType
  WizardWrx.Core.EnvTokenExpander:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander
        name: EnvTokenExpander
        nameWithType: EnvTokenExpander
        qualifiedName: WizardWrx.Core.EnvTokenExpander
      VB:
      - id: WizardWrx.Core.EnvTokenExpander
        name: EnvTokenExpander
        nameWithType: EnvTokenExpander
        qualifiedName: WizardWrx.Core.EnvTokenExpander
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.EnvTokenExpander
  WizardWrx.Core.EnvTokenExpander.GetTokenExpander*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.GetTokenExpander*
        name: GetTokenExpander
        nameWithType: EnvTokenExpander.GetTokenExpander
        qualifiedName: WizardWrx.Core.EnvTokenExpander.GetTokenExpander
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.GetTokenExpander*
        name: GetTokenExpander
        nameWithType: EnvTokenExpander.GetTokenExpander
        qualifiedName: WizardWrx.Core.EnvTokenExpander.GetTokenExpander
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.GetTokenExpander
  WizardWrx.Core.EnvTokenExpander.Acquire*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.Acquire*
        name: Acquire
        nameWithType: EnvTokenExpander.Acquire
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Acquire
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.Acquire*
        name: Acquire
        nameWithType: EnvTokenExpander.Acquire
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Acquire
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.Acquire
  WizardWrx.Core.EnvTokenExpander.ContainsEnvToken*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken*
        name: ContainsEnvToken
        nameWithType: EnvTokenExpander.ContainsEnvToken
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken*
        name: ContainsEnvToken
        nameWithType: EnvTokenExpander.ContainsEnvToken
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ContainsEnvToken
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.ContainsEnvToken
  WizardWrx.Core.EnvTokenExpander.ExtractEnvToken*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken*
        name: ExtractEnvToken
        nameWithType: EnvTokenExpander.ExtractEnvToken
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken*
        name: ExtractEnvToken
        nameWithType: EnvTokenExpander.ExtractEnvToken
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ExtractEnvToken
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.ExtractEnvToken
  WizardWrx.Core.EnvTokenExpander.Free*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.Free*
        name: Free
        nameWithType: EnvTokenExpander.Free
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Free
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.Free*
        name: Free
        nameWithType: EnvTokenExpander.Free
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Free
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.Free
  WizardWrx.Core.EnvTokenExpander.Busy*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.Busy*
        name: Busy
        nameWithType: EnvTokenExpander.Busy
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Busy
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.Busy*
        name: Busy
        nameWithType: EnvTokenExpander.Busy
        qualifiedName: WizardWrx.Core.EnvTokenExpander.Busy
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.Busy
  WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens*
        name: ExpandEnvironmentTokens
        nameWithType: EnvTokenExpander.ExpandEnvironmentTokens
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens*
        name: ExpandEnvironmentTokens
        nameWithType: EnvTokenExpander.ExpandEnvironmentTokens
        qualifiedName: WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.ExpandEnvironmentTokens
  WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName*:
    name:
      CSharp:
      - id: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName*
        name: TokenizeEnvVarName
        nameWithType: EnvTokenExpander.TokenizeEnvVarName
        qualifiedName: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName
      VB:
      - id: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName*
        name: TokenizeEnvVarName
        nameWithType: EnvTokenExpander.TokenizeEnvVarName
        qualifiedName: WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.EnvTokenExpander.TokenizeEnvVarName
  WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        name: ASSEMBLYDATAPATH_TOKEN
        nameWithType: AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        name: ASSEMBLYDATAPATH_TOKEN
        nameWithType: AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: F:WizardWrx.Core.AssemblyLocatorBase.ASSEMBLYDATAPATH_TOKEN
  WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
        name: _strAssemblyLocation
        nameWithType: AssemblyLocatorBase._strAssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
        name: _strAssemblyLocation
        nameWithType: AssemblyLocatorBase._strAssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: F:WizardWrx.Core.AssemblyLocatorBase._strAssemblyLocation
  WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
        name: AssemblyDataPath
        nameWithType: AssemblyLocatorBase.AssemblyDataPath
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
        name: AssemblyDataPath
        nameWithType: AssemblyLocatorBase.AssemblyDataPath
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.AssemblyDataPath
  WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
        name: AssemblyLocation
        nameWithType: AssemblyLocatorBase.AssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
        name: AssemblyLocation
        nameWithType: AssemblyLocatorBase.AssemblyLocation
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.AssemblyLocation
  WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
        name: RecoveredConfigurationExceptions
        nameWithType: AssemblyLocatorBase.RecoveredConfigurationExceptions
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
        name: RecoveredConfigurationExceptions
        nameWithType: AssemblyLocatorBase.RecoveredConfigurationExceptions
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.RecoveredConfigurationExceptions
  WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
        name: MissingConfigSettings
        nameWithType: AssemblyLocatorBase.MissingConfigSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
        name: MissingConfigSettings
        nameWithType: AssemblyLocatorBase.MissingConfigSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.MissingConfigSettings
  WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
        name: DLLConfiguration
        nameWithType: AssemblyLocatorBase.DLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
        name: DLLConfiguration
        nameWithType: AssemblyLocatorBase.DLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLConfiguration
  WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
        name: DLLSettingsSection
        nameWithType: AssemblyLocatorBase.DLLSettingsSection
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
        name: DLLSettingsSection
        nameWithType: AssemblyLocatorBase.DLLSettingsSection
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLSettingsSection
  WizardWrx.Core.AssemblyLocatorBase.DLLSettings:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
        name: DLLSettings
        nameWithType: AssemblyLocatorBase.DLLSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
        name: DLLSettings
        nameWithType: AssemblyLocatorBase.DLLSettings
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.DLLSettings
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: P:WizardWrx.Core.AssemblyLocatorBase.DLLSettings
  WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion:
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
        name: GetAssemblyVersion
        nameWithType: AssemblyLocatorBase.GetAssemblyVersion
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
        name: GetAssemblyVersion
        nameWithType: AssemblyLocatorBase.GetAssemblyVersion
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetAssemblyVersion
  WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String):
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
        name: GetDLLSetting
        nameWithType: AssemblyLocatorBase.GetDLLSetting
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
        name: GetDLLSetting
        nameWithType: AssemblyLocatorBase.GetDLLSetting
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: M:WizardWrx.Core.AssemblyLocatorBase.GetDLLSetting(System.String)
  WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type):
    name:
      CSharp:
      - id: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
        name: SetPropertiesFromDLLConfiguration
        nameWithType: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Type
        name: Type
        nameWithType: Type
        qualifiedName: System.Type
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
        name: SetPropertiesFromDLLConfiguration
        nameWithType: AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
        qualifiedName: WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.Type
        name: Type
        nameWithType: Type
        qualifiedName: System.Type
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: WizardWrx.Core.AssemblyLocatorBase
    commentId: M:WizardWrx.Core.AssemblyLocatorBase.SetPropertiesFromDLLConfiguration(System.Type)
  WizardWrx.Core.PropertyDefaults.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults.#ctor*
        name: PropertyDefaults
        nameWithType: PropertyDefaults.PropertyDefaults
        qualifiedName: WizardWrx.Core.PropertyDefaults.PropertyDefaults
      VB:
      - id: WizardWrx.Core.PropertyDefaults.#ctor*
        name: PropertyDefaults
        nameWithType: PropertyDefaults.PropertyDefaults
        qualifiedName: WizardWrx.Core.PropertyDefaults.PropertyDefaults
    isDefinition: true
    commentId: Overload:WizardWrx.Core.PropertyDefaults.#ctor
  WizardWrx.Core.PropertyDefaults.ValuesCollection*:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults.ValuesCollection*
        name: ValuesCollection
        nameWithType: PropertyDefaults.ValuesCollection
        qualifiedName: WizardWrx.Core.PropertyDefaults.ValuesCollection
      VB:
      - id: WizardWrx.Core.PropertyDefaults.ValuesCollection*
        name: ValuesCollection
        nameWithType: PropertyDefaults.ValuesCollection
        qualifiedName: WizardWrx.Core.PropertyDefaults.ValuesCollection
    isDefinition: true
    commentId: Overload:WizardWrx.Core.PropertyDefaults.ValuesCollection
  WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate*:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate*
        name: GetAssemblyBuildDate
        nameWithType: PropertyDefaults.GetAssemblyBuildDate
        qualifiedName: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate
      VB:
      - id: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate*
        name: GetAssemblyBuildDate
        nameWithType: PropertyDefaults.GetAssemblyBuildDate
        qualifiedName: WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate
    isDefinition: true
    commentId: Overload:WizardWrx.Core.PropertyDefaults.GetAssemblyBuildDate
  WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString*:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString*
        name: GetAssemblyVersionString
        nameWithType: PropertyDefaults.GetAssemblyVersionString
        qualifiedName: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString
      VB:
      - id: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString*
        name: GetAssemblyVersionString
        nameWithType: PropertyDefaults.GetAssemblyVersionString
        qualifiedName: WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.PropertyDefaults.GetAssemblyVersionString
  WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues*:
    name:
      CSharp:
      - id: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues*
        name: EnumerateMissingConfigurationValues
        nameWithType: PropertyDefaults.EnumerateMissingConfigurationValues
        qualifiedName: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues
      VB:
      - id: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues*
        name: EnumerateMissingConfigurationValues
        nameWithType: PropertyDefaults.EnumerateMissingConfigurationValues
        qualifiedName: WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues
    isDefinition: true
    commentId: Overload:WizardWrx.Core.PropertyDefaults.EnumerateMissingConfigurationValues
  Microsoft.Win32:
    name:
      CSharp:
      - name: Microsoft.Win32
        nameWithType: Microsoft.Win32
        qualifiedName: Microsoft.Win32
        isExternal: true
      VB:
      - name: Microsoft.Win32
        nameWithType: Microsoft.Win32
        qualifiedName: Microsoft.Win32
    isDefinition: true
    commentId: N:Microsoft.Win32
  Microsoft.Win32.RegistryKey:
    name:
      CSharp:
      - id: Microsoft.Win32.RegistryKey
        name: RegistryKey
        nameWithType: RegistryKey
        qualifiedName: Microsoft.Win32.RegistryKey
        isExternal: true
      VB:
      - id: Microsoft.Win32.RegistryKey
        name: RegistryKey
        nameWithType: RegistryKey
        qualifiedName: Microsoft.Win32.RegistryKey
        isExternal: true
    isDefinition: true
    parent: Microsoft.Win32
    commentId: T:Microsoft.Win32.RegistryKey
  WizardWrx.Core.RegistryValues.RegQueryValue*:
    name:
      CSharp:
      - id: WizardWrx.Core.RegistryValues.RegQueryValue*
        name: RegQueryValue
        nameWithType: RegistryValues.RegQueryValue
        qualifiedName: WizardWrx.Core.RegistryValues.RegQueryValue
      VB:
      - id: WizardWrx.Core.RegistryValues.RegQueryValue*
        name: RegQueryValue
        nameWithType: RegistryValues.RegQueryValue
        qualifiedName: WizardWrx.Core.RegistryValues.RegQueryValue
    isDefinition: true
    commentId: Overload:WizardWrx.Core.RegistryValues.RegQueryValue
  WizardWrx.Core.RegistryValues.ValueExists*:
    name:
      CSharp:
      - id: WizardWrx.Core.RegistryValues.ValueExists*
        name: ValueExists
        nameWithType: RegistryValues.ValueExists
        qualifiedName: WizardWrx.Core.RegistryValues.ValueExists
      VB:
      - id: WizardWrx.Core.RegistryValues.ValueExists*
        name: ValueExists
        nameWithType: RegistryValues.ValueExists
        qualifiedName: WizardWrx.Core.RegistryValues.ValueExists
    isDefinition: true
    commentId: Overload:WizardWrx.Core.RegistryValues.ValueExists
  WizardWrx.Core.RegistryValues:
    name:
      CSharp:
      - id: WizardWrx.Core.RegistryValues
        name: RegistryValues
        nameWithType: RegistryValues
        qualifiedName: WizardWrx.Core.RegistryValues
      VB:
      - id: WizardWrx.Core.RegistryValues
        name: RegistryValues
        nameWithType: RegistryValues
        qualifiedName: WizardWrx.Core.RegistryValues
    isDefinition: true
    commentId: T:WizardWrx.Core.RegistryValues
  WizardWrx.Core.StringFixups.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.#ctor*
        name: StringFixups
        nameWithType: StringFixups.StringFixups
        qualifiedName: WizardWrx.Core.StringFixups.StringFixups
      VB:
      - id: WizardWrx.Core.StringFixups.#ctor*
        name: StringFixups
        nameWithType: StringFixups.StringFixups
        qualifiedName: WizardWrx.Core.StringFixups.StringFixups
    isDefinition: true
    commentId: Overload:WizardWrx.Core.StringFixups.#ctor
  WizardWrx.Core.StringFixups.ApplyFixups*:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.ApplyFixups*
        name: ApplyFixups
        nameWithType: StringFixups.ApplyFixups
        qualifiedName: WizardWrx.Core.StringFixups.ApplyFixups
      VB:
      - id: WizardWrx.Core.StringFixups.ApplyFixups*
        name: ApplyFixups
        nameWithType: StringFixups.ApplyFixups
        qualifiedName: WizardWrx.Core.StringFixups.ApplyFixups
    isDefinition: true
    commentId: Overload:WizardWrx.Core.StringFixups.ApplyFixups
  WizardWrx.Core.StringFixups:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups
        name: StringFixups
        nameWithType: StringFixups
        qualifiedName: WizardWrx.Core.StringFixups
      VB:
      - id: WizardWrx.Core.StringFixups
        name: StringFixups
        nameWithType: StringFixups
        qualifiedName: WizardWrx.Core.StringFixups
    isDefinition: true
    commentId: T:WizardWrx.Core.StringFixups
  WizardWrx.Core.StringFixups.StringFixup.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.StringFixup.#ctor*
        name: StringFixup
        nameWithType: StringFixups.StringFixup.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup.StringFixup
      VB:
      - id: WizardWrx.Core.StringFixups.StringFixup.#ctor*
        name: StringFixup
        nameWithType: StringFixups.StringFixup.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup.StringFixup
    isDefinition: true
    commentId: Overload:WizardWrx.Core.StringFixups.StringFixup.#ctor
  WizardWrx.Core.StringFixups.StringFixup.ToString*:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.StringFixup.ToString*
        name: ToString
        nameWithType: StringFixups.StringFixup.ToString
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup.ToString
      VB:
      - id: WizardWrx.Core.StringFixups.StringFixup.ToString*
        name: ToString
        nameWithType: StringFixups.StringFixup.ToString
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup.ToString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.StringFixups.StringFixup.ToString
  WizardWrx.Core.StringFixups.StringFixup:
    name:
      CSharp:
      - id: WizardWrx.Core.StringFixups.StringFixup
        name: StringFixups.StringFixup
        nameWithType: StringFixups.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup
      VB:
      - id: WizardWrx.Core.StringFixups.StringFixup
        name: StringFixups.StringFixup
        nameWithType: StringFixups.StringFixup
        qualifiedName: WizardWrx.Core.StringFixups.StringFixup
    isDefinition: true
    commentId: T:WizardWrx.Core.StringFixups.StringFixup
  WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
        name: TimeDisplayFormatter.DateFieldOrder
        nameWithType: TimeDisplayFormatter.DateFieldOrder
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
        name: TimeDisplayFormatter.DateFieldOrder
        nameWithType: TimeDisplayFormatter.DateFieldOrder
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder
  WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat*
        name: CalendarDateFormat
        nameWithType: TimeDisplayFormatter.CalendarDateFormat
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat*
        name: CalendarDateFormat
        nameWithType: TimeDisplayFormatter.CalendarDateFormat
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.CalendarDateFormat
  WizardWrx.Core.TimeDisplayFormatter.HoursFormatType:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
        name: TimeDisplayFormatter.HoursFormatType
        nameWithType: TimeDisplayFormatter.HoursFormatType
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
        name: TimeDisplayFormatter.HoursFormatType
        nameWithType: TimeDisplayFormatter.HoursFormatType
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.HoursFormatType
  WizardWrx.Core.TimeDisplayFormatter.HoursFormat*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormat*
        name: HoursFormat
        nameWithType: TimeDisplayFormatter.HoursFormat
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.HoursFormat
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.HoursFormat*
        name: HoursFormat
        nameWithType: TimeDisplayFormatter.HoursFormat
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.HoursFormat
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.HoursFormat
  System.TimeZone:
    name:
      CSharp:
      - id: System.TimeZone
        name: TimeZone
        nameWithType: TimeZone
        qualifiedName: System.TimeZone
        isExternal: true
      VB:
      - id: System.TimeZone
        name: TimeZone
        nameWithType: TimeZone
        qualifiedName: System.TimeZone
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.TimeZone
  WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone*
        name: MachineTimeZone
        nameWithType: TimeDisplayFormatter.MachineTimeZone
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone*
        name: MachineTimeZone
        nameWithType: TimeDisplayFormatter.MachineTimeZone
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.MachineTimeZone
  WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC*
        name: ShowAmPmAsUC
        nameWithType: TimeDisplayFormatter.ShowAmPmAsUC
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC*
        name: ShowAmPmAsUC
        nameWithType: TimeDisplayFormatter.ShowAmPmAsUC
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.ShowAmPmAsUC
  WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone*
        name: ShowTimeZone
        nameWithType: TimeDisplayFormatter.ShowTimeZone
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone*
        name: ShowTimeZone
        nameWithType: TimeDisplayFormatter.ShowTimeZone
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.ShowTimeZone
  WizardWrx.Core.TimeDisplayFormatter.ShowWeekday*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday*
        name: ShowWeekday
        nameWithType: TimeDisplayFormatter.ShowWeekday
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday*
        name: ShowWeekday
        nameWithType: TimeDisplayFormatter.ShowWeekday
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.ShowWeekday
  WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
        name: TimeDisplayFormatter.TimePrecisionType
        nameWithType: TimeDisplayFormatter.TimePrecisionType
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
        name: TimeDisplayFormatter.TimePrecisionType
        nameWithType: TimeDisplayFormatter.TimePrecisionType
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType
  WizardWrx.Core.TimeDisplayFormatter.TimePrecision*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecision*
        name: TimePrecision
        nameWithType: TimeDisplayFormatter.TimePrecision
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimePrecision
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.TimePrecision*
        name: TimePrecision
        nameWithType: TimeDisplayFormatter.TimePrecision
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimePrecision
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.TimePrecision
  WizardWrx.Core.TimeDisplayFormatter.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.#ctor*
        name: TimeDisplayFormatter
        nameWithType: TimeDisplayFormatter.TimeDisplayFormatter
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimeDisplayFormatter
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.#ctor*
        name: TimeDisplayFormatter
        nameWithType: TimeDisplayFormatter.TimeDisplayFormatter
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.TimeDisplayFormatter
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.#ctor
  WizardWrx.Core.TimeDisplayFormatter.FormatThisTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime*
        name: FormatThisTime
        nameWithType: TimeDisplayFormatter.FormatThisTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime*
        name: FormatThisTime
        nameWithType: TimeDisplayFormatter.FormatThisTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.FormatThisTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.FormatThisTime
  WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime*
        name: FormatCurrentTime
        nameWithType: TimeDisplayFormatter.FormatCurrentTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime*
        name: FormatCurrentTime
        nameWithType: TimeDisplayFormatter.FormatCurrentTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.FormatCurrentTime
  WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime*
        name: GetTimeZoneForTime
        nameWithType: TimeDisplayFormatter.GetTimeZoneForTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime*
        name: GetTimeZoneForTime
        nameWithType: TimeDisplayFormatter.GetTimeZoneForTime
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.GetTimeZoneForTime
  WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes*:
    name:
      CSharp:
      - id: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes*
        name: PrepareLocalAndUTCTimes
        nameWithType: TimeDisplayFormatter.PrepareLocalAndUTCTimes
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes
      VB:
      - id: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes*
        name: PrepareLocalAndUTCTimes
        nameWithType: TimeDisplayFormatter.PrepareLocalAndUTCTimes
        qualifiedName: WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TimeDisplayFormatter.PrepareLocalAndUTCTimes
  ? WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<TimeDisplayFormatter.DateFieldOrder>
        nameWithType: StringExtensions.RenderEvenWhenNull<TimeDisplayFormatter.DateFieldOrder>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of TimeDisplayFormatter.DateFieldOrder)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of TimeDisplayFormatter.DateFieldOrder)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.Core.TimeDisplayFormatter.DateFieldOrder)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  ? WizardWrx.Core.TimeDisplayFormatter.HoursFormatType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<TimeDisplayFormatter.HoursFormatType>
        nameWithType: StringExtensions.RenderEvenWhenNull<TimeDisplayFormatter.HoursFormatType>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.Core.TimeDisplayFormatter.HoursFormatType>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of TimeDisplayFormatter.HoursFormatType)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of TimeDisplayFormatter.HoursFormatType)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.Core.TimeDisplayFormatter.HoursFormatType)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  ? WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType.WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
  : name:
      CSharp:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull<TimeDisplayFormatter.TimePrecisionType>
        nameWithType: StringExtensions.RenderEvenWhenNull<TimeDisplayFormatter.TimePrecisionType>
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull<WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType>
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: WizardWrx.StringExtensions.RenderEvenWhenNull``1(System.String,System.String,System.IFormatProvider)
        name: RenderEvenWhenNull(Of TimeDisplayFormatter.TimePrecisionType)
        nameWithType: StringExtensions.RenderEvenWhenNull(Of TimeDisplayFormatter.TimePrecisionType)
        qualifiedName: WizardWrx.StringExtensions.RenderEvenWhenNull(Of WizardWrx.Core.TimeDisplayFormatter.TimePrecisionType)
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.String
        name: String
        nameWithType: String
        qualifiedName: System.String
        isExternal: true
      - name: ', '
        nameWithType: ', '
        qualifiedName: ', '
      - id: System.IFormatProvider
        name: IFormatProvider
        nameWithType: IFormatProvider
        qualifiedName: System.IFormatProvider
        isExternal: true
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
    parent: WizardWrx.StringExtensions
    commentId: M:WizardWrx.StringExtensions.RenderEvenWhenNull``1(``0,System.String,System.String,System.IFormatProvider)
  System.IO.StreamWriter:
    name:
      CSharp:
      - id: System.IO.StreamWriter
        name: StreamWriter
        nameWithType: StreamWriter
        qualifiedName: System.IO.StreamWriter
        isExternal: true
      VB:
      - id: System.IO.StreamWriter
        name: StreamWriter
        nameWithType: StreamWriter
        qualifiedName: System.IO.StreamWriter
        isExternal: true
    isDefinition: true
    parent: System.IO
    commentId: T:System.IO.StreamWriter
  WizardWrx.Core.TraceLogger.ForceAutoFlush*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.ForceAutoFlush*
        name: ForceAutoFlush
        nameWithType: TraceLogger.ForceAutoFlush
        qualifiedName: WizardWrx.Core.TraceLogger.ForceAutoFlush
      VB:
      - id: WizardWrx.Core.TraceLogger.ForceAutoFlush*
        name: ForceAutoFlush
        nameWithType: TraceLogger.ForceAutoFlush
        qualifiedName: WizardWrx.Core.TraceLogger.ForceAutoFlush
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.ForceAutoFlush
  WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst*
        name: WriteWithBothTimesLabeledLocalFirst
        nameWithType: TraceLogger.WriteWithBothTimesLabeledLocalFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst*
        name: WriteWithBothTimesLabeledLocalFirst
        nameWithType: TraceLogger.WriteWithBothTimesLabeledLocalFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirst
  WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough*
        name: WriteWithBothTimesLabeledLocalFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough*
        name: WriteWithBothTimesLabeledLocalFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledLocalFirstWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst*
        name: WriteWithBothTimesLabeledUTCFirst
        nameWithType: TraceLogger.WriteWithBothTimesLabeledUTCFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst*
        name: WriteWithBothTimesLabeledUTCFirst
        nameWithType: TraceLogger.WriteWithBothTimesLabeledUTCFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirst
  WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough*
        name: WriteWithBothTimesLabeledUTCFirstWithPassTrhough
        nameWithType: TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough*
        name: WriteWithBothTimesLabeledUTCFirstWithPassTrhough
        nameWithType: TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesLabeledUTCFirstWithPassTrhough
  WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst*
        name: WriteWithBothTimesUnlabeledLocalFirst
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledLocalFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst*
        name: WriteWithBothTimesUnlabeledLocalFirst
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledLocalFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirst
  WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough*
        name: WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough*
        name: WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledLocalFirstWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst*
        name: WriteWithBothTimesUnlabeledUTCFirst
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledUTCFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst*
        name: WriteWithBothTimesUnlabeledUTCFirst
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledUTCFirst
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirst
  WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough*
        name: WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough*
        name: WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
        nameWithType: TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithBothTimesUnlabeledUTCFirstWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime*
        name: WriteWithLabeledLocalTime
        nameWithType: TraceLogger.WriteWithLabeledLocalTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime*
        name: WriteWithLabeledLocalTime
        nameWithType: TraceLogger.WriteWithLabeledLocalTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTime
  WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough*
        name: WriteWithLabeledLocalTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithLabeledLocalTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough*
        name: WriteWithLabeledLocalTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithLabeledLocalTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithLabeledLocalTimeWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime*
        name: WriteWithUnlabeledLocalTime
        nameWithType: TraceLogger.WriteWithUnlabeledLocalTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime*
        name: WriteWithUnlabeledLocalTime
        nameWithType: TraceLogger.WriteWithUnlabeledLocalTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTime
  WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough*
        name: WriteWithUnlabeledLocalTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough*
        name: WriteWithUnlabeledLocalTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithUnlabeledLocalTimeWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime*
        name: WriteWithLabeledUTCTime
        nameWithType: TraceLogger.WriteWithLabeledUTCTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime*
        name: WriteWithLabeledUTCTime
        nameWithType: TraceLogger.WriteWithLabeledUTCTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTime
  WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough*
        name: WriteWithLabeledUTCTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithLabeledUTCTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough*
        name: WriteWithLabeledUTCTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithLabeledUTCTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithLabeledUTCTimeWithPassThrough
  WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime*
        name: WriteWithUnlabeledUTCTime
        nameWithType: TraceLogger.WriteWithUnlabeledUTCTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime*
        name: WriteWithUnlabeledUTCTime
        nameWithType: TraceLogger.WriteWithUnlabeledUTCTime
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTime
  WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough*:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough*
        name: WriteWithUnlabeledUTCTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough
      VB:
      - id: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough*
        name: WriteWithUnlabeledUTCTimeWithPassThrough
        nameWithType: TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough
        qualifiedName: WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough
    isDefinition: true
    commentId: Overload:WizardWrx.Core.TraceLogger.WriteWithUnlabeledUTCTimeWithPassThrough
  WizardWrx.Core.TraceLogger:
    name:
      CSharp:
      - id: WizardWrx.Core.TraceLogger
        name: TraceLogger
        nameWithType: TraceLogger
        qualifiedName: WizardWrx.Core.TraceLogger
      VB:
      - id: WizardWrx.Core.TraceLogger
        name: TraceLogger
        nameWithType: TraceLogger
        qualifiedName: WizardWrx.Core.TraceLogger
    isDefinition: true
    commentId: T:WizardWrx.Core.TraceLogger
  WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.Core.UnconfiguredDLLSettings
        name: UnconfiguredDLLSettings
        nameWithType: UnconfiguredDLLSettings
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: WizardWrx.GenericSingletonBase`1
        name: GenericSingletonBase
        nameWithType: GenericSingletonBase
        qualifiedName: WizardWrx.GenericSingletonBase
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.Core.UnconfiguredDLLSettings
        name: UnconfiguredDLLSettings
        nameWithType: UnconfiguredDLLSettings
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: WizardWrx.GenericSingletonBase`1
    parent: WizardWrx
    commentId: T:WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}
  WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
        name: s_genTheOnlyInstance
        nameWithType: GenericSingletonBase<T>.s_genTheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase<T>.s_genTheOnlyInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
        name: s_genTheOnlyInstance
        nameWithType: GenericSingletonBase(Of T).s_genTheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of T).s_genTheOnlyInstance
    isDefinition: true
    commentId: F:WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
  WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.s_genTheOnlyInstance:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
        name: s_genTheOnlyInstance
        nameWithType: GenericSingletonBase<UnconfiguredDLLSettings>.s_genTheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase<WizardWrx.Core.UnconfiguredDLLSettings>.s_genTheOnlyInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
        name: s_genTheOnlyInstance
        nameWithType: GenericSingletonBase(Of UnconfiguredDLLSettings).s_genTheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of WizardWrx.Core.UnconfiguredDLLSettings).s_genTheOnlyInstance
    isDefinition: false
    definition: WizardWrx.GenericSingletonBase`1.s_genTheOnlyInstance
    parent: WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}
    commentId: F:WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.s_genTheOnlyInstance
  WizardWrx.GenericSingletonBase`1.TheOnlyInstance:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase<T>.TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase<T>.TheOnlyInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase(Of T).TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of T).TheOnlyInstance
    isDefinition: true
    commentId: P:WizardWrx.GenericSingletonBase`1.TheOnlyInstance
  WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.TheOnlyInstance:
    name:
      CSharp:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase<UnconfiguredDLLSettings>.TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase<WizardWrx.Core.UnconfiguredDLLSettings>.TheOnlyInstance
      VB:
      - id: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
        name: TheOnlyInstance
        nameWithType: GenericSingletonBase(Of UnconfiguredDLLSettings).TheOnlyInstance
        qualifiedName: WizardWrx.GenericSingletonBase(Of WizardWrx.Core.UnconfiguredDLLSettings).TheOnlyInstance
    isDefinition: false
    definition: WizardWrx.GenericSingletonBase`1.TheOnlyInstance
    parent: WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}
    commentId: P:WizardWrx.GenericSingletonBase{WizardWrx.Core.UnconfiguredDLLSettings}.TheOnlyInstance
  WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance*
        name: GetTheSingleInstance
        nameWithType: UnconfiguredDLLSettings.GetTheSingleInstance
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance*
        name: GetTheSingleInstance
        nameWithType: UnconfiguredDLLSettings.GetTheSingleInstance
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.GetTheSingleInstance
  WizardWrx.Core.UnconfiguredDLLSettings.Add*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.Add*
        name: Add
        nameWithType: UnconfiguredDLLSettings.Add
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.Add
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.Add*
        name: Add
        nameWithType: UnconfiguredDLLSettings.Add
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.Add
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.Add
  System.Collections.Generic.List{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}:
    name:
      CSharp:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.Collections.Generic.List`1
        name: List
        nameWithType: List
        qualifiedName: System.Collections.Generic.List
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.Collections.Generic.List`1
    parent: System.Collections.Generic
    commentId: T:System.Collections.Generic.List{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}
  WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile*
        name: GetMissingPropsForFile
        nameWithType: UnconfiguredDLLSettings.GetMissingPropsForFile
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile*
        name: GetMissingPropsForFile
        nameWithType: UnconfiguredDLLSettings.GetMissingPropsForFile
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.GetMissingPropsForFile
  WizardWrx.Core.UnconfiguredDLLSettings.Count*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.Count*
        name: Count
        nameWithType: UnconfiguredDLLSettings.Count
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.Count
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.Count*
        name: Count
        nameWithType: UnconfiguredDLLSettings.Count
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.Count
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.Count
  System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}:
    name:
      CSharp:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: <
        nameWithType: <
        qualifiedName: <
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: '>'
        nameWithType: '>'
        qualifiedName: '>'
      VB:
      - id: System.IComparable`1
        name: IComparable
        nameWithType: IComparable
        qualifiedName: System.IComparable
        isExternal: true
      - name: '(Of '
        nameWithType: '(Of '
        qualifiedName: '(Of '
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1
    parent: System
    commentId: T:System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor*
        name: UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor*
        name: UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.UnconfiguredSetting
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.#ctor
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName*
        name: ConfigFileName
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName*
        name: ConfigFileName
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ConfigFileName
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName*
        name: PropName
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.PropName
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName*
        name: PropName
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.PropName
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropName
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue*
        name: PropValue
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue*
        name: PropValue
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.PropValue
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
    isDefinition: true
    parent: WizardWrx.Core
    commentId: T:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
  ? WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo*
  : name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo*
        name: IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo*
        name: System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.System#IComparable{WizardWrx#Core#UnconfiguredDLLSettings#UnconfiguredSetting}#CompareTo
  ? System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}.CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
  : name:
      CSharp:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable<UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        qualifiedName: System.IComparable<WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting>.CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IComparable`1.CompareTo(`0)
        name: CompareTo
        nameWithType: IComparable(Of UnconfiguredDLLSettings.UnconfiguredSetting).CompareTo
        qualifiedName: System.IComparable(Of WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting).CompareTo
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
        name: UnconfiguredDLLSettings.UnconfiguredSetting
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: false
    definition: System.IComparable`1.CompareTo(`0)
    parent: System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}
    commentId: M:System.IComparable{WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting}.CompareTo(WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting)
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals*
        name: Equals
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.Equals
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals*
        name: Equals
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.Equals
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.Equals
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode*
        name: GetHashCode
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode*
        name: GetHashCode
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.GetHashCode
  WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString*
        name: ToString
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.ToString
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString
      VB:
      - id: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString*
        name: ToString
        nameWithType: UnconfiguredDLLSettings.UnconfiguredSetting.ToString
        qualifiedName: WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnconfiguredDLLSettings.UnconfiguredSetting.ToString
  System.IDisposable:
    name:
      CSharp:
      - id: System.IDisposable
        name: IDisposable
        nameWithType: IDisposable
        qualifiedName: System.IDisposable
        isExternal: true
      VB:
      - id: System.IDisposable
        name: IDisposable
        nameWithType: IDisposable
        qualifiedName: System.IDisposable
        isExternal: true
    isDefinition: true
    parent: System
    commentId: T:System.IDisposable
  System.IO.FileNotFoundException:
    commentId: T:System.IO.FileNotFoundException
  WizardWrx.Core.UnmanagedLibrary.#ctor*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnmanagedLibrary.#ctor*
        name: UnmanagedLibrary
        nameWithType: UnmanagedLibrary.UnmanagedLibrary
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.UnmanagedLibrary
      VB:
      - id: WizardWrx.Core.UnmanagedLibrary.#ctor*
        name: UnmanagedLibrary
        nameWithType: UnmanagedLibrary.UnmanagedLibrary
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.UnmanagedLibrary
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnmanagedLibrary.#ctor
  TDelegate:
    name:
      CSharp:
      - name: TDelegate
        nameWithType: TDelegate
        qualifiedName: TDelegate
      VB:
      - name: TDelegate
        nameWithType: TDelegate
        qualifiedName: TDelegate
    isDefinition: true
    commentId: '!:TDelegate'
  '{TDelegate}':
    name:
      CSharp:
      - name: TDelegate
        nameWithType: TDelegate
        qualifiedName: TDelegate
      VB:
      - name: TDelegate
        nameWithType: TDelegate
        qualifiedName: TDelegate
    isDefinition: false
    definition: TDelegate
    commentId: '!:TDelegate'
  WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction*
        name: GetUnmanagedFunction
        nameWithType: UnmanagedLibrary.GetUnmanagedFunction
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction
      VB:
      - id: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction*
        name: GetUnmanagedFunction
        nameWithType: UnmanagedLibrary.GetUnmanagedFunction
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction
  WizardWrx.Core.UnmanagedLibrary.Dispose*:
    name:
      CSharp:
      - id: WizardWrx.Core.UnmanagedLibrary.Dispose*
        name: Dispose
        nameWithType: UnmanagedLibrary.Dispose
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.Dispose
      VB:
      - id: WizardWrx.Core.UnmanagedLibrary.Dispose*
        name: Dispose
        nameWithType: UnmanagedLibrary.Dispose
        qualifiedName: WizardWrx.Core.UnmanagedLibrary.Dispose
    isDefinition: true
    commentId: Overload:WizardWrx.Core.UnmanagedLibrary.Dispose
  System.IDisposable.Dispose:
    name:
      CSharp:
      - id: System.IDisposable.Dispose
        name: Dispose
        nameWithType: IDisposable.Dispose
        qualifiedName: System.IDisposable.Dispose
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
      VB:
      - id: System.IDisposable.Dispose
        name: Dispose
        nameWithType: IDisposable.Dispose
        qualifiedName: System.IDisposable.Dispose
        isExternal: true
      - name: (
        nameWithType: (
        qualifiedName: (
      - name: )
        nameWithType: )
        qualifiedName: )
    isDefinition: true
    parent: System.IDisposable
    commentId: M:System.IDisposable.Dispose
  WizardWrx.Core.UnmanagedLibrary:
    name:
      CSharp:
      - id: WizardWrx.Core.UnmanagedLibrary
        name: UnmanagedLibrary
        nameWithType: UnmanagedLibrary
        qualifiedName: WizardWrx.Core.UnmanagedLibrary
      VB:
      - id: WizardWrx.Core.UnmanagedLibrary
        name: UnmanagedLibrary
        nameWithType: UnmanagedLibrary
        qualifiedName: WizardWrx.Core.UnmanagedLibrary
    isDefinition: true
    commentId: T:WizardWrx.Core.UnmanagedLibrary
  WizardWrx.Cryptography.DigestFile.MD5Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile.MD5Hash*
        name: MD5Hash
        nameWithType: DigestFile.MD5Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.MD5Hash
      VB:
      - id: WizardWrx.Cryptography.DigestFile.MD5Hash*
        name: MD5Hash
        nameWithType: DigestFile.MD5Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.MD5Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestFile.MD5Hash
  WizardWrx.Cryptography.DigestFile.SHA1Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile.SHA1Hash*
        name: SHA1Hash
        nameWithType: DigestFile.SHA1Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA1Hash
      VB:
      - id: WizardWrx.Cryptography.DigestFile.SHA1Hash*
        name: SHA1Hash
        nameWithType: DigestFile.SHA1Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA1Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestFile.SHA1Hash
  WizardWrx.Cryptography.DigestFile.SHA256Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile.SHA256Hash*
        name: SHA256Hash
        nameWithType: DigestFile.SHA256Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA256Hash
      VB:
      - id: WizardWrx.Cryptography.DigestFile.SHA256Hash*
        name: SHA256Hash
        nameWithType: DigestFile.SHA256Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA256Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestFile.SHA256Hash
  WizardWrx.Cryptography.DigestFile.SHA384Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile.SHA384Hash*
        name: SHA384Hash
        nameWithType: DigestFile.SHA384Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA384Hash
      VB:
      - id: WizardWrx.Cryptography.DigestFile.SHA384Hash*
        name: SHA384Hash
        nameWithType: DigestFile.SHA384Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA384Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestFile.SHA384Hash
  WizardWrx.Cryptography.DigestFile.SHA512Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile.SHA512Hash*
        name: SHA512Hash
        nameWithType: DigestFile.SHA512Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA512Hash
      VB:
      - id: WizardWrx.Cryptography.DigestFile.SHA512Hash*
        name: SHA512Hash
        nameWithType: DigestFile.SHA512Hash
        qualifiedName: WizardWrx.Cryptography.DigestFile.SHA512Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestFile.SHA512Hash
  WizardWrx.Cryptography.DigestFile:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestFile
        name: DigestFile
        nameWithType: DigestFile
        qualifiedName: WizardWrx.Cryptography.DigestFile
      VB:
      - id: WizardWrx.Cryptography.DigestFile
        name: DigestFile
        nameWithType: DigestFile
        qualifiedName: WizardWrx.Cryptography.DigestFile
    isDefinition: true
    commentId: T:WizardWrx.Cryptography.DigestFile
  WizardWrx.Cryptography.DigestString.SHA256Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestString.SHA256Hash*
        name: SHA256Hash
        nameWithType: DigestString.SHA256Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA256Hash
      VB:
      - id: WizardWrx.Cryptography.DigestString.SHA256Hash*
        name: SHA256Hash
        nameWithType: DigestString.SHA256Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA256Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestString.SHA256Hash
  WizardWrx.Cryptography.DigestString.SHA384Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestString.SHA384Hash*
        name: SHA384Hash
        nameWithType: DigestString.SHA384Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA384Hash
      VB:
      - id: WizardWrx.Cryptography.DigestString.SHA384Hash*
        name: SHA384Hash
        nameWithType: DigestString.SHA384Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA384Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestString.SHA384Hash
  WizardWrx.Cryptography.DigestString.SHA512Hash*:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestString.SHA512Hash*
        name: SHA512Hash
        nameWithType: DigestString.SHA512Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA512Hash
      VB:
      - id: WizardWrx.Cryptography.DigestString.SHA512Hash*
        name: SHA512Hash
        nameWithType: DigestString.SHA512Hash
        qualifiedName: WizardWrx.Cryptography.DigestString.SHA512Hash
    isDefinition: true
    commentId: Overload:WizardWrx.Cryptography.DigestString.SHA512Hash
  WizardWrx.Cryptography.DigestString:
    name:
      CSharp:
      - id: WizardWrx.Cryptography.DigestString
        name: DigestString
        nameWithType: DigestString
        qualifiedName: WizardWrx.Cryptography.DigestString
      VB:
      - id: WizardWrx.Cryptography.DigestString
        name: DigestString
        nameWithType: DigestString
        qualifiedName: WizardWrx.Cryptography.DigestString
    isDefinition: true
    commentId: T:WizardWrx.Cryptography.DigestString
  WizardWrx.Cryptography:
    name:
      CSharp:
      - name: WizardWrx.Cryptography
        nameWithType: WizardWrx.Cryptography
        qualifiedName: WizardWrx.Cryptography
      VB:
      - name: WizardWrx.Cryptography
        nameWithType: WizardWrx.Cryptography
        qualifiedName: WizardWrx.Cryptography
    isDefinition: true
    commentId: N:WizardWrx.Cryptography
