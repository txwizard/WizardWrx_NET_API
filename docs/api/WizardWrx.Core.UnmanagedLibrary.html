<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class UnmanagedLibrary
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class UnmanagedLibrary
   ">
    <meta name="generator" content="docfx 2.56.6.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="WizardWrx.Core.UnmanagedLibrary">
  
  
  <h1 id="WizardWrx_Core_UnmanagedLibrary" data-uid="WizardWrx.Core.UnmanagedLibrary" class="text-break">Class UnmanagedLibrary
  </h1>
  <div class="markdown level0 summary"><p>Utility class to wrap an unmanaged DLL and be responsible for freeing it</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><span class="xref">UnmanagedLibrary</span></div>
  </div>
  <div classs="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.IDisposable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <span class="xref">System.Object.ToString()</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="WizardWrx.Core.html">WizardWrx.Core</a></h6>
  <h6><strong>Assembly</strong>: WizardWrx.Core.dll</h6>
  <h5 id="WizardWrx_Core_UnmanagedLibrary_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed class UnmanagedLibrary : IDisposable</code></pre>
  </div>
  <h5 id="WizardWrx_Core_UnmanagedLibrary_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>This is a managed wrapper over the native LoadLibrary, GetProcAddress,
and FreeLibrary calls.</p>
<p>I didn't immediately notice the fact that this class is sealed, but not
static; hence, public UnmanagedLibrary ( string fileName ) is its one
and only public constructor. As insurance against accidentally creating
a useless, uninitialized instance, I added a default constructor, marked
as private.</p>
</div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="WizardWrx_Core_UnmanagedLibrary__ctor_" data-uid="WizardWrx.Core.UnmanagedLibrary.#ctor*"></a>
  <h4 id="WizardWrx_Core_UnmanagedLibrary__ctor_System_String_" data-uid="WizardWrx.Core.UnmanagedLibrary.#ctor(System.String)">UnmanagedLibrary(String)</h4>
  <div class="markdown level1 summary"><p>Constructor to load a DLL and be responsible for freeing it</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public UnmanagedLibrary(string fileName)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">fileName</span></td>
        <td><p>full path name of DLL to load</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="WizardWrx_Core_UnmanagedLibrary__ctor_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Throws exceptions on failure. Most common failure would be file-not-found, or
that the file is not a loadable image.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IO.FileNotFoundException</span></td>
        <td><p>if fileName cannot be found</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="WizardWrx_Core_UnmanagedLibrary_Dispose_" data-uid="WizardWrx.Core.UnmanagedLibrary.Dispose*"></a>
  <h4 id="WizardWrx_Core_UnmanagedLibrary_Dispose" data-uid="WizardWrx.Core.UnmanagedLibrary.Dispose">Dispose()</h4>
  <div class="markdown level1 summary"><p>Call FreeLibrary on the unmanaged DLL. All function pointers
handed out from this class become invalid after this.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Dispose()</code></pre>
  </div>
  <h5 id="WizardWrx_Core_UnmanagedLibrary_Dispose_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is very dangerous because it suddenly invalidate
everything retrieved from this DLL. This includes any functions
handed out via GetProcAddress, and potentially any objects returned
from those functions (which may have an implementation in the DLL).</p>
</div>
  
  
  <a id="WizardWrx_Core_UnmanagedLibrary_GetUnmanagedFunction_" data-uid="WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction*"></a>
  <h4 id="WizardWrx_Core_UnmanagedLibrary_GetUnmanagedFunction__1_System_String_" data-uid="WizardWrx.Core.UnmanagedLibrary.GetUnmanagedFunction``1(System.String)">GetUnmanagedFunction&lt;TDelegate&gt;(String)</h4>
  <div class="markdown level1 summary"><p>Dynamically lookup a function via kernel32!GetProcAddress.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TDelegate GetUnmanagedFunction&lt;TDelegate&gt;(string functionName)
    where TDelegate : class</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">functionName</span></td>
        <td><p>raw name of the function in the export table</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TDelegate</span></td>
        <td><p>null if function is not found, else a delegate to the unmanaged
function</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">TDelegate</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="WizardWrx_Core_UnmanagedLibrary_GetUnmanagedFunction__1_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GetProcAddress results are valid as long as the DLL is loaded. This
is very, very dangerous to use since you need to ensure that the DLL
is not unloaded until after you’re done with any objects implemented
by the DLL. For example, if you get a delegate that then gets an
IUnknown implemented by this DLL, you can not dispose this library
until that IUnknown is collected. Else, you may free the library, and
then the CLR may call release on that IUnknown, leading to a crash.</p>
<p>Declare your delegate pretty much as you would in C or C++; if you
happen to have a working typedef, use it as the pattern for your
delegate declaration, which must have class cope.</p>
<p>Once you have your delegate declared, instantiate it by assigning it
the value returned by calling this method on an instance that was
constructed using the name of the DLL that exports the desired Win32
(or Win64) function.</p>
<p>Since the Win64 API generally uses the same names, signatures, and
DLL names (e. g., it's still Kernel32.dll, and GetProcAddress is
still GetProcAddress), most of your existing Windows API calls work
unchanged in Win64. The magic that makes this possible is that Win32
code looks in %SystemRoot%\SysWOW64, while Win64 code looks in
%SystemRoot%\System32 for system libraries. The clear goal of this
initially confusing scheme was to make porting code to 64 bits as
painless as possible.</p>
</div>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.IDisposable</span>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
