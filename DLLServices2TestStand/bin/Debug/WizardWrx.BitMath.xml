<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WizardWrx.BitMath</name>
    </assembly>
    <members>
        <member name="T:WizardWrx.BCLIntegerTypeInfo">
            <summary>
            Instances of this type are built into the program as a static read-only
            array, which is incorporated into the static BitHelpers class for use by
            its static methods, all of which are internal to this assembly.
            </summary>
        </member>
        <member name="M:WizardWrx.BCLIntegerTypeInfo.#ctor">
            <summary>
            The default constructor is defined and marked private, to enforce
            creation of populated instances. Since instances are essentially
            baked into the program, this is pretty much a moot point.
            </summary>
            <remarks>
            Though all but one will almost certainly go unused, this class 
            overrides every method on its implicit base class, System.Object. In
            particular, the two comparison methods, CompareTo and Equals, are
            unlikely to see action because the assembly exposes a complete array
            of these objects that is presorted and accessible through public
            subscript constants and a public access method that returns the
            object that corresponds to a specified type.
            </remarks>
        </member>
        <member name="M:WizardWrx.BCLIntegerTypeInfo.#ctor(System.Type,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            The alternate constructor creates a populated instance.
            </summary>
            <param name="ptypBCLTypeInfo">
            Specify the System.Type that corresponds to the specified GUID.
            </param>
            <param name="pintMaxDigits">
            Specify the maximum number of decimal digits that the type can
            express.
            </param>
            <param name="pintBytesOccupied">
            Specify the number of bytes of machine memory occupied by instances.
            </param>
            <param name="pintBitsCapacity">
            Specify the number of bits that can be stored in instances. For the
            purpose of this exercise, the sign is treated as just another bit.
            </param>
            <param name="pfIsSigned">
            Specify TRUE to indicate that the type has a sign, otherwise FALSE.
            </param>
        </member>
        <member name="M:WizardWrx.BCLIntegerTypeInfo.Equals(System.Object)">
            <summary>
            This method overrides the Equal method on System.Object by
            evaluating the compact GUID strings if the other comparand is a
            BCLIntegerTypeInfo. In all other cases, this method returns FALSE.
            </summary>
            <param name="obj">
            Specify another BCLIntegerTypeInfo instance. A null reference or one
            to any other type is meaningless, and is covered by returning FALSE.
            </param>
            <returns>
            This method returns TRUE when both instances have identical BCLType
            properties. Otherwise, the return value is FALSE.
            </returns>
        </member>
        <member name="M:WizardWrx.BCLIntegerTypeInfo.GetHashCode">
            <summary>
            This method overrides the default GetHashCode implementation in the
            base class by substituting the hash code of its BCLType property.
            </summary>
            <returns>
            The return value is the hash code of the BCLType property of the
            instance.
            </returns>
        </member>
        <member name="M:WizardWrx.BCLIntegerTypeInfo.ToString">
            <summary>
            This method overrides the default ToString method on System.Object
            to deliver a compact rendering of the properties of the instance.
            </summary>
            <returns>
            The return value is a compact formatted rendering of every property
            of the instance, including the raw GUID, which is extracted from the
            System.Type reference stored in the instance.
            </returns>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.BCLType">
            <summary>
            This property gets the actual System.Type of the integral type
            represented by this instance.
            </summary>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.MaximumDecimalDigits">
            <summary>
            This property gets the maximum number of decimal digits that can be
            represented by this type.
            </summary>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.RequiredStorageBytes">
            <summary>
            This property gets the number of bytes occupied by an instance of
            this type in machine memory or on disk.
            </summary>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.CapacityInBits">
            <summary>
            This property gets the number of bits that can be stored in an
            instance of this type. The sign, which occupies the most significant
            bit of signed integers, is included in the bit count, because it is
            just like any other bit when the integer is treated as a bit mask.
            </summary>
            <see cref="P:WizardWrx.BCLIntegerTypeInfo.IsSigned"/>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.IsSigned">
            <summary>
            This property returns TRUE if the integer represented by the
            instance has a sign. Otherwise, this property returns FALSE.
            </summary>
            <see cref="P:WizardWrx.BCLIntegerTypeInfo.CapacityInBits"/>
        </member>
        <member name="P:WizardWrx.BCLIntegerTypeInfo.GUIDPerType">
            <summary>
            This property gets the raw GUID from the System.Type represented by
            the instance.
            </summary>
            <seealso cref="P:WizardWrx.BCLIntegerTypeInfo.BCLType"/>
        </member>
        <member name="T:WizardWrx.BitArray32">
            <summary>
            This object exposes properties and methods to simplify using masks of up
            to 32 bits in day to day programming.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_01">
            <summary>
            Bit 1
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_02">
            <summary>
            Bit 2
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_03">
            <summary>
            Bit 3
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_04">
            <summary>
            Bit 4
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_05">
            <summary>
            Bit 5
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_06">
            <summary>
            Bit 6
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_07">
            <summary>
            Bit 7
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_08">
            <summary>
            Bit 8
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_09">
            <summary>
            Bit 9
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_10">
            <summary>
            Bit 10
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_11">
            <summary>
            Bit 11
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_12">
            <summary>
            Bit 12
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_13">
            <summary>
            Bit 13
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_14">
            <summary>
            Bit 14
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_15">
            <summary>
            Bit 15
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_16">
            <summary>
            Bit 16
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_17">
            <summary>
            Bit 17
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_18">
            <summary>
            Bit 18
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_19">
            <summary>
            Bit 19
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_20">
            <summary>
            Bit 20
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_21">
            <summary>
            Bit 21
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_22">
            <summary>
            Bit 22
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_23">
            <summary>
            Bit 23
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_24">
            <summary>
            Bit 24
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_25">
            <summary>
            Bit 25
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_26">
            <summary>
            Bit 26
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_27">
            <summary>
            Bit 27
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_28">
            <summary>
            Bit 28
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_29">
            <summary>
            Bit 29
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_30">
            <summary>
            Bit 30
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_31">
            <summary>
            Bit 31
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_32">
            <summary>
            Bit 32
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_01">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_02">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_03">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_04">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_05">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_06">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_07">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_08">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_09">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_10">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_11">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_12">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_13">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_14">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_15">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_16">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_17">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_18">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_19">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_20">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_21">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_22">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_23">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_24">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_25">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_26">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_27">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_28">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_29">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_30">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_31">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NUMBER_32">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_00">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_01">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_02">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_03">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_04">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_05">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_06">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_07">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_08">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_09">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_10">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_11">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_12">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_13">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_14">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_15">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_16">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_17">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_18">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_19">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_20">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_21">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_22">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_23">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_24">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_25">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_26">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_27">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_28">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_29">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_30">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_OFFSET_31">
            <summary>
            Bits are numbered from lowest (least significant) to highest (most significant).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.MINIMUM_BIT_GROUP_IN_FORMAT">
            <summary>
            The FormatIntegerAsBitArray overload that takes a Bits Per Group
            argument (pintBitsPerGroup) requires its value to either be this
            value or an even multiple of it, or SUPPRESS_BIT_GROUPING (zero).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.SUPPRESS_BIT_GROUPING">
            <summary>
            Argument pintBitsPerGroup of static method FormatIntegerAsBitArray
            must be either zero (this constant value) or an even multiple of
            MINIMUM_BIT_GROUP_IN_FORMAT (4), which also operates as its minimum
            permitted positive value.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.ON">
            <summary>
            This symbolic constant for identifying a bit as ON maps to bool true.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.OFF">
            <summary>
            This symbolic constant for identifying a bit as OFF maps to bool false.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NBR_MAX">
            <summary>
            Since this class numbers bits from 1. the highest supported bit number is 32.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BIT_NBR_MIN">
            <summary>
            Since this class numbers bits from 1. the first bit number is 1.
            </summary>
        </member>
        <member name="M:WizardWrx.BitArray32.#ctor">
            <summary>
            This default constructor for a BitArray32 object creates an
            object with all bits OFF.
            </summary>
            <remarks>
            Internally, the object is implemented as an unsigned 32 bit integer,
            a native value type.
            </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.#ctor(System.UInt32)">
            <summary>
            This overloaded constructor for a BitArray32 object creates an
            object with a specified initial value.
            </summary>
            <param name="puintInitialValue">
            Pass the initial value into the constructor as an unsigned 32 bit
            integer, a native value type.
            </param>
        </member>
        <member name="M:WizardWrx.BitArray32.BitOff(System.Int32)">
             <summary>
             Turn a specified bit in the _uintBitMask instance variable OFF.
             </summary>
             <param name="pintBitNumber">
             Ordinal number of bit to turn OFF. Bits are numbered from 1 to 32,
             with 1 being the least significant bit.
             </param>
             <remarks>
             This code uses a temporary instance of the BitArray32 class, which is
             discarded as the method returns.
            
             Since neither operand of the exclusive-OR assignment operator can be
             a BitArray32 object _ubmTheBit must be cast to UInt32, using the
             implicit operator UInt32, defined elsewhere in this class. Private
             variable _uintBitMask is already a UInt32.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.BitOn(System.Int32)">
             <summary>
             Turn a specified bit in the _uintBitMask instance variable ON.
             </summary>
             <param name="pintBitNumber">
             Ordinal number of bit to turn ON. Bits are numbered from 1 to 32,
             with 1 being the least significant bit.
             </param>
             <remarks>
             This code uses a temporary instance of the BitArray32 class, which is
             discarded as the method returns.
            
             Since neither operand of the logical OR assignment operator can be
             a BitArray32 object _ubmTheBit must be cast to UInt32, using the
             implicit operator UInt32, defined elsewhere in this class. Private
             variable _uintBitMask is already a UInt32.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.IsBitOff(System.Int32)">
             <summary>
             Test the state of a specified bit, returning TRUE if it is OFF.
             </summary>
             <param name="pintBitNumber">
             Ordinal number of bit to evaluate. Bits are numbered from 1 to 32,
             with 1 being the least significant bit.
             </param>
             <returns>
             TRUE if the specified bit is ON, else FALSE.
             </returns>
             <remarks>
             This code uses a temporary instance of the BitArray32 class, which is
             discarded as the method returns.
            
             Unlike the BitOff and BitOn operators, everything is already cast to
             Uint32. Therefore, this method works just fine without any casts.
            
             Since this code is unlikely to change, it uses the most concise form
             of the IF statement, which supports a single executable statement in
             each branch.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.IsBitOn(System.Int32)">
             <summary>
             Test the state of a specified bit, returning TRUE if it is ON.
             </summary>
             <param name="pintBitNumber">
             Ordinal number of bit to evaluate. Bits are numbered from 1 to 32,
             with 1 being the least significant bit.
             </param>
             <returns>
             TRUE if the specified bit is ON, else FALSE.
             </returns>
             <remarks>
             This code uses a temporary instance of the BitArray32 class, which is
             discarded as the method returns.
            
             Unlike the BitOff and BitOn operators, everything is already cast to
             Uint32. Therefore, this method works just fine without any casts.
            
             Since this code is unlikely to change, it uses the most concise form
             of the IF statement, which supports a single executable statement in
             each branch.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.BitNumber(System.UInt32)">
            <summary>
            Return the bit number that corresponds to the given value. Bits are
            numbered from 1, starting with the least significant bit.
            </summary>
            <param name="puintBitValue">
            Unsigned integer puintBitValue must be a integral power of two.
            </param>
            <returns>
            If the function succeeds, the return value is the bit number that
            corresponds to the specified integral power of two.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown if the input
            value is not an integral power of two.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.BitNumber(System.Int32)">
            <summary>
            Return the bit number that corresponds to the given value. Bits are
            numbered from 1, starting with the least significant bit.
            </summary>
            <param name="pintBitValue">
            Signed integer puintBitValue must be a positive integral power of
            two.
            </param>
            <returns>
            If the function succeeds, the return value is the bit number that
            corresponds to the specified integral power of two.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown if the input
            value is not an integral power of two.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.BitPosition(System.UInt32)">
            <summary>
            Return the bit position that corresponds to the given value. Bit
            positions are numbered from 0, starting with the least significant
            bit.
            </summary>
            <param name="puintBitValue">
            Unsigned integer puintBitValue must be a integral power of two.
            </param>
            <returns>
            If the function succeeds, the return value is the bit position that
            corresponds to the specified integral power of two.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown if the input
            value is not an integral power of two.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.BitPosition(System.Int32)">
            <summary>
            Return the bit position that corresponds to the given value. Bit
            positions are numbered from 0, starting with the least significant
            bit.
            </summary>
            <param name="pintBitValue">
            Signed integer pintBitValue must be a positive integral power of
            two.
            </param>
            <returns>
            If the function succeeds, the return value is the bit position that
            corresponds to the specified integral power of two.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown if the input
            value is not an integral power of two.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.FormatIntegerAsBitArray``1(``0)">
            <summary>
            Format any integral value type as an array of bits, listed from most
            significant to least.
            </summary>
            <typeparam name="T">
            This method accepts all integral value types except IntPtr. However,
            since there is no documented provision in the .NET Framework to
            enforce such a restriction on a generic type at compile time, the
            task is left to this method, which enforces it at run time. However,
            when fed an incompatible type, this method degrades gracefully by
            applying its default string format.
            </typeparam>
            <param name="pintIntegralValueType">
            This argument is expected to be an integral type, but a non-integral
            type is processed by degrading to its default ToString method.
            </param>
            <returns>
            When argument pintIntegralValueType is an integral value type, the
            returned string is composed of zeros and ones that represent the
            bits that store its value, listing them from most significant bit to
            least.
            
            If the integer has a sign, the most significant bit is the bit that
            is reserved to hold it. Likewise, the most significant bit of an
            unsigned integer is the bit that stores the highest power of two
            that it can hold.
            </returns>
            <remarks>
            This method could easily be implemented as a call to the second
            overload, but I chose to keep their implementations separate for two
            reasons.
            
            1) The second overload concatenates its second argument to the same
            string constant used by this method, passing the resulting string as
            the second argument to the string.Format overload that takes a
            format provider as its first argument. Since string concatenation is
            expensive, why use it when the simpler method call achieves the goal
            so much more cheaply.
            
            2) Since string formatters can see high usage, and the only difference
            between the two overloads is the string concatenation, calling the
            second overload not only incurs a wasteful string concatenation, but it
            must waste a stack frame for this dubious objective.
            </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.FormatIntegerAsBitArray``1(``0,System.Int32)">
            <summary>
            Format any integral value type as an array of bits, listed from most
            significant to least, with optional grouping.
            </summary>
            <typeparam name="T">
            This method accepts all integral value types except IntPtr. However,
            since there is no documented provision in the .NET Framework to
            enforce such a restriction on a generic type at compile time, the
            task is left to this method to do so at run time. However, when fed
            an incompatible type, this method degrades gracefully by applying
            its default string format.
            </typeparam>
            <param name="pintIntegralValueType">
            This argument is expected to be an integral type, but a non-integral
            type is processed by degrading to its default ToString method.
            </param>
            <param name="pintBitsPerGroup">
            Specify the number of bits to include in each group, or specify zero
            to suppress formatting, equivalent to calling the first overload.
            
            IMPORTANT: The mechanism by which the spaces are inserted imposes a
            restriction that this value must be evenly divisible by 4, such that
            the four bits of each byte are kept together.
            </param>
            <returns>
            When argument pintIntegralValueType is an integral value type, the
            returned string is composed of zeros and ones that represent the
            bits that store its value, listing them from most significant bit to
            least.
            
            If the integer has a sign, the most significant bit is the bit that
            is reserved to hold it. Likewise, the most significant bit of an
            unsigned integer is the bit that stores the highest power of two
            that it can hold.
            </returns>
            <exception cref="T:System.FormatException">
            Invalid formatting instructions raise a FormatException exception,
            which typically wraps an ArgumentException, and supplies additional
            detail not usually available from a typical FormatException.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.FormatIntegerAsHex``1(``0)">
            <summary>
            Format any integral value type as an array of hexadecimal "digits", 
            listed from most significant to least, specifying a standard numeric
            format string and a minimum length appropriate to its maximum value.
            
            The advantage of this method over the standard ToString overloads is
            that you don't have to figure out how many hexadecimal digits you
            must allow.
            </summary>
            <typeparam name="T">
            This method accepts all integral value types except IntPtr. However,
            since there is no documented provision in the .NET Framework to
            enforce such a restriction on a generic type at compile time, the
            task is left to this method to do so at run time. However, when fed
            an incompatible type, this method degrades gracefully by applying
            its default string format.
            </typeparam>
            <param name="pintIntegralValueType">
            This argument is expected to be an integral type, but a non-integral
            type is processed by degrading to its default ToString method.
            </param>
            <returns>
            When argument pintIntegralValueType is an integral value type, the
            returned string is composed of hexadecimal "digits" that represent
            its value in base 16. The length of the string is a function of the
            maximum value that can be stored in an integer of the input type.
            Hence, a Byte, being an 8 bit integer, returns a two-character hex
            string, a UInt16 returns four, UInt32 eight, and UInt64 sixteen.
            
            Otherwise, the default ToString method on its type is called, and
            the returned string is whatever that method provides.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.GetRulerTens(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Get the tens marks of the bit mask ruler from the string resources.
            </summary>
            <param name="penmBitCount">
            Indicate the length of ruler to generate by way of a member of the
            BitCount enumeration. See the BitCount enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitCount"/>
            <returns>
            The return value is a string, exactly 60 characters long, containing
            nine spaces, each followed by the next sequential integer, counting
            from 1.
            </returns>
            <seealso cref="M:WizardWrx.BitArray32.GetRulerUnits(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
            This method throws an ComponentModel.InvalidEnumArgumentException
            exception when the penmBitCount argument is not a valid member of
            the BitCount enumeration and when the penmBitDisplayOrder argument
            is not a valid member of the BitDisplayOrder enumeration. In both
            cases, a value of Unspecified is treated as invalid.
            
            If the BitCount value that is invalid, the exception is actually
            thrown by a private method, TrimRuler, which this method, by virtue
            of being unguarded, allows to bubble up the stack, as would be the
            case if it had thrown the exception.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This method allows the InvalidOperationException exception thrown
            when it calls private method TrimRuler, sending a pstrWholeRuler
            string that has a string length that differs from the length implied
            by the numeric value of the penmBitCount enumeration argument to
            bubble up the call stack.
            </exception>
            <remarks>
            This is a method call, rather than a property, because the string is
            read from a resource. 
            
            The InvalidOperationException and InvalidEnumArgumentException
            exceptions bubble up, rather than being caught in this routine to
            avoid duplicating the task in both of its internal callers. 
            </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.GetRulerUnits(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Get the units marks of the bit mask ruler from the string resources.
            </summary>
            <param name="penmBitCount">
            Indicate the length of ruler to generate by way of a member of the
            BitCount enumeration. See the BitCount enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitCount"/>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
            <returns>
            The return value is a string, exactly 64 characters long, containing
            numbers from 1 to 10, repeated six times, followed by numbers
            1 through 4, enough to cover the bits in mask of 64 bits.
            </returns>
            <seealso cref="M:WizardWrx.BitArray32.GetRulerTens(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
            This method throws an ComponentModel.InvalidEnumArgumentException
            exception when the penmBitCount argument is not a valid member of
            the BitCount enumeration and when the penmBitDisplayOrder argument
            is not a valid member of the BitDisplayOrder enumeration. In both 
            cases, a value of Unspecified is treated as invalid.
            
            If the BitCount value that is invalid, the exception is actually
            thrown by a private method, TrimRuler, which this method, by virtue
            of being unguarded, allows to bubble up the stack, as would be the
            case if it had thrown the exception.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This method allows the InvalidOperationException exception thrown
            when it calls private method TrimRuler, sending a pstrWholeRuler
            string that has a string length that differs from the length implied
            by the numeric value of the penmBitCount enumeration argument to
            bubble up the call stack.
            </exception>
            <remarks>
            This is a method call, rather than a property, because the string is
            read from a resource. 
            
            The InvalidOperationException and InvalidEnumArgumentException
            exceptions bubble up, rather than being caught in this routine to
            avoid duplicating the task in both of its internal callers. 
            </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.TurnBitOff(System.Int32)">
             <summary>
             Return a new BitArray32 object in which a specified bit is turned ON
             and all others are OFF.
             </summary>
             <param name="pintBitNumber">
             Ordinal number of bit to turn OFF. Bits are numbered from 1 to 32,
             with 1 being the least significant bit.
             </param>
             <returns>
             A new BitArray32 object with a single bit turned OFF, and all others
             already turned OFF.
             </returns>
             <remarks>
             In essence, this method returns an instance of the BitArray32 created
             by calling its default constructor.
            
             This method and its companion, TurnBitOn, bounds checks its input,
             notwithstanding the fact that the bitwise operators discard the high
             bits in the bit count operand of the left logical shift operator.
            
             Since all instance methods call these static methods, these bounds
             checks suffice for the entire class.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.TurnBitOn(System.Int32)">
             <summary>
             Return a new BitArray32 with bit number (ordinal) pintBitNumber
             turned ON.
             </summary>
             <param name="pintBitNumber">
             Number of bit to turn on with bits numbered from 1 to 32, starting
             with Bit 1 as the least significant bit.
             </param>
             <returns>
             A new BitArray32 object, with the specified bit ON and all others 
             OFF.
             </returns>
             <remarks>
             This method and its companion, TurnBitOff, bounds checks its input,
             notwithstanding the fact that the bitwise operators discard the high
             bits in the bit count operand of the left logical shift operator.
            
             Since all instance methods call these static methods, these bounds
             checks suffice for the entire class.
             </remarks>
        </member>
        <member name="M:WizardWrx.BitArray32.TrimRuler(System.String,WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Trim the ruler to fit.
            </summary>
            <param name="pstrWholeRuler">
            Specify a reference to the ruler string to trim.
            </param>
            <param name="penmBitCount">
            Indicate the length of ruler to generate by way of a member of the
            BitCount enumeration. See the BitCount enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitCount"/>
            <returns>
            The ruler is trimmed to fit a bit mask of the specified width, and
            returned as a new string.
            </returns>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
            This method throws an ComponentModel.InvalidEnumArgumentException
            exception when the penmBitCount argument is not a valid member of
            the BitCount enumeration. A value of Unspecified is treated as an
            invalid value.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This method throws an InvalidOperationException exception when the
            pstrWholeRuler string length differs from the length implied by the
            numeric value of the penmBitCount enumeration argument.
            </exception>
        </member>
        <member name="M:WizardWrx.BitArray32.ToString">
            <summary>
            Override the ToString method to provide a useful output, in the form
            of a hexadecimal representation of the value of its bit mask.
            </summary>
            <returns>
            A String representation of the private variable that holds the
            current value of the bit mask, formatted as a hexadecimal
            representation of its value.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.ToString(System.String)">
            <summary>
            Override the ToString method to provide additional useful outputs,
            such as a couple of optional binary (bit level) formats.
            </summary>
            <param name="format">
            In keeping with the standard nomenclature, this format string gives
            details about the output format desired.
            </param>
            <returns></returns>
        </member>
        <member name="M:WizardWrx.BitArray32.Equals(System.Object)">
            <summary>
            Override the default Equals method, so that class instances can
            participate in meaningful equality tests.
            </summary>
            <param name="pComparand">
            A reference to a generic object to be compared against the current
            instance.
            </param>
            <returns>
            True if the two meet our definition of Equals, which is that the two
            bit masks are equal.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.Equals(WizardWrx.BitArray32)">
            <summary>
            Provide a typecast version of the generic Equals method.
            </summary>
            <param name="pComparand">
            The comparand is the other BitArray32 to be tested for equality. 
            </param>
            A reference to another instance of the BitArray32 class, to be
            compared against the current instance.
            <returns>
            True if the two meet our definition of Equals, which is that the two
            bit masks are equal.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.GetHashCode">
            <summary>
            This class overrides the GetHashCode method of its base class to
            return the hash code for the uint32 primitive that stores its data.
            </summary>
            <returns>
            An Integer which is the value returned by the GetHashCode method of
            the uint32 object.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.op_Equality(WizardWrx.BitArray32,WizardWrx.BitArray32)">
            <summary>
            Though not recommended, members of this class override the equality
            and inequality operators.
            </summary>
            <param name="pobjLValue">
            Value on left of equal sign, otherwise known as the LValue or left
            operand.
            </param>
            <param name="pobjRValue">
            Value on right of equal sign, otherwise known as the RValue or right
            operand.
            </param>
            <returns>
            True if both value are equal, or if they refer to the same object.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.op_Inequality(WizardWrx.BitArray32,WizardWrx.BitArray32)">
            <summary>
            Though not recommended, members of this class override the equality
            and inequality operators.
            </summary>
            <param name="pobjLValue">
            Value on left of equal sign, otherwise known as the LValue or left
            operand.
            </param>
            <param name="pojbRValue">
            Value on right of equal sign, otherwise known as the RValue or right
            operand.
            </param>
            <returns>
            Inverse of the value returned by the overloaded equals operator.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.op_Implicit(WizardWrx.BitArray32)~System.UInt32">
            <summary>
            Cast a BitArray32 object to its underlying type, UInt32.
            </summary>
            <param name="pMask">
            The BitArray32 to be cast to a UInt32.
            </param>
            <returns>
            A reference to its input variable, cast to a UInt32.
            </returns>
        </member>
        <member name="M:WizardWrx.BitArray32.op_Implicit(System.UInt32)~WizardWrx.BitArray32">
            <summary>
            Cast a Uint32, the underlying type of a BitArray32, to an object of
            type BitArray32.
            </summary>
            <param name="pUInt32">
            The Uint32 to be cast to a BitArray32.
            </param>
            <returns>
            A reference to its input variable, cast to a BitArray32.
            </returns>
        </member>
        <member name="T:WizardWrx.BitArray32.BitCount">
            <summary>
            Use this enumeration to tell the GetRulerTens and GetRulerUnits
            how long you want the ruler to be. The name of the enumeration,
            BitCount, should help you to select the correct length, as is its
            numeric value.
            </summary>
            <see cref="M:WizardWrx.BitArray32.GetRulerUnits(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <see cref="M:WizardWrx.BitArray32.GetRulerTens(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <seealso cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="F:WizardWrx.BitArray32.BitCount.Unspecified">
            <summary>
            The default (uninitialized) value of Unspecified is invalid, and
            elicits an InvalidEnumArgumentException exception.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitCount.Count08">
            <summary>
            Create a ruler for masks of 8 bits (1 byte).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitCount.Count16">
            <summary>
            Create a ruler for masks of 16 bits (2 bytes).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitCount.Count32">
            <summary>
            Create a ruler for masks of 32 bits (4 bytes).
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitCount.Count64">
            <summary>
            Create a ruler for masks of 64 bits (8 bytes).
            </summary>
        </member>
        <member name="T:WizardWrx.BitArray32.BitDisplayOrder">
            <summary>
            Use this enumeration to tell the GetRulerTens and GetRulerUnits
            in which direction you want the ruler to appear.
            </summary>
            <see cref="M:WizardWrx.BitArray32.GetRulerUnits(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <see cref="M:WizardWrx.BitArray32.GetRulerTens(WizardWrx.BitArray32.BitCount,WizardWrx.BitArray32.BitDisplayOrder)"/>
            <seealso cref="T:WizardWrx.BitArray32.BitCount"/>
        </member>
        <member name="F:WizardWrx.BitArray32.BitDisplayOrder.Unspecified">
            <summary>
            The default (uninitialized) value of Unspecified is invalid, and
            elicits an InvalidEnumArgumentException exception.
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitDisplayOrder.HighBitToLowBit">
            <summary>
            HighBitToLowBit elicits a ruler with its markings numbered from
            right to left (High bit to Low), the order in which bits appear
            in core dumps and in most of the graphical displays that appear
            in technical documentation.
            
            Since this is the conventional display order, it is the default
            when 
            </summary>
        </member>
        <member name="F:WizardWrx.BitArray32.BitDisplayOrder.LowBitToHighBit">
            <summary>
            LowBitToHighBit elicits a ruler with its markings numbered from
            left to right (Low bit to High), which may be more useful for a
            carbon unit, especially one who is unaccustomed to reading bit
            masks from core dumps.
            </summary>
        </member>
        <member name="T:WizardWrx.BitHelpers">
            <summary>
            This static class defines utility methods to support formatting of
            integral data types as arrays of individual bits, along with embedded
            read-only data structures to support their work.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_MAX_DEC_DIGITS_03">
            <summary>
            The MaximumDecimalDigits property of a BCLIntegerTypeInfo instance
            specifies a maximum decimal digits capacity of 3.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_MAX_DEC_DIGITS_05">
            <summary>
            The MaximumDecimalDigits property of a BCLIntegerTypeInfo instance
            specifies a maximum decimal digits capacity of 5.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_MAX_DEC_DIGITS_10">
            <summary>
            The MaximumDecimalDigits property of a BCLIntegerTypeInfo instance
            specifies a maximum decimal digits capacity of 10.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_MAX_DEC_DIGITS_19">
            <summary>
            The MaximumDecimalDigits property of a BCLIntegerTypeInfo instance
            specifies a maximum decimal digits capacity of 19.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_MAX_DEC_DIGITS_20">
            <summary>
            The MaximumDecimalDigits property of a BCLIntegerTypeInfo instance
            specifies a maximum decimal digits capacity of 20.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_BYTES_TO_STORE_1">
            <summary>
            The RequiredStorageBytes property of a BCLIntegerTypeInfo instance
            specifies a storage requirement of 2 bytes.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_BYTES_TO_STORE_2">
            <summary>
            The RequiredStorageBytes property of a BCLIntegerTypeInfo instance
            specifies a storage requirement of 2 bytes.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_BYTES_TO_STORE_4">
            <summary>
            The RequiredStorageBytes property of a BCLIntegerTypeInfo instance
            specifies a storage requirement of 4 bytes.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_BYTES_TO_STORE_8">
            <summary>
            The RequiredStorageBytes property of a BCLIntegerTypeInfo instance
            specifies a storage requirement of 8 bytes.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_CAPACITY_BITS_08">
            <summary>
            The CapacityInBits property of a BCLIntegerTypeInfo instance
            specifies its capacity to hold a mask of up to 8 bits.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_CAPACITY_BITS_16">
            <summary>
            The CapacityInBits property of a BCLIntegerTypeInfo instance
            specifies its capacity to hold a mask of up to 16 bits.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_CAPACITY_BITS_32">
            <summary>
            The CapacityInBits property of a BCLIntegerTypeInfo instance
            specifies its capacity to hold a mask of up to 32 bits.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_CAPACITY_BITS_64">
            <summary>
            The CapacityInBits property of a BCLIntegerTypeInfo instance
            specifies its capacity to hold a mask of up to 64 bits.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_IS_SIGNED">
            <summary>
            The IsSigned property of a BCLIntegerTypeInfo instance specifies
            that it is treated as signed (TRUE) when it is being treated as an
            integer.
            
            When treated as a bit mask, the sign is ignored, and treated as just
            another bit, which happens to occupy its Most Significant Bit
            position.
            </summary>
            <remarks>
            Reserving one bit for the sign affects the upper and lower limits of
            numbers that can be stored in an integer, decreasing the absolute
            values of both by a factor of two. This is evident in the reported
            MaxValue and MinValue of an integer of a given size, which is the
            absolute value of one less than plus or minus two to the power of B,
            where B is the number of bits available to store its absolute value.
            </remarks>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCLI_IS_UNSIGNED">
            <summary>
            The IsSigned property of a BCLIntegerTypeInfo instance specifies
            that it is treated as unsigned (FALSE) when it is being treated as 
            an integer.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_BYTE">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.Byte
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_INT16">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.Int16
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_INT32">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.Int32
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_INT64">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.Int64
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_UINT32">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.UInt32
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_UINT64">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.UInt64
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BCL_INTEGRAL_TYPEINFO_UINT16">
            <summary>
            Use this subscript to address the BCLIntegerTypeInfo array
            s_abclintegertypeinfo that stores information about the System.UInt16
            integral value type.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.BITS_PER_BYTE">
            <summary>
            This constant defines the number of bits per byte. So far as I know,
            this applies to computers of any type; a byte is a byte, period.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.FORMAT_GENERAL">
            <summary>
            In keeping with standards implemented elsewhere in the Land of .NET,
            the default format string is upper case G.
            </summary>
            <remarks>
            None of the supported custom format specifiers overlaps any of the 
            standard format specifiers that apply to numeric, dates, times, or
            time spans.
            </remarks>
        </member>
        <member name="F:WizardWrx.BitHelpers.FORMAT_BITS_HIGH_TO_LOW">
            <summary>
            Use upper case H, optionally followed by a numeric substring to 
            specify the number of bits to separate into groups by a space, to
            have the bits displayed high bit to low. This is the conventional
            display order.
            </summary>
            <remarks>
            None of the supported custom format specifiers overlaps any of the 
            standard format specifiers that apply to numeric, dates, times, or
            time spans.
            </remarks>
        </member>
        <member name="F:WizardWrx.BitHelpers.FORMAT_BITS_LOW_TO_HIGH">
            <summary>
            Use upper case L, optionally followed by a numeric substring to 
            specify the number of bits to separate into groups by a space, to
            have the bits displayed low bit to high. This format caters for
            readers who prefer their bit positions to count from left to right,
            or are unfamiliar with the conventional method of visualizing a bit
            mask.
            </summary>
            <remarks>
            None of the supported custom format specifiers overlaps any of the 
            standard format specifiers that apply to numeric, dates, times, or
            time spans.
            </remarks>
        </member>
        <member name="F:WizardWrx.BitHelpers.HEX_DIGITS_PER_BYTE">
            <summary>
            This symbolic constant defines the number of hexadecimal digits
            (characters) required to store the hexadecimal (base 16) value of
            one byte.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.ARRAY_FIRST_ELEMENT">
            <summary>
            In keeping with my coding standard of using symbolic constants to
            specify the meaning of any magic number, zero is mapped to one such
            constant, to be interpreted as the array base (the subscript of its
            first element).
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.HEXADECIMAL">
            <summary>
            Pass this constant to the ToString method on any integral type to
            format it as a string of hexadecimal digits.
            </summary>
            <remarks>
            Since the array uses lower case characters, so must the intermediate
            format.
            </remarks>
        </member>
        <member name="F:WizardWrx.BitHelpers.LEN_MINIMUM">
            <summary>
            This symbolic constant specifies the minimum length of a format
            string.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.POS_PREFIX">
            <summary>
            The position of the prefix is specified as its array subscript,
            for use in separating the numeric suffix.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.POS_MODIFIER">
            <summary>
            In like manner, the position of the numeric modifier is specified in
            terms of its array subscript.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.QUOTE_CHAR">
            <summary>
            Use this to simplify and clarify when you pass a double quote mark
            as an argument.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.SPACE_CHAR">
            <summary>
            Since there is no practical way to distinguish a space character
            from a number of other characters, and strings thereof, that may
            appear to be blank, the space character is a stalwart symbolic
            constant.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.s_abclintegertypeinfo">
            <summary>
            This static read-only array of BCLIntegerTypeInfo objects is used
            internally by the static methods on the BitHelpers class, of which
            it is a static property, drives the custom ToString method that
            renders integers as arrays of bits.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.s_achrHexDigit">
            <summary>
            A binary search of this array yields the required subscript into the
            s_abytAsBits array.
            </summary>
        </member>
        <member name="F:WizardWrx.BitHelpers.s_abytAsBits">
            <summary>
            This table translates hexadecimal "digits" into their corresponding
            bits.
            </summary>
        </member>
        <member name="M:WizardWrx.BitHelpers.FormatBitMask``1(``0,System.String)">
            <summary>
            Format a bit mask; this method is intended to implement the ToString
            overload on the BitArray classes.
            </summary>
            <typeparam name="T">
            Though not enforced by the compiler, the input must be an integral
            type, though it is left to this method to enforce it at run time.
            </typeparam>
            <param name="pgenBitMask">
            Specify the bit mask to format, which must be an integral type.
            System.Byte is considered an integral type that stores 8 bits.
            </param>
            <param name="pstrFormatString">
            Specify the format string, which must be either "G" by itself, "H",
            or "L" followed by a positive integer less than the number of bits
            represented by pgenBitMask.
            </param>
            <returns>
            if the function succeeds, the return value is a string containing a
            1 or 0 for each bit in pgenBitMask.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown when the bits per
            group suffix is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            An ArgumentException exception is thrown when the bits per group
            suffix is non-numeric.
            </exception>
        </member>
        <member name="M:WizardWrx.BitHelpers.ParseFormatString(System.String)">
            <summary>
            Parse the format string, returning the outcome through a new
            FormattingParameters instance.
            </summary>
            <param name="pstrFormatString">
            Specify the formatting string to parse.
            </param>
            <returns>
            If the function succeeds, it returns a fully populated
            FormattingParameters object.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            An ArgumentOutOfRangeException exception is thrown when the bits per
            group suffix is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            An ArgumentException exception is thrown when the bits per group
            suffix is non-numeric.
            </exception>
        </member>
        <member name="M:WizardWrx.BitHelpers.InfoForIntegralType(System.Type)">
            <summary>
            Get the BCLIntegerTypeInfo for a specified type.
            </summary>
            <param name="ptypForThisType">
            Specify the Type for which BCLIntegerTypeInfo is required. The
            TypeHandle is extracted and used as the index.
            </param>
            <returns>
            If the function succeeds, the return value is the desired
            BCLIntegerTypeInfo object. Otherwise, the return value is null.
            </returns>
        </member>
        <member name="M:WizardWrx.BitHelpers.StrReverse(System.String)">
            <summary>
            Return a new string with the characters reversed.
            </summary>
            <param name="pstrInput">
            Specify the string to be reversed.
            </param>
            <returns>
            The return value is a copy of the string with its characters
            reversed.
            </returns>
            <example>
            C#:
            
            	string strNormal = "ABC" ;
            	string strReversed = StrReverse(strNormal);
            	Console.WriteLine("    Input string  = {0}",strNormal);
            	Console.WriteLine("    Output string = {0}",strReversed);
            	
            VB:
            
            	Dim strNormal As String = "ABC"
            	Dim strReversed As String = StrReverse(strNormal)
            	Console.WriteLine("    Input string  = {0}",strNormal)
            	Console.WriteLine("    Output string = {0}",strReversed)
            	
            Output:
            
                Input string  = ABC
                Output string = CBA
            </example>
        </member>
        <member name="T:WizardWrx.BitMaskAndRuler">
            <summary>
            Instances of this class keep a bit mask and a correctly oriented ruler
            together.
            </summary>
        </member>
        <member name="F:WizardWrx.BitMaskAndRuler.DISPLAY_TENS_ROW">
            <summary>
            This constant represents the element in the string array returned by
            the DisplayBitMask method that points to the tens row of the ruler.
            </summary>
        </member>
        <member name="F:WizardWrx.BitMaskAndRuler.DISPLAY_UNITS_ROW">
            <summary>
            This constant represents the element in the string array returned by
            the DisplayBitMask method that points to the units row of the ruler,
            which is shown below the tens row of the ruler.
            </summary>
        </member>
        <member name="F:WizardWrx.BitMaskAndRuler.DISPLAY_BITS_ROW">
            <summary>
            This constant represents the element in the string array returned by
            the DisplayBitMask method that points to the bit array row, which is
            shown below the units row of the ruler.
            </summary>
        </member>
        <member name="F:WizardWrx.BitMaskAndRuler.DISPLAY_ROW_COUNT">
            <summary>
            This constant represents the number of elements in the string array
            returned by the 
            </summary>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor">
            <summary>
            To enforce creation of fully initialized types, the default
            constructor is hidden.
            </summary>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.Byte,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="pbytBitMask">
            Specify the Byte (Unsigned 8 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.UInt16,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="puintBitMask">
            Specify the UInt16 (Unsigned 16 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.UInt32,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="puintBitMask">
            Specify the UInt32 (Unsigned 32 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.UInt64,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="puintBitMask">
            Specify the UInt64 (Unsigned 64 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.Int16,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="pintBitMask">
            Specify the Int16 (Signed 16 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.Int32,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="pintBitMask">
            Specify the Int32 (Signed 32 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.#ctor(System.Int64,WizardWrx.BitArray32.BitDisplayOrder)">
            <summary>
            Construct a bit mask from any integral type. In this context, a Byte
            is treated as an unsigned integer of 8 bits.
            </summary>
            <param name="pintBitMask">
            Specify the Int64 (Signed 64 bit integer) to treat as a bit mask.
            </param>
            <param name="penmBitDisplayOrder">
            Indicate the direction in which the ruler should be displayed. See
            the XML documentation for the BitDisplayOrder enumeration for a full
            explanation of each value.
            </param>
            <see cref="T:WizardWrx.BitArray32.BitDisplayOrder"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromArray">
            <summary>
            This method returns the three elements that are intended to be
            displayed as a unit.
            </summary>
            <returns>
            The return value is an array of strings, which always contains
            exactly three elements containing the tens row of the ruler, the
            units row of the ruler, and the bit array, in that order.
            </returns>
            <seealso cref="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromMultilineString"/>
            <seealso cref="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromMultilineString(System.Int32)"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromMultilineString">
            <summary>
            This method returns the three elements that are intended to be
            displayed as a unit as a multi-line string.
            </summary>
            <returns>
            Unlike companion method DisplayBitMaskFromArray, this method returns
            one long string, WITH each line EXCEPT the last one terminated with
            a newline.
            </returns>
            <seealso cref="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromArray"/>
        </member>
        <member name="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromMultilineString(System.Int32)">
            <summary>
            This method returns the three elements that are intended to be
            displayed as a unit as a multi-line string.
            </summary>
            <param name="pintNLeadingSpaces">
            Specify the number of leading spaces to insert in front of each of
            the three lines.
            </param>
            <returns>
            Unlike companion method DisplayBitMaskFromArray, this method returns
            one long string, WITH each line EXCEPT the last one terminated with
            a newline.
            </returns>
            <seealso cref="M:WizardWrx.BitMaskAndRuler.DisplayBitMaskFromArray"/>
        </member>
        <member name="P:WizardWrx.BitMaskAndRuler.ArrayOfBits">
            <summary>
            This property gets the string that contains the array of bits.
            </summary>
        </member>
        <member name="P:WizardWrx.BitMaskAndRuler.DecimalRepresentation">
            <summary>
            This property gets the decimal representation of the integral bit
            mask.
            </summary>
        </member>
        <member name="P:WizardWrx.BitMaskAndRuler.HexadecimalRepresentation">
            <summary>
            This property gets the hexadecimal representation of the integral
            bit mask.
            </summary>
        </member>
        <member name="P:WizardWrx.BitMaskAndRuler.Tens">
            <summary>
            This property gets the Tens row of the ruler.
            </summary>
        </member>
        <member name="P:WizardWrx.BitMaskAndRuler.Units">
            <summary>
            This property gets the Units row of the ruler.
            </summary>
        </member>
        <member name="T:WizardWrx.BitMaskFormat">
            <summary>
            A default instance of this class is fed into an overload of 
            string.Format to render the bit array.
            </summary>
        </member>
        <member name="M:WizardWrx.BitMaskFormat.System#ICustomFormatter#Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
            Format integral types as arrays of bits. Other types are handed off
            to the system formatting engine.
            </summary>
            <param name="format">
            Specify the format string to apply. This method supports a custom
            format code, B, and the standard G code.
            </param>
            <param name="arg">
            Specify the integral type to format.
            </param>
            <param name="formatProvider">
            Specify the accompanying format provider.
            </param>
            <returns>
            If the method succeeds and the format code is B, the return value is
            a string that represents the integral type as a string of bits, 
            listed from most significant to least.
            
            If the method succeeds and the format code is G, the return value is
            a hexadecimal representation of the integer, sufficiently padded to
            hold the maximum value supported by an integer of the specified type.
            
            All other cases are handed over to the default formatting engine and
            the outcome is undefined, since it depends upon the behavior of a
            component that is outside of my control.
            </returns>
        </member>
        <member name="M:WizardWrx.BitMaskFormat.EnrichedFormatException(System.String,System.Object)">
            <summary>
            Construct my own FormatException exception that includes the format
            string and its intended argument.
            </summary>
            <param name="pstrFormatString">
            Specify the format string to apply. This method supports a custom
            format code, B, and the standard G code.
            </param>
            <param name="pobjArgument">
            Specify the integral type to format.
            </param>
            <returns>
            The return value becomes the Message of a new FormatException
            exception to which the original FormatException exception is
            attached, so that nothing is lost, especially the original stack
            trace.
            </returns>
        </member>
        <member name="M:WizardWrx.BitMaskFormat.System#IFormatProvider#GetFormat(System.Type)">
            <summary>
            This method implements the IFormatProvider provider interface on
            behalf of the BitMaskFormat class.
            </summary>
            <param name="formatType">
            Provided that the type of formatType is ICustomFormatter, return the
            instance of BitMaskFormat on behalf of which this method was called.
            </param>
            <returns>
            If formatType is valid, the return value is a reference to the
            instance of BitMaskFormat on behalf of which this method was called.
            Otherwise, a null reference is returned.
            </returns>
        </member>
        <member name="T:WizardWrx.FormattingParameters">
            <summary>
            Static method ParseFormatString on class BitHelpers reports its findings
            by constructing and returning an instance of this class.
            </summary>
        </member>
        <member name="F:WizardWrx.FormattingParameters.SUPPRESS_GROUPING">
            <summary>
            Setting the BitsPerGroup property to this value suppresses grouping.
            </summary>
        </member>
        <member name="M:WizardWrx.FormattingParameters.#ctor">
            <summary>
            The default constructor is marked private, to ensure that only fully
            initialized instances can be constructed.
            </summary>
        </member>
        <member name="M:WizardWrx.FormattingParameters.#ctor(WizardWrx.FormattingParameters.FormatCode,System.Int32)">
            <summary>
            ParseFormatString renders its report by calling this constructor.
            </summary>
            <param name="penmFormatCode">
            A member of the FormatCode enumeration specifies the format prefix
            code.
            </param>
            <param name="pintBitsPerGroup">
            An optional positive integer specifies how many bits to include in
            each group. If this value is zero, there is no grouping.
            </param>
        </member>
        <member name="M:WizardWrx.FormattingParameters.AddPaddingAsSpecified(System.Text.StringBuilder)">
            <summary>
            Append padding if the specification calls for it and there are
            enough characters in the buffer.
            </summary>
            <param name="psbWork">
            Padding, if any, is appended to the StringBuilder to which the
            calling static FormatBitMask method on the BitHelpers class is
            building the bit array.
            </param>
        </member>
        <member name="P:WizardWrx.FormattingParameters.FormatPrefix">
            <summary>
            This property reports the selected FormatCode enumeration member
            that maps to the specified format prefix character.
            </summary>
        </member>
        <member name="P:WizardWrx.FormattingParameters.BitsPerGroup">
            <summary>
            This property reports the bits per group integer, which may be zero.
            </summary>
        </member>
        <member name="T:WizardWrx.FormattingParameters.FormatCode">
            <summary>
            A read only property maps the format code character onto this
            enumeration.
            </summary>
        </member>
        <member name="F:WizardWrx.FormattingParameters.FormatCode.General">
            <summary>
            The format code prefix is G, General, which permits no modifiers.
            </summary>
        </member>
        <member name="F:WizardWrx.FormattingParameters.FormatCode.BitsHighToLow">
             <summary>
             The format code prefix is H, Bits, which permits an integral
             modifier, causing bits to be displayed from highest to lowest.
            
             This is the conventional display order for visualization of bit
             masks.
             </summary>
        </member>
        <member name="F:WizardWrx.FormattingParameters.FormatCode.BitsLowToHigh">
            <summary>
            The format code prefix is L, Bits, which permits an integral
            modifier, causing bits to be displayed from lowest to highest.
            
            This is an alternative format for use by people who are either
            uncomfortable with the conventional visualization of bit masks
            or are unfamiliar with it.
            </summary>
        </member>
        <member name="T:WizardWrx.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BCLI_INDEX_TOSTRING_TEMPLATE">
            <summary>
              Looks up a localized string similar to TypeHandle = {0}, Subscript = {1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BCLI_TOSTRING_TEMPLATE">
            <summary>
              Looks up a localized string similar to BCLType = {0}, MaximumDecimalDigits = {1}, RequiredStorageBytes = {2}, CapacityInBits = {3}, IsSigned = {4}, GUIDPerType = {5}.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BIT_RULER_TENS_HIGHTOLOW">
            <summary>
              Looks up a localized string similar to    6         5         4         3         2         1          .
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BIT_RULER_TENS_LOWTOHIGH">
            <summary>
              Looks up a localized string similar to           1         2         3         4         5         6   .
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BIT_RULER_UNITS_HIGHTOLOW">
            <summary>
              Looks up a localized string similar to 3210987654321098765432109876543210987654321098765432109876543210.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.BIT_RULER_UNITS_LOW2HIGH">
            <summary>
              Looks up a localized string similar to 0123456789012345678901234567890123456789012345678901234567890123.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_BIT_COUNT_OUT_OF_RANGE">
            <summary>
              Looks up a localized string similar to Value must be greater than zero AND divisible by 8..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_BIT_GROUPS_LESS_THAN_ZERO">
            <summary>
              Looks up a localized string similar to Value most be greater than or equal to zero..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_BIT_GROUPSIZE_MUST_BE_NUMERIC">
            <summary>
              Looks up a localized string similar to The Bits per Group value must be numeric. The specified value is {1}{0}{1}..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_BIT_GROUPSIZE_OUT_OF_RANGE">
            <summary>
              Looks up a localized string similar to The Bits per Group value must be greater than zero..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_ENRICED_FORMAT_EXCEPTION">
            <summary>
              Looks up a localized string similar to An FormatException exception was caught in the Format method on an instance of the BitMaskFormat class.{2}    Format String    = {0}{2}Object to Format = {1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_INVALID_BIT_GROUPSIZE">
            <summary>
              Looks up a localized string similar to The Bits per Group value must be evenly divisible by {0}. The specified value was {1}..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_INVALID_FORMAT_PREFIX_ENUM">
            <summary>
              Looks up a localized string similar to Error in WizardWrx.BitHelpers.FormatBitMask: internal variable fpFormattingParams.FormatPrefix in invalid. The actual value is {0}..
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_INVALID_RULER_STRING">
            <summary>
              Looks up a localized string similar to The ruler string length is incorrect.{2}    Expected length = {0}{2}    Actual length   = {1}.
            </summary>
        </member>
        <member name="P:WizardWrx.Properties.Resources.ERRMSG_TYPE_MUST_BE_INTEGERAL">
            <summary>
              Looks up a localized string similar to Only integeral types are supported..
            </summary>
        </member>
    </members>
</doc>
